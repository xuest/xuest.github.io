<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content=""/>



    <meta name="description" content=""/>


<meta name="Robots" content="all">


    <title>Augustxuesong</title>


<link rel="icon" href="/images/favicon.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/style.css">


<script src="/js/highlight.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >Home</a>
            
                <a class="nav-item" href="/resume"
                
                >Resume</a>
            
                <a class="nav-item" href="/mood"
                
                   target="_blank"
                
                >Mood</a>
            
                <a class="nav-item" href="/amusement/tetris"
                
                   target="_blank"
                
                >Amusement</a>
            
                <a class="nav-item" href="/about"
                
                >About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/12/03/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">Docker 教程讲解</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-12-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/12/03/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">
                    <p>
                        
                            Docker简介Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。
Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。
容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低
Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。
Docker的应用场景
Web 应用的自动化打包和发布。
自动化测试和持续集成、发布。
在服务型环境中部署和调整数据库或其他的后台应用。
从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环

Docker 的优点Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。
1、快速，一致地交付您的应用程序Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。
容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：

您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。
他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。
当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。
测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。

2、响应式部署和扩展Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。
Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。
3、在同一硬件上运行更多工作负载Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。
Docker 架构Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。
Docker 容器通过 Docker 镜像来创建。
容器与镜像的关系类似于面向对象编程中的对象与类。
Docker 包括三个基本概念:

镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。

Docker安装Docker 镜像构建当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。
列出镜像列表我们可以使用 docker images 来列出本地主机上的镜像。
REPOSITORY                                  TAG                 IMAGE ID            CREATED             SIZEregistry.ihdou.com/4.0/v4manage             latest              6f4c3cf49540        30 hours ago        156MB192.168.102.78/4.0/v4manage                 latest              6f4c3cf49540        30 hours ago        156MB192.168.102.78/4.0/v4manage                 v1                  6f4c3cf49540        30 hours ago        156MB192.168.102.78/v4manage                     latest              6f4c3cf49540        30 hours ago        156MB
各个选项说明:

REPOSITORY：表示镜像的仓库源
TAG：镜像的标签
IMAGE ID：镜像ID
CREATED：镜像创建时间
SIZE：镜像大小

同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 v4manage             仓库源里，有 v1、latest               等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。
使用镜像来运行容器
1docker run -t -i 192.168.102.78&#x2F;4.0&#x2F;v4manage:v1 &#x2F;bin&#x2F;bash

参数说明：

-i: 交互式操作。
-t: 终端。
ubuntu:15.10: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。
/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。

获取一个新的镜像当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。
docker pull 192.168.102.78/4.0/v4manage
查找镜像我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： https://hub.docker.com/
我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。
1docker search v4

NAME: 镜像仓库源的名称
DESCRIPTION: 镜像的描述
OFFICIAL: 是否 docker 官方发布
stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。
AUTOMATED: 自动构建
我们决定使用上图中的 httpd 官方版本的镜像，使用命令 docker pull 来下载镜像。
删除镜像镜像删除使用 docker rmi 命令，存在基于当前镜像正在运行的或者stop的容器时，需先停用删除容器，再删除镜像
[root@k8s-master harbor]# docker rmi 6dd206182a84Deleted: sha256:6dd206182a849cad478ba4c1de76bfe3e32625e3e49a56a2585c7000efeaf33fDeleted: sha256:b4d4ea2b50ffda7360439fefde67d6bcc61f9fa1f8ce627261bc44ba5b1c3ab8Deleted: sha256:f12cb102ecabd70a1381e2c5e3b5306d3b30e328d52f5c53c39540cc78e4626fDeleted: sha256:64d6980d5059ddbd51a9dea09062d213dfedf89b25822a629f45d3f4aab4159bDeleted: sha256:38f5bf067c29598625aee277b503b95af493e2d61866012cc90a221b9db2fe67Deleted: sha256:5fc71dd3e480565be4631ad5ca7da3e86ec35becafa8333837e630268971d236Deleted: sha256:f552c10bfa44c286856f36a7d00723448f4e8fd392fab6ac3969840daaabd03e[root@k8s-master harbor]# 
更新镜像更新镜像之前，我们需要使用镜像来创建一个容器。在运行的容器内部使用 apt-get update 命令进行更新
[root@k8s-master harbor]# docker run -t -i 192.168.102.78/4.0/v4manage:v1 /bin/bashroot@d36a4bcbe790:/# apt-get updateGet:1 http://security.debian.org/debian-security buster/updates InRelease [65.4 kB]Get:2 http://deb.debian.org/debian buster InRelease [121 kB]Get:3 http://deb.debian.org/debian buster-updates InRelease [51.9 kB]Get:4 http://security.debian.org/debian-security buster/updates/main amd64 Packages [253 kB]Get:5 http://deb.debian.org/debian buster/main amd64 Packages [7906 kB]Get:6 http://deb.debian.org/debian buster-updates/main amd64 Packages [7856 B]Fetched 8406 kB in 8s (1052 kB/s)Reading package lists… Doneroot@d36a4bcbe790:/# 
在完成操作之后，输入 exit 命令来退出这个容器。
此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。
各个参数说明：

-m: 提交的描述信息
-a: 指定镜像作者
e218edb10161：容器 ID
runoob/ubuntu:v2: 指定要创建的目标镜像名

新增镜像我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像
123456789101112131415161718192021222324# This Nuxt.js Dockerfile# FROM MAINTAINER Xuest# Base images 基础镜像FROM registry.ihdou.com/node:10.15.3-alpine#MAINTAINER 维护者信息MAINTAINER Xuest #ENV 设置环境变量ENV NODE_ENV=productionENV HOST 0.0.0.0#RUN 执行以下命令 RUN mkdir -p /social-statics-app#COPY COPY . /social-statics-app#WORKDIR 相当于cdWORKDIR /social-statics-app#EXPOSE 映射端口EXPOSE 3000RUN npm installRUN npm rebuild node-sassRUN npm run buildRUN npm cache clean --force#CMD 运行以下命令CMD [&quot;npm&quot;, &quot;start&quot;]

Docker 仓库管理仓库（Repository）是集中存放镜像的地方。以下介绍一下 [Docker Hub]。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的
Docker Hub目前 Docker 官方维护了一个公共仓库 Docker Hub。
大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。
注册在 https://hub.docker.com 免费注册一个 Docker 账号。
登录和退出登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。
1$ docker login

退出退出 docker hub 可以使用以下命令：
1$ docker logout

拉取镜像
你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。
以 ubuntu 为关键词进行搜索：
1$ docker search ubuntu

使用 docker pull 将官方 ubuntu 镜像下载到本地：
1$ docker pull ubuntu 

推送镜像用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。
以下命令中的 username 请替换为你的 Docker 账号用户名。
1234567891011$ docker tag ubuntu:18.04 username&#x2F;ubuntu:18.04$ docker image lsREPOSITORY      TAG        IMAGE ID            CREATED           ...  ubuntu          18.04      275d79972a86        6 days ago        ...  username&#x2F;ubuntu 18.04      275d79972a86        6 days ago        ...  $ docker push username&#x2F;ubuntu:18.04$ docker search username&#x2F;ubuntuNAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATEDusername&#x2F;ubuntu


                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">Docker 搭建私有仓库</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-11-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">
                    <p>
                        
                            Harbor私有仓库以Harbor为列搭建私有仓库
一、Harbor概述Habor是由VMWare公司开源的容器镜像仓库。事实上，Habor是在Docker Registry上进行了相应的
企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访
问控制 ，AD/LDAP集成以及审计日志等，足以满足基本企业需求。
官方地址：https://vmware.github.io/harbor/cn/
Github项目地址：https://github.com/goharbor/harbor
安装包下载地址：https://github.com/goharbor/harbor/releases

Harbor相关组件：




组件
功能



harbor-adminserver
配置管理中心


harbor-db
Mysql数据库


harbor-jobservice
负责镜像复制


harbor-log
记录操作日志


harbor-ui
Web管理页面和API


nginx
前端代理，负责前端页面和镜像上传/下载转发


redis
会话


registry
镜像存储


二、Harbor安装1、先安装docker-compose
curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s-uname -m` &gt; /usr/local/bin/docker-compose 
给docker-compose添加执行权限
chmod +x /usr/local/bin/docker-compose
查看docker-compose是否安装成功
docker-compose -version
docker-compose version 1.27.3, build 4092ae5d
2、下载Harbor的压缩包v2.1.1
wget https://github.com/goharbor/harbor/releases/download/v2.1.1/harbor-offline-installer-v2.1.1.tgz
上传压缩包到linux，并解压
tar zxvf harbor-offline-installer-v2.1.1.tgz
修改配置:
cp harbor.yml.tmpl  harbor.yml
vim harbor.yml
修改hostname: 192.168.102.78   密码hd123456
注释掉https默认（如有https另说）
3、安装Harbor
./prepare 
./install.sh
4、启动、停止Harbor
docker-compose up -d 启动 
docker-compose stop 停止 
docker-compose restart 重新启动
5、访问Harbor
http://192.168.102.78
默认账户密码：admin/hd12345
6、配置http镜像仓库可信任
vim /etc/docker/daemon.json    
编辑配置文件 添加一行信任授权内容： {  
​       “insecure-registries”: [“192.168.102.78”]   
 } 
添加完成后重启docker服务： systemctl restart docker

测试实例
docker login 192.168.102.78
admin
hd123456
docker push 192.168.102.78/4.0/v4manage

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 命令大全</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
                    <p>
                        
                            命令介绍docker是传统的CS架构分为docker client和docker server
docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。
docker的镜像管理#查看镜像列表: 
docker images 
docker image ls 
#导出镜像: 
docker image save centos &gt; docker-centos6.9.tar.gz 
#导入镜像: 
docker image load -i docker-centos6.9.tar.gz 
#删除镜像: 
docker image rm centos:latest 
docker image rm 578c3 
#搜索镜像     
docker search + 镜像名字 
#给源中镜像打标签: 
docker tag nginx:latest 10.0.0.11:80/nginx:latest 
#推送指定镜像到docker镜像源服务器 
docker push 10.0.0.11:80/nginx:latest 
#获取镜像    
docker pull image_name 
#官方pull    
docker pull centos:6.8（没有指定版本，默认会下载最新版） 
#私有仓库pull    
docker pull daocloud.io/huangzhichong/alpine-cn:latest 
#显示一个镜像的历史
docker history image_name    
#使用当前目录下的Dockerfile构建镜像
docker build -t  .   
docker的容器管理#查看版本
docker -v     
#查看docker信息    
docker info     
#运行容器 
docker run –name 容器名 -d -p 3306:3306 mysql  
#docker 启动容器 
docker run image_name 
docker run -d -p 80:80 nginx:latest 
（run 创建并运行一个容器 -d 放在后台  -p 端口映射 :docker的容器端口 -P 随机分配端口 
​    -v 源地址(宿主机):目标地址(容器) )
#启动容器
docker run image_name   
#停止容器 
docker stop container_id  
#杀死容器
docker kill container_name   
#查看容器列表
docker ps (-a -l -q)    
#停用并删除容器
docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)
#停止多有容器
docker stop $(docker ps -q)
#删除所有容器
docker rm $(docker ps -aq)
#查看容器列表 
docker ps -a  
#进容器
docker exec -it 77cd6bef4dc9 /bin/bash   
#开启/停止 指定容器id或者容器名称的容器 
docker start/stop container-id||container-name 
#启动容器 -v
docker run -d -p 80:80 -v /opt/xuest:/usr/share/nginx/html nginx:latest 
#查看容器日志
docker logs container-name/container-id     
#查看容器状态 
docker ps | grep ${CONTAINER_ID}    
镜像打包 (保存对容器的修改) 
docker commit ID new_image_name     
提交的描述信息” -a=”作者” 容器id  要创建的目标镜像名:[标签名] 
docker commit -m=””
#查看容器内部详情细节 
docker inspect &lt;id/container_name&gt;   
#登录
docker login 
#退出而不关闭容器 Ctrl+P+Q     
docker run -it –rm –name centos6 centos:6.9 /bin/bash  
-it 分配交互式的终端  
–name 指定容器的名字  
/bin/sh覆盖容器的初始命令 
启动命名：docker run -d -p 80:80  -v   waibulj:内部路径  –name
docker命令集


命令
说明



容器生命周期管理



run
创建一个新容器并运行


start
开启一个容器并使其在后台运行


stop
停止一个容器


restart
重启一个容器


kill
杀掉一个容器进程


rm
删除容器


pause
暂停容器


unpause
恢复暂停容器


create
从镜像中创建一个容器


exec
对一个容器执行shell命令


容器操作



ps
列出容器


inspect
获取容器或镜像的元数据


top
查看正在运行中的容器进程信息


attach
链接正在运行的容器


events
从docker服务器获取事件


logs
获取docker日志


wait
让一个容器进入等待，使其进入阻塞状态


export
讲一个容器的文件系统打包至tar


port
列出一个容器的端口映射情况


container
管理已经运行的容器的


deploy
部署新的堆栈或更新已有堆栈的


update
更新容器


rename
重命名容器


volume
卷管理


容器文件系统操作



commit
提交一个容器的文件系统，使之生成一个新的镜像


cp
向一个正在运行的容器复制文件，或将容器中的文件复制出来


diff
检查一个容器文件系统更改情况


镜像仓库操作



login
docker登入


logout
docker登出


pull
拉取镜像


push
推送镜像至服务器


search
在docker hub上查询镜像


镜像管理



images
列出镜像


rmi
删除镜像


tag
修改本地某一镜像的标记，使其镜像属于某一仓库


build
通过指定Dockerfile文件编译镜像


history
查看镜像历史


save
将制定镜像保存成tar文件


load
从tar中恢复镜像


import
从tar中创建一个新镜像


checkpoint
设置checkpoint，类似于恢复点，可以让镜像撤销到曾经设置的某一个checkpoint上


image
docker镜像管理


manifest
docker镜像清单管理


trust
docker可信镜像管理


集群管理



swarm
docker集群管理工具


node
docker集群节点控制


stack
docker集群堆栈管理


其他命令



info
查询docker信息


version
查询docker版本


system
docker系统管理


stats
docker容器资源使用统计


config
管理docker配置


network
docker网络管理


plugin
docker插件管理


secret
docker敏感信息管理


service
docker服务管理


run命令
docker run命令是创建一个新容器并运行，若本地不存在该容器镜像会直接去镜像仓库中查找并自动下载。

语法：
12docker run [OPTIONS] IMAGE [COMMAND] [ARG...]1

命令参数说明：



参数名
默认
说明
特殊示例



–add-host

为容器添加一个host to ip的映射关系，可以添加若干个，且容器重启后不会消失。若直接修改容器中的/etc/hosts文件，容器重启后会消失
docker run –add-host localhost:127.0.0.1 ubuntu:latest


–attach(-a)

将容器的stdin,stdout,stderr【标准输入，标准输出，错误输出】关联到本地shell中，在执行docker run时，将所有输入输出指定到本地shell中，若执行时携带此参数，可以指定将stdin,stdout,stderr的某一个或某几个关联到本地shell



–blkio-weight
0
限制容器读写权重，当宿主机有1个以上容器时，可以设置容器的读写优先权，权重值在10～1000之间，0为关闭权重（该参数默认为0）



–blkio-weight-device
0
设置针对指定设备的权重，权重值在10～1000之间，且优先级高于blkio.weight
docker run –blkio-weight-device “/dev/sda:100” ubuntu:latest


–cap-add

增强linux能力，在docker容器内限制了大部分的linux能力，在之前，需要开启这些功能需要结合--privileged开启特权模式才能使用这些参数，考虑到安全性，可以通过该参数来开启指定的linux功能【默认开启的功能及全部定义详见docker runc】，若参数为all则默认开启所有linux能力



–cap-drop

移除linux能力



–cgroup-parent

配置容器的控制组，继承该控制组的资源限制模式。扩展阅读:linux cgroup



–cidfile

创建一个容器，并将该容器的pid输出到某一文件中，若该文件存在，则会返回一个错误
docker run –cidfile /tmp/docker_test.cid ubuntu echo “test”


–cpu-count
0
设置容器cpu数量仅限Windows版本



–cpu-percent
0
设置容器CPU使用百分比仅限Windows版本



–cpu-period
0
与参数–cpu-quota配合使用，用于设定cpu从新分配资源的时间周期,时间周期结束后，会对cpu进行重新分配。



–cpu-quota
0
与参数–cpu-period配合使用，用于设定该容器在资源分配周期内占用cpu的时间，若容器设定–cpu-quota=1000000 –cpu-period=500000，则该容器在这个时间周期内权重为50%，这两个参数主要是提升宿主机内某一容器的权重比，可以用来解决宿主机内若干容器的资源抢占导致重要容器cpu性能不足的场景。该模式应用于Linux 的CFS模式，扩展阅读：完全公平调度程序(CFS)



–cpu-rt-period
0
–cpu-period的微秒版



–cpu-rt-runtime
0
在一个cpu资源分配周期内，优先保证某容器的cpu使用的最大微秒数。例如，默认周期为 1000000 微秒（1秒），设置 –cpu-rt-runtime=950000 可确保使用实时调度程序的容器每 1000000 微秒可运行 950000 微秒，并保留至少 50000 微秒用于非实时任务。



–cpu-shares(-c)
0
设置容器CPU权重，可以用于调整容器在单位分配周期内的资源优先使用比



–cpus

设置容器使用cpu的数量，该参数为1.3新增参数用于快速设置容器对于cpu的占用，例如示例，可以直接设置该容器使用多少cpu
docker run –cpus=”.5” ubuntu:latest


–cpuset-cpus

设置容器允许在哪个cpu上执行该进程，譬如–cpuset-cpus=”1,3”为指定在cpu 1 和cpu 3上执行，–cpuset-cpus=”0-2”为指定在cpu0,cpu1,cpu2上执行
docker run –cpuset-cpus=”1,3” ubuntu:latest docker run –cpuset-cpus=”0-2” ubuntu:latest


–cpuset-mems

同参数--cpuset-cpus，但该参数是作用于NUMA 架构的 CPU
docker run –cpuset-mems=”1,3” ubuntu:latest docker run –cpuset-mems=”0-2” ubuntu:latest


–detach(-d)
false
指定该容器运行于前台还是后台



–detach-keys

设置容器的键盘映射键位，在容器被链接到前台时，若宿主机的键盘键位与容器键位冲突，可以使用该指令对容器的键位进行重新映射



–device

将宿主机的设备映射至容器



–device-cgroup-rule

将宿主机的设备添加到cgroup规则列表中



–device-read-bps

以字节数/每秒的形式限制设备的读取速率
docker run –device-read-bps /dev/sda:100KB ubuntu:latest


–device-read-iops

以每秒所执行IO操作的次数的形式限制设备的读取速率
docker run –device-read-iops /dev/sda:10 ubuntu:latest


–device-write-bps

以字节数/每秒的形式限制设备的写入速率



–device-write-iops

以每秒所执行IO操作的次数的形式限制设备的写入速率



–disable-content-trust
true
忽略镜像的校验



–dns

指定容器使用的DNS服务器，默认和宿主一致



–dns-opt

设置DNS选项，同修改/etc/resolv.conf文件



–dns-option

设置DNS选项，同修改/etc/resolv.conf文件



–dns-search

指定容器DNS搜索域名，默认和宿主一致



–entrypoint

覆盖Dockerfile中设置的entrypoint命令



–env(-e)

设置/新增环境变量



–env-file

读取本地环境变量文件，并加载到容器中



–expose

开放一个端口或一组端口



–group-add

为容器添加用户组



–health-cmd

执行一个健康检查命令



–health-interval
0
配合--health-cmd参数，设置健康检查的执行的间隔时间（ms | s | m | h）



–health-retries
0
配合--health-cmd参数，设置健康检查命令失败重试的次数



–health-start-period
0
配合--health-cmd参数，设置健康检查的启动时间（ms | s | m | h）



–health-timeout
0
配合--health-cmd参数，设置健康检查命令超时时间（ms | s | m | h）



–help
false
帮助



–hostname(-h)

指定容器的hostname



–init
false
使用tini工具在容器中新增一个守护进程，来预防该容器出现僵尸进程的可能性



–interactive (-i)
false
以交互模式运行容器，并将容器的STDIN（标准输入）打开，通常与参数--tty (-t)配合使用



–io-maxbandwidth
0
限制容器IO最大速率仅限Windows版本



–io-maxiops
0
以每秒所执行IO操作的次数的形式限制设备的读取速率仅限Windows版本



–ip

设置容器的IPv4地址



–ip6

设置容器的IPv6地址



–ipc

启用ipc命名空间。在docker容器中进程交互采用了Linux常见的进程间交互方法(interprocess communication - IPC), 包括信号量、消息队列和共享内存等。容器的进程间交互实际上还是host上具有相同pid命名空间中的进程间交互，因此需要在IPC资源申请时加入命名空间信息，每个IPC资源有一个唯一的32位id。



–isolation

使用容器隔离。该参数拥有三个值 (1)default 即与使用dockerd –exec-opt的参数默认效果相同 (2)process 使用linux内核命名空间进行隔离，该参数不支持windows环境。 （3）使用微软的Hyper-V虚拟技术进行隔离，该参数仅限windows环境



–kernel-memory
0
限制该容器内核的内存使用



–label (-l)

设置该容器的元数据



–label-file

通过本地文件导入元数据至该容器



–link

指定容器间的关联，使用其他容器的IP、env等信息



–link-local-ip

设置本地链路地址（link-local address）ip



–log-driver

设置一个指定日志接受工具，用于动态收集日志。扩展阅读日志处理与log-driver实现



–log-opt

配合参数--log-driver使用，用于设置日志输出参数



–mac-address

设置该容器mac地址



–memory -m
0
限制该容器内存使用



–memory-reservation
0
软限制该容器的内存使用，当宿主机内存空闲时，该容器的内存使用可以一定比例超出限制，但当宿主机内存紧张时，会强制该容器内存使用限制在该参数之内



–memory-swap
0
内存交换分区大小限制。配合参数--memory使用，且最小内存交换限制应该大于内存限制。该参数有4种情况： (1)不设置–memory与该参数:则该容器默认可以用完宿舍机的所有内存和 宿主机 swap 分区。 (2)设置–memory 50MB 不设置–memory-swap（默认为0）:则–memory-swap值等于限制内存大小，即该容器能够申请的最大内存为100MB。 (3)设置–memory 50MB –memory-swap为-1:则该容器最大可以申请的内存为50MB+宿主机swap分区大小 (4)设置–memory 50MB –memory-swap 100MB：则该容器可以申请的最大内存为100MB-50MB=50MB



–memory-swappiness
-1
用于调整虚拟内存的控制行为，为0～100之间的整数。在linux内存管理中，将内存中不活跃的页交换至硬盘中，以缓解内存紧张，该参数设置为0则认定该容器所有内存中的内容均不允许交换至硬盘，用以保障最大性能，若设置为100，则认为该容器所有内存中的数据均可以交换至硬盘。扩展阅读Linux内存管理



–mount

将文件系统挂载附加到容器



–name

设置该容器的名称



–net

将容器连接到网络，支持bridge/host/none/container四种类型



–net-alias

设置该容器在网络上的别名



–network

将容器连接到网络，支持bridge/host/none/container四种类型



–network-alias

设置该容器在网络上的别名



–no-healthcheck
false
禁止一切健康检查行为



–oom-kill-disable
false
设置是否禁止oom kill行为，若该容器因为需要大量请求内存，导致宿主机内存不足或触发到内存限制，导致杀死该容器进程，若设置该参数为true则会关闭这个检查



–oom-score-adj
0
调整主机的OOM首选项（从-1000到1000）此处需要注意的是，非专业人士docker官方是不建议用户修改--oom-score-adj``--oom-kill-disable这两个参数的



–pid

自定义设置该容器的pid



–pids-limit
0
该参数值为整数，为限制该容器所能创建的最大进程数。



–privileged
false
在该容器上开启特权模式，让该容器拥有所有的linux能力



–publish -p

将容器的端口映射到宿主机上
docker run -p 8000:8000 ubuntu


–publish-all (-P)
false
将该容器的所有端口均随机映射至宿主机



–read-only
false
设置该容器只读



–restart
no
在退出该容器时重启该容器



–rm
false
当退出该容器时自动删除该容器资源



–runtime

指定该容器关联一个runtime的容器，在使用该参数时注意runtime specified必须在dockerd --add-runtime注册过。扩展阅读什么是容器的runtime与Docker、Containerd、RunC之间的进程关系



–security-opt

设置安全属性，在windows上使用CredentialSpec模块来执行身份识别。



–shm-size
0
设置/dev/shm/目录的大小



–sig-proxy
true
代理进程所接收的所有字符,当指定–sig-proxy=false时，ctrl+c和ctrl+d 不会传递信号给docker进程而关闭容器。



–stop-signal
SIGTERM
停止带有信号的容器，在linux环境下输入kill -l,就可以看到所有信号名称，可以指定容器发出某种信号时停止该容器，譬如SIGKILL



–stop-timeout
0
设置容器调用命令超时后自动退出。该参数可以设置容器在调用命令时导致超时后多少秒退出，0为永远不退出，该参数单位为秒



–storage-opt

设定该容器的存储空间，可以分别指定dm.basesize、dm.loopdatasize、dm.loopmetadatasize等项,指定单个容器可用数据空间、docker可用数据空间、元数据可用数据空。
docker run –storage-opt dm.basesize=20G ubuntu


–sysctl
map[]
修改内核参数，对应修改容器中的/etc/sysctl.conf文件



–tmpfs

指定挂载一个tmpfs目录，tmpfs是一种虚拟内存文件系统。可以不经由镜像直接创建一个容器
docker run -d –tmpfs /run:rw,noexec,nosuid,size=65536k my_image


–tty (-t)
false
为容器重新分配一个伪输入终端，通常与参数--interactive (-i)同时使用



–ulimit

设置容器的ulimit选项，扩展阅读ulimit命令



–user (-u)

在该容器下添加新用户



–userns

指定该容器运行在指定host user namespace中



–uts

使用uts命名空间。扩展阅读Linux命名空间入门



–volume (-v)

在该容器下挂载新卷



–volume-driver

挂载一个卷容器，该卷可以是一个本地共享卷或者一个远程服务，配合docker volume create命令创建一个卷



–volumes-from

可以将任意文件夹反挂载到卷中，从而快速实现对该容器的备份与迁移。
docker run –rm –volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata


–workdir (-w)

指定容器的工作目录与Dockerfile中的WORKDIR作用相同










start命令
docker start是用于启动容器的命令


语法：
12docker start [OPTIONS] CONTAINER [CONTAINER...]1

容器运维操作–attach命令docker attach命令对应开发者很有用，可以连接到正在运行的容器，观察容器的运行状况，或与容器的主进程进行交互。
–inspect命令用于查看镜像和容器的详细信息，默认会列出全部信息，可以通过–format参数来指定输出的模板格式，以便输出特定信息。
查看容器的信息container（ps）docker ps命令可以查看容器的CONTAINER ID、NAME、IMAGE NAME、端口开启及绑定、容器启动后执行的COMMNAD。最常用的功能是通过ps来找到CONTAINER_ID，以便对特定容器进行操作。docker ps 默认显示当前正在运行中的containerdocker ps -a 查看包括已经停止的所有容器docker ps -l 显示最新启动的一个容器（包括已停止的）
示例
1234[devadmin@swarm1 ~]$ docker ps -lCONTAINER ID        IMAGE                                            COMMAND              CREATED             STATUS              PORTS                      NAMES1cfb8ad8642e        regloc.com&#x2F;test&#x2F;settlequery:201711271708   &quot;sh entrypoint.sh&quot;   22 hours ago        Up 22 hours         0.0.0.0:18182-&gt;18182&#x2F;tcp   settlequery.z4taavbos34np74za1bu674az.ncj2uocqbh15ljxhui0yccd9t[devadmin@swarm1 ~]$ 



– 列出机器上的镜像（images）1234# docker images REPOSITORY               TAG             IMAGE ID        CREATED         VIRTUAL SIZEubuntu                   14.10           2185fd50e2ca    13 days ago     236.9 MB…

其中我们可以根据REPOSITORY来判断这个镜像是来自哪个服务器，如果没有 / 则表示官方镜像，类似于username/repos_name表示Github的个人公共库，类似于regsistory.example.com:5000/repos_name则表示的是私服。IMAGE ID列其实是缩写，要显示完整则带上--no-trunc选项
2. 在docker index中搜索image（search）1234Usage: docker search TERM# docker search seanloNAME                DESCRIPTION           STARS     OFFICIAL   AUTOMATEDseanloook&#x2F;centos6   sean&#39;s docker repos         0

搜索的范围是官方镜像和所有个人公共镜像。NAME列的 / 后面是仓库的名字。
3. 从docker registry server 中下拉image或repository（pull）12Usage: docker pull [OPTIONS] NAME[:TAG]# docker pull centos

上面的命令需要注意，在docker v1.2版本以前，会下载官方镜像的centos仓库里的所有镜像，而从v.13开始官方文档里的说明变了：will pull the centos:latest image, its intermediate layers and any aliases of the same id，也就是只会下载tag为latest的镜像（以及同一images id的其他tag）。也可以明确指定具体的镜像：
1# docker pull centos:centos6

当然也可以从某个人的公共仓库（包括自己是私人仓库）拉取，形如docker pull username/repository&lt;:tag_name&gt; ：
1# docker pull seanlook&#x2F;centos:centos6

如果你没有网络，或者从其他私服获取镜像，形如docker pull registry.domain.com:5000/repos:&lt;tag_name&gt;
1# docker pull dl.dockerpool.com:5000&#x2F;mongo:latest

4. 推送一个image或repository到registry（push）与上面的pull对应，可以推送到Docker Hub的Public、Private以及私服，但不能推送到Top Level Repository。
12# docker push seanlook&#x2F;mongo# docker push registry.tp-link.net:5000&#x2F;mongo:2014-10-27

registry.tp-link.net也可以写成IP，172.29.88.222。在repository不存在的情况下，命令行下push上去的会为我们创建为私有库，然而通过浏览器创建的默认为公共库。
5. 从image启动一个container（run）docker run命令首先会从特定的image创之上create一层可写的container，然后通过start命令来启动它。停止的container可以重新启动并保留原来的修改。run命令启动参数有很多，以下是一些常规使用说明当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：

检查本地是否存在指定的镜像，不存在就从公有仓库下载
利用镜像创建并启动一个容器
分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
从地址池配置一个 ip 地址给容器
执行用户指定的应用程序
执行完毕后容器被终止

1Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

5.1 使用image创建container并执行相应命令，然后停止12# docker run ubuntu echo &quot;hello world&quot;hello word

这是最简单的方式，跟在本地直接执行echo &#39;hello world&#39; 几乎感觉不出任何区别，而实际上它会从本地ubuntu:latest镜像启动到一个容器，并执行打印命令后退出（docker ps -l可查看）。需要注意的是，默认有一个--rm=true参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。容器启动后会自动随机生成一个CONTAINER ID，这个ID在后面commit命令后可以变为IMAGE ID
使用image创建container并进入交互模式, login shell是/bin/bash12# docker run -i -t --name mytest centos:centos6 &#x2F;bin&#x2F;bashbash-4.1#

上面的--name参数可以指定启动后的容器名字，如果不指定则docker会帮我们取一个名字。镜像centos:centos6也可以用IMAGE ID (68edf809afe7) 代替），并且会启动一个伪终端，但通过ps或top命令我们却只能看到一两个进程，因为容器的核心是所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外，并没有其它的资源，可见Docker对资源的利用率极高。此时使用exit或Ctrl+D退出后，这个容器也就消失了（消失后的容器并没有完全删除？）（那么多个TAG不同而IMAGE ID相同的的镜像究竟会运行以哪一个TAG启动呢
5.2 运行出一个container放到后台运行12# docker run -d ubuntu &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 2; done&quot;ae60c4b642058fefcc61ada85a610914bed9f5df0e2aa147100eab85cea785dc

它将直接把启动的container挂起放在后台运行（这才叫saas），并且会输出一个CONTAINER ID，通过docker ps可以看到这个容器的信息，可在container外面查看它的输出docker logs ae60c4b64205，也可以通过docker attach ae60c4b64205连接到这个正在运行的终端，此时在Ctrl+C退出container就消失了，按ctrl-p ctrl-q可以退出到宿主机，而保持container仍然在运行另外，如果-d启动但后面的命令执行完就结束了，如/bin/bash、echo test，则container做完该做的时候依然会终止。而且-d不能与–rm同时使用可以通过这种方式来运行memcached、apache等。
5.3 映射host到container的端口和目录映射主机到容器的端口是很有用的，比如在container中运行memcached，端口为11211，运行容器的host可以连接container的 internel_ip:11211 访问，如果有从其他主机访问memcached需求那就可以通过-p选项，形如-p &lt;host_port:contain_port&gt;，存在以下几种写法：
1234-p 11211:11211 这个即是默认情况下，绑定主机所有网卡（0.0.0.0）的11211端口到容器的11211端口上-p 127.0.0.1:11211:11211 只绑定localhost这个接口的11211端口-p 127.0.0.1::5000-p 127.0.0.1:80:8080

目录映射其实是“绑定挂载”host的路径到container的目录，这对于内外传送文件比较方便，在搭建私服那一节，为了避免私服container停止以后保存的images不被删除，就要把提交的images保存到挂载的主机目录下。使用比较简单，-v &lt;host_path:container_path&gt;，绑定多个目录时再加-v。
1-v &#x2F;tmp&#x2F;docker:&#x2F;tmp&#x2F;docker

另外在两个container之间建立联系可用--link，下面是一个例子：
1234# docker run --name nginx_test \&gt; -v &#x2F;tmp&#x2F;docker:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:ro \&gt; -p 80:80 -d \&gt; nginx:1.7.6

在主机的/tmp/docker下建立index.html，就可以通过http://localhost:80/或http://host-ip:80访问了。
6. 将一个container固化为一个新的image（commit）当我们在制作自己的镜像的时候，会在container中安装一些工具、修改配置，如果不做commit保存起来，那么container停止以后再启动，这些更改就消失了。docker commit &lt;container&gt; [repo:tag]后面的repo:tag可选只能提交正在运行的container，即通过docker ps可以看见的容器，
123456789101112131415161718查看刚运行过的容器# docker ps -lCONTAINER ID   IMAGE     COMMAND      CREATED       STATUS        PORTS   NAMESc9fdf26326c9   nginx:1   nginx -g..   3 hours ago   Exited (0)..     nginx_test启动一个已存在的容器（run是从image新建容器后再启动），以下也可以使用docker start nginx_test代替  [root@hostname docker]# docker start c9fdf26326c9c9fdf26326c9docker run -i -t --sig-proxy&#x3D;false 21ffe545748baf &#x2F;bin&#x2F;bashnginx服务没有启动# docker commit -m &quot;some tools installed&quot; fcbd0a5348ca seanlook&#x2F;ubuntu:14.10_tutorialfe022762070b09866eaab47bc943ccb796e53f3f416abf3f2327481b446a9503请注意，当你反复去commit一个容器的时候，每次都会得到一个新的&#96;IMAGE ID&#96;，假如后面的&#96;repository:tag&#96;没有变，通过&#96;docker images&#96;可以看到，之前提交的那份镜像的&#96;repository:tag&#96;就会变成&#96;&lt;none&gt;:&lt;none&gt;&#96;，所以尽量避免反复提交。另外，观察以下几点:


commit container只会pause住容器，这是为了保证容器文件系统的一致性，但不会stop。如果你要对这个容器继续做其他修改：
你可以重新提交得到新image2，删除次新的image1
也可以关闭容器用新image1启动，继续修改，提交image2后删除image1
当然这样会很痛苦，所以一般是采用Dockerfile来build得到最终image，参考[]


虽然产生了一个新的image，并且你可以看到大小有100MB，但从commit过程很快就可以知道实际上它并没有独立占用100MB的硬盘空间，而只是在旧镜像的基础上修改，它们共享大部分公共的“片”。

下
1. 开启/停止/重启container（start/stop/restart）容器可以通过run新建一个来运行，也可以重新start已经停止的container，但start不能够再指定容器启动时运行的指令，因为docker只能有一个前台进程。容器stop（或Ctrl+D）时，会在保存当前容器的状态之后退出，下次start时保有上次关闭时更改。而且每次进入attach进去的界面是一样的，与第一次run启动或commit提交的时刻相同。
123CONTAINER_ID&#x3D;$(docker start &lt;containner_id&gt;)docker stop $CONTAINER_IDdocker restart $CONTAINER_ID

2. 连接到正在运行中的container（attach）要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。
1# docker attach --sig-proxy&#x3D;false $CONTAINER_ID

3. 查看image或container的底层信息（inspect）inspect的对象可以是image、运行中的container和停止的container。
123查看容器的内部IP# docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; $CONTAINER_ID172.17.42.35

4. 删除一个或多个container、image（rm、rmi）你可能在使用过程中会build或commit许多镜像，无用的镜像需要删除。但删除这些镜像是有一些条件的：

同一个IMAGE ID可能会有多个TAG（可能还在不同的仓库），首先你要根据这些 image names 来删除标签，当删除最后一个tag的时候就会自动删除镜像；
承上，如果要删除的多个IMAGE NAME在同一个REPOSITORY，可以通过docker rmi &lt;image_id&gt;来同时删除剩下的TAG；若在不同Repo则还是需要手动逐个删除TAG；
还存在由这个镜像启动的container时（即便已经停止），也无法删除镜像；

TO-DO如何查看镜像与容器的依存关系
删除容器docker rm &lt;container_id/contaner_name&gt;
12删除所有停止的容器docker rm $(docker ps -a -q)

删除镜像docker rmi &lt;image_id/image_name …&gt;`
5. docker build 使用此配置生成新的imagebuild命令可以从Dockerfile和上下文来创建镜像：docker build [OPTIONS] PATH | URL | -上面的PATH或URL中的文件被称作上下文，build image的过程会先把这些文件传送到docker的服务端来进行的。如果PATH直接就是一个单独的Dockerfile文件则可以不需要上下文；如果URL是一个Git仓库地址，那么创建image的过程中会自动git clone一份到本机的临时目录，它就成为了本次build的上下文。无论指定的PATH是什么，Dockerfile是至关重要的，请参考Dockerfile Reference。请看下面的例子：
123456789101112131415161718# cat Dockerfile FROM seanlook&#x2F;nginx:bash_vimEXPOSE 80ENTRYPOINT &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &amp;&amp; &#x2F;bin&#x2F;bash# docker build -t seanlook&#x2F;nginx:bash_vim_Df .Sending build context to Docker daemon 73.45 MBSending build context to Docker daemon Step 0 : FROM seanlook&#x2F;nginx:bash_vim ---&gt; aa8516fa0bb7Step 1 : EXPOSE 80 ---&gt; Using cache ---&gt; fece07e2b515Step 2 : ENTRYPOINT &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &amp;&amp; &#x2F;bin&#x2F;bash ---&gt; Running in e08963fd5afb ---&gt; d9bbd13f5066Removing intermediate container e08963fd5afbSuccessfully built d9bbd13f5066

上面的PATH为.，所以在当前目录下的所有文件（不包括.dockerignore中的）将会被tar打包并传送到docker daemon（一般在本机），从输出我们可以到Sending build context...，最后有个Removing intermediate container的过程，可以通过--rm=false来保留容器。TO-DOdocker build github.com/creack/docker-firefox失败。
6. 给镜像打上标签（tag）tag的作用主要有两点：一是为镜像起一个容易理解的名字，二是可以通过docker tag来重新指定镜像的仓库，这样在push时自动提交到仓库。
12345将同一IMAGE_ID的所有tag，合并为一个新的# docker tag 195eb90b5349 seanlook&#x2F;ubuntu:rm_test新建一个tag，保留旧的那条记录# docker tag Registry&#x2F;Repos:Tag New_Registry&#x2F;New_Repos:New_Tag

7. 查看容器的信息container（ps）docker ps命令可以查看容器的CONTAINER ID、NAME、IMAGE NAME、端口开启及绑定、容器启动后执行的COMMNAD。经常通过ps来找到CONTAINER_ID。docker ps 默认显示当前正在运行中的containerdocker ps -a 查看包括已经停止的所有容器docker ps -l 显示最新启动的一个容器（包括已停止的）
8. 查看容器中正在运行的进程（top）容器运行时不一定有/bin/bash终端来交互执行top命令，查看container中正在运行的进程，况且还不一定有top命令，这是docker top &lt;container_id/container_name&gt;就很有用了。实际上在host上使用ps -ef|grep docker也可以看到一组类似的进程信息，把container里的进程看成是host上启动docker的子进程就对了。
9. 其他命令docker还有一些如login、cp、logs、export、import、load、kill等不是很常用的命令，比较简单，请参考官网。
events、history和logs命令这3个命令用于查看Docker的系统日志信息。events命令会打印出实时的系统事件；history命令会打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的命令记录；logs命令会打印出容器中进程的运行日志。
docker events [options] ：从服务器获取实时事件。
OPTIONS说明：

-f ：根据条件过滤事件；
–since ：从指定的时间戳后显示所有事件;
–until ：流水时间显示到指定的时间为止；

docker history [options] image：查看指定镜像的创建历史。
OPTIONS说明：

**-H :**以可读的格式打印镜像大小和日期，默认为true；
**–no-trunc :**显示完整的提交记录；
**-q :**仅列出提交记录ID。

docker logs [options] container
123456Options:        --details        显示更多的信息    -f, --follow         跟踪日志输出，最后一行为当前时间戳的日志        --since string   显示自具体某个时间或时间段的日志        --tail string    从日志末尾显示多少行日志， 默认是all    -t, --timestamps     显示时间戳

FROM registry.ihdou.com/node:10.15.3-alpineMAINTAINER CharlieENV NODE_ENV=productionENV HOST 0.0.0.0RUN mkdir -p /social-statics-appCOPY . /social-statics-appWORKDIR /social-statics-appEXPOSE 3000RUN apk add –no-cache make gcc g++ pythonRUN npm installRUN npm rebuild node-sassRUN npm run buildRUN npm cache clean –forceRUN apk del make gcc g++ pythonCMD [“npm”, “start”]
镜像构建：
docker build -t social-statics-app .
docker build -t registry.ihdou.com/search .
项目启动命令：
docker run -dt –rm  -p 3000:3000 social-statics-app
docker run -it –rm  -v /usr/local/jars:/logs –name zuul zuul
docker run -it –rm -p 10014:10014  -v /usr/local/jars:/logs –name search search:v1
docker run -it –rm -p 38012:38012  -v /usr/local/jars:/logs registry.ihdou.com/4.0/wallet

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">Docker Dockerfile</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">
                    <p>
                        
                            Dockerfile什么是 Dockerfile？Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。
一.Dockerfile基本结构一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令
123456789101112131415161718192021222324# This Nuxt.js Dockerfile# FROM MAINTAINER Xuest# Base images 基础镜像FROM registry.ihdou.com/node:10.15.3-alpine#MAINTAINER 维护者信息MAINTAINER Xuest #ENV 设置环境变量ENV NODE_ENV=productionENV HOST 0.0.0.0#RUN 执行以下命令 RUN mkdir -p /social-statics-app#COPY COPY . /social-statics-app#WORKDIR 相当于cdWORKDIR /social-statics-app#EXPOSE 映射端口EXPOSE 3000RUN npm installRUN npm rebuild node-sassRUN npm run buildRUN npm cache clean --force#CMD 运行以下命令CMD [&quot;npm&quot;, &quot;start&quot;]

1、FROM : 指定基础镜像，要在哪个镜像建立
格式为 FROM &lt;image&gt; 或FROM &lt;image&gt;:&lt;tag&gt; 。
第一条指令必须为 FROM 指令。**定制的镜像都是基于 FROM 的镜像，这里的 image就是定制需要的基础镜像。后续的操作都是基于 image。
2、MAINTAINER：指定维护者信息
格式为 MAINTAINER &lt;name&gt;
3、RUN：在镜像中要执行的命令
格式为 RUN &lt;command&gt; 或 RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]，前者将在 shell 终端中运行命令，即 /bin/bash -c ；后者则使用 exec 执行。指定使用其它终端可以通过第二种方式实现，例如 RUN [“/bin/bash”, “-c”,”echo hello”] 。
4、WORKDIR：指定当前工作目录，相当于 cd
格式为 WORKDIR /path/to/workdir
5、EXPOSE：指定容器要打开的端口
格式为 EXPOSE &lt;port&gt; [&lt;port&gt;...]，告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。
6、ENV：定义环境变量
格式为 ENV &lt;key&gt; &lt;value&gt; 。 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。
ENV PATH /usr/local/nginx/sbin:$PATH
7、COPY 
复制本地主机的 （为 Dockerfile 所在目录的相对路径）到容器中的
8、ADD
相当于 COPY，但是比 COPY 功能更强大
格式为 ADD &lt;src&gt; &lt;dest&gt;，该命令将复制指定的 到容器中的 。 其中 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件，复制进容器会自动解压。
9、VOLUME
挂载目录 格式为VOLUME [&quot;/data&quot;]，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。
10、USER
格式为 USER daemon，指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： RUN useradd -s /sbin/nologin -M www。
11、ENTRYPOINT
ENTRYPOINT [“executable”, “param1”, “param2”] ENTRYPOINT command param1 param2 （shell中执行）
配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效。
12、CMD
CMD [“executable”,”param1”,”param2”] 使用 exec 执行，推荐方式；CMD command param1 param2 在 /bin/bash 中执行，提供给需要交互的应用；CMD [“param1”,”param2”] 提供给 ENTRYPOINT 的默认参数；指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令
13、ONBUILD
格式为 ONBUILD [INSTRUCTION]，在构建本镜像时不生效，在基于此镜像构建镜像时生效。配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。
注意：
ENTRYPOINT 和 CMD 的区别：ENTRYPOINT 指定了该镜像启动时的入口，CMD 则指定了容器启动时的命令，当两者共用时，完整的启动命令像是 ENTRYPOINT + CMD 这样。使用 ENTRYPOINT 的好处是在我们启动镜像就像是启动了一个可执行程序，在 CMD 上仅需要指定参数；另外在我们需要自定义 CMD 时不容易出错。
使用 CMD 的 Dockerfile：
1[root@sta2 test]# cat Dockerfile FROM mysql CMD [&quot;echo&quot;,&quot;test&quot;]

使用 ENTRYPOINT 的 Dockerfile
1[root@sta2 entrypoint]#  cat  Dockerfile FROM mysql ENTRYPOINT [&quot;echo&quot;,&quot;test&quot;]

结论：ENTRYPOINT 不能覆盖掉执行时的参数，CMD 可以掉覆盖默认的参数。
demo
Jar例子：
FROM registry.ihdou.com/java8LABEL maintainer XuestADD social-search-server-1.0.0-SNAPSHOT.jar search.jarEXPOSE 10014 19997ENTRYPOINT [“java”,”-jar”,”search.jar”]
VUE Nuxt例子：
FROM registry.ihdou.com/node:10.15.3-alpineMAINTAINER XuestENV NODE_ENV=productionENV HOST 0.0.0.0RUN mkdir -p /social-statics-appCOPY . /social-statics-appWORKDIR /social-statics-appEXPOSE 3000RUN npm installRUN npm rebuild node-sassRUN npm run buildRUN npm cache clean –forceCMD [“npm”, “start”]
VUE静态：
FROM registry.ihdou.com/tool/nginxRUN mkdir /usr/share/nginx/html/v4manageCOPY nginx.conf /etc/nginx/nginx.confCOPY ./v4manage /usr/share/nginx/html/v4manageEXPOSE 80
&lt;覆盖容器nginx配置&gt;
nginx根目录：/usr/share/nginx/html/
nginx配置地址：/etc/nginx/nginx.conf
        server &#123;
                listen       80;
                server_name  localhost;
                root    /usr/share/nginx/html/v4manage/;
                location / &#123;
                        try_files $uri $uri/ @router;
                        index  index.html index.htm;
                &#125;
                location @router &#123;
                        rewrite ^.*$ /index.html last;
                &#125;
        &#125;
二.创建镜像1、使用Dockerfile构建镜像
docker build -t v4manage .  
2.给镜像打标签
docker tag v4manage  192.168.102.78/4.0/ v4manage 
3.Push仓库
docker push 192.168.102.78/4.0/ v4manage
[root@k8s-master harbor]# docker tag 192.168.102.78/v4manage 192.168.102.78/4.0/v4manage[root@k8s-master harbor]# docker push 192.168.102.78/4.0/v4manageThe push refers to repository [192.168.102.78/4.0/v4manage]518ec4362654: Pushedba2c6d9de847: Pushed6f40d5797506: Pushed7e914612e366: Pushedf790aed835ee: Pushed850c2400ea4d: Pushed7ccabd267c9f: Pushedf5600c6330da: Pushedlatest: digest: sha256:9f920ab7c9e5f5b5f9673b013b2b68193ca80c0a5236d7c72484e473abe3f659 size: 1987

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/03/Elasticsearch%E9%9B%86%E7%BE%A4/">Elasticsearch集群搭建</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/03/Elasticsearch%E9%9B%86%E7%BE%A4/">
                    <p>
                        
                            Elasticsearch集群搭建1.1 安装准备
1.1.1**下载安装包**
https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.2.tar.gz
1.1.2 服务器准备
为搭建ElasticSearch集群，准备了二台服务器，主机IP分别为：



服务器IP
系统版本



192.168.102.151
Centos7.5


192.168.102.11
Centos7.5






1.1.3 新建用户
ES不支持root用户启动，分别使用root用户登录服务器新建es用户,并设置密码，然后给用户文件夹所有权
# 新增用户
useradd es
# 设置密码
passwd es
# 授权
chown es /home/es
# 新建es数据文件夹和日志文件夹
mkdir -p /opt/es/logs
mkdir -p /opt/es/data
chown es /opt/es/
chown es /opt/es/logs/
chown es /opt/es/data/
# 准备安装包
1、jdk-8u144-linux-x64.tar.gz 2、elasticsearch-6.2.2.tar.gz
1.1.4 调整系统参数
1.1.3.1 内核参数调整
vim /etc/sysctl.conf
# 增加下面的内容
fs.file-max = 65536
vm.max_map_count = 262144
# 执行命令
sysctl -p
1.1.3.2 资源参数调整
vim /etc/security/limits.conf
# 修改
* soft nofile 65536
* hard nofile 65536
* soft nproc 2048
* hard nproc 4096
es soft memlock unlimited
es hard memlock unlimited
1.1.3.3 调整线程数
vim /etc/security/limits.d/90-nproc.conf
找到如下内容：
* soft nproc 1024
#修改为
* soft nproc 2048
1.2 JDK**安装**
登录es用户，进入/opt文件夹，解压JDK安装包 ES5.0以上必须1.8JDK支持
cd /opt
tar -zxvf /home/es/jdk-8u144-linux-x64.tar.gz
# 设置环境变量
vim /etc/profile
#在文件最下方添加
export JAVA_HOME=/opt/jdk1.8.0_144
export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/*.jar
export PATH=.:$JAVA_HOME/bin:$PATH
1.3 ES**安装及配置**
1.3.1 解压缩
# 切换到es用户
cd /home/es
tar -zxvf elasticsearch-6.2.2.tar.gz
1.3.2 配置
1.3.2.1 elasticsearch.yml
cluster.name: my-social
node.name: social-151
network.host: 192.168.102.151
node.master: true
node.data: true
path.data: /opt/es/data
path.logs: /opt/es/logs
http.cors.enabled: true
http.ors.allow-origin: “*”
discovery.zen.ping.unicast.hosts: [“192.168.102.11”,”192.168.102.151”]                                  
# 集群名称，各个节点的值必须一致
cluster.name: elasticsearch_production
# 节点名称，区分节点，各个节点的值不能一致
node.name: node-1
# 数据文件路径
path.data: /opt/es/data
# 日志文件路径
path.logs: /opt/es/logs
# 设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，Linux下可以通过ulimit -l unlimited命令
bootstrap.memory_lock: true
# 因为Centos6不支持SecComp，而ES5.6.4默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动
bootstrap.system_call_filter: false
# 本机IP
network.host: 192.168.6.104
# 单播列表
discovery.zen.ping.unicast.hosts: [“192.168.102.151”, “192.168.102.11”, “192.168.102.40”]
# 防止脑裂，官方推荐设置成 N/2 + 1，N是集群中master节点的数量
discovery.zen.minimum_master_nodes: 2
# 存在至少2个节点（数据节点或者 master 节点）才进行数据恢复
gateway.recover_after_nodes: 2
# 等待10分钟，或者3个节点上线后，才进行数据恢复，这取决于哪个条件先达到
gateway.expected_nodes: 3
gateway.recover_after_time: 10m
# 禁用xpack安全认证
xpack.security.enabled: false
1.3.2.2 jvm.options
# 调整内存大小根据系统资源而定，最好不要超过总资源一半
-Xms8g
-Xmx8g
1.3.2.3 elasticsearch**和elasticsearch-plugin**
可选步骤，如果环境变量配置JDK为1.8不需要配置，若需要多JDK共同使用则需要配置
export JAVA_HOME=/opt/jdk1.8.0_144
export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/*.jar
export PATH=.:$JAVA_HOME/bin:$PATH
1.3.4 启动
cd /home/es/elasticsearch-6.2.2/bin
# 控制台启动，加 -d 参数可以后台启动
./elasticsearch    
# 查看节点状态
curl -XGET ‘192.168.102.151:9200/_cat/nodes?v’
# 查看集群状态
curl -XGET ‘192.168.102.11:9200/_cat/health?v’
1.4 head**的安装**
//下载源码
（1）git clone git://github.com/mobz/elasticsearch-head.git
//进入根目录
（2）cd elasticsearch-head
//安装
（3）npm install
//启动
（4）nohup grunt server &amp;
这里需要注意es5的head不再是es的插件而是需要单独作为一个服务提供，上面我们安装es时，最后两行配置属性是开启了es的跨域访问，所以head作为一个单独的服务，是可以访问es集群的。
此外es5的head安装依赖nodejs环境，所以我们要安装node 步骤如下：
这里采用的是下载官网编译好的二进制包直接安装
（1）wget https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.xz
（2）xz -d node-v8.9.4-linux-x64.tar.xz 
（3）设置全局环境变量
export NODE_HOME=/usr/local/node/8.9.4
export PATH=$NODE_HOME/bin:$PATH
（4）验证
head只需要在一台es节点上安装即可
1.5 IK**分词器的安装**
（1）下载源码
https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip//进入根目录
（2）cd elasticsearch-6.2.2 
（3）./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip
重启elasticsearch、
http://192.168.102.151:9200/_analyze?analyzer=ik_max_word&amp;text=iphonex &amp;pretty=true
常见问题：
通过手动重新分配分片（curl -XPOST esip:9200/_cluster/reroute?retry_failed=true ）解决unassigned

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程讲解</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-07-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
                    <p>
                        
                            1.查看线程信息：
方法1：
   jps
   top -H -p 进程id

方法2：
 jstack 进程id

方法3  
jconsonle  ， jvisualvm


  cd /usr/local/
  java -Djava.rmi.server.hostname=192.168.102.19 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false  Thread01
2.线程状态
操作系统层面：5种

【初始状态】：创建了线程对象
【可运行状态】：（就绪状态）线程对象创建后，该状态的线程位于可运行线程池中，等待调度，获取cpu 的使用权 。
【运行状态】：可运行状态的线程获得了cpu 时间片 ，执行程序代码。
​    ·当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换。
【阻塞状态】：阻塞状态是指线程因为某种原因放弃了cpu 使用权，让出了cpu时间片，暂时停止运行。直到线程进入可运行)状态，才有机会再次获得cpu时间片转到运行状态。

(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。

(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
 ·对阻塞状态的线程来说只要他们一直不被唤醒，调度器就一直不回考虑调度他们。


【中止状态】：线程执行完毕，生命周期结束，不会再转换为其他状态。

根据Thread.State枚举，分为6种状态。


1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2.运行(RUNNABLE)：调用了start方法后，Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态涵盖了操作系统层面的【可运行状态】，【运行状态】和【阻塞状态】(由于BIO导致的线程阻塞，在java中无法区分，仍然认为是可运行。)
3.阻塞(BLOCKED)：表示线程阻塞于锁。
4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6.终止(TERMINATED)：表示该线程已经执行完毕。
————-StateTest—————
3.守护线程默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。
也就是说，如果没有普通线程，那么守护线程也没有存活下去的意义了。
垃圾回收器线程就是 一种守护线程。
————-DaemonTest—————
4.线程上下文切换（Thread Context Switch）因为以下一些原因，导致cpu不再执行当前线程，转而执行另一个线程的代码：

线程cpu时间片用完（被动）
垃圾回收（被动）
有更高优先级线程执行（被动）
线程自己调用了sleep，wait，yield，join，park，synchronized，lock等方法（主动）

当context switch发生时，需要操作系统保存当前线程的状态，并恢复另一个线程的状态。
context switch频繁发生会影响性能。
5.常见方法


sleep&amp;yield


​    3.yield()方法的作用是放弃当前的CPU资源，让其 他任务去占用CPU执行时间，放弃的时间不确定， 有可能刚刚放弃，马上又获得CPU时间片。

join

如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才 从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。
体现了多线程中同步的应用，即调用方需要等待线程的结果。

interrupt


打断sleep，wait，join的线程

通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。（打断标记:false）
———-InterruptTest01——————–

如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。（打断标记:true）
————InterruptTest02———————–


6.两阶段终止模式—interrupt实现
当我们想要结束一个线程时候，通过此模式可以优雅安全的关闭线程，让线程可以完成它本应完成的当前任务并可以附加一些收尾工作后再进行关闭
是一种线程设计模式，并不在传统23中设计模式中
此模式下关闭线程会有一定延迟，主要在于被关闭线程需要执行完后，再进行关闭


​     错误方式



模拟场景—监控处理


———————–TwoPhaseTerminationTest————————
7.锁7.1 临界区：一段代码内如果存在对共享资源的的多线程读写操作，称这段代码为临界区。
1234567891011static int counter = 0;static void increament()     // 临界区&#123;    count++;&#125;static void decreament()       // 临界区&#123;    count--;&#125;

7.2竞态条件多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件
例：
——————SynTest01——-查看字节码————

当前线程获得锁后，执行临界区代码；执行中其他线程进入临界区时则进入阻塞；指到当前线程释放锁

7.3方法上synchronizedsynchronized是指在对象上加锁。
synchronized(lock): 是指对lock对象加锁
synchronized(this): 是指对当前对象加锁
12345678910111213class Test&#123;    public synchronized void test()&#123;            &#125;&#125;等价于class Test&#123;    public void test()&#123;        synchronized(this)&#123;                &#125;    &#125;&#125;

123456789101112class Test&#123;    public synchronized static void test()&#123;            &#125;&#125;等价于class Test&#123;    public static void test()&#123;        synchronized(Test.class)&#123;                &#125;    &#125;



7.4 Java对象头
Java对象由 Java对象头和成员变量组成

对象头以32位虚拟机为例：
普通对象
​      
数组对象    
其中Mark Word结构为

7.5 MonitorMonitor被翻译为监视器或管程，是java synchronized锁的底层原理
每个Java对象都可以关联一个Monitor对象，当使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word就被设置指向Monitor的指针。
Monitor结构如下


https://www.processon.com/diagraming/5fa279bc0791291e95ccb764
7.6 synchronized字节码———————————-SynTest01————————————–
7.7 轻量级锁轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。
轻量级锁对使用者是透明的，预发仍然是synchronized。
假设有两个方法同步块，利用同一个对象加锁。
12345678910111213static final Object obj = new Object();public static void method1() &#123;  synchronized (obj) &#123;    // 同步代码块1    method2();  &#125;&#125;public static void method2() &#123;  synchronized (obj) &#123;    // 同步代码块2  &#125;&#125;







7.8 锁膨胀如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这是需要进行锁膨胀，将轻量级锁升级成重量级锁。



7.9 自旋优化


7.10 偏向锁轻量级锁在没有竞争时(就自己这个线程)，每次锁冲入仍然要执行CAS操作。
JAVA6中引入偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID时自己的就表示没有竞争，不用重新CAS，以后只要不发生竞争，这个对象锁就归该线程所有。
12345678910111213static final Object obj = new Object();public static void method1() &#123;  synchronized (obj) &#123;    // 同步代码块1    method2();  &#125;&#125;public static void method2() &#123;  synchronized (obj) &#123;//------------锁重入    // 同步代码块2  &#125;&#125;



7.10.1 偏向状态
一个对象创建时：

如果开启了偏向锁(默认开启)，那么对象创建后，markword值为0x05，即最后3位为101，这时它的thread，epoch，age都为0
偏向锁默认是有延迟的，不会再程序启动时立即生效，如果想避免延迟，可以加VM参数：-XX:BiasedLockingStartupDelay=0来禁用延迟。
如果没有开启偏向锁，那么对象创建后，markword的值为0x01，即最后3位为001，这时它的hashcode，age都为0，第一次用到hashcode时才会赋值

——————–BiasedTest01——-验证对象创建mark头数据，vm参数等———–
——————–BiasedTest02——–验证加锁前后mark头数据———-
7.10.2 撤销-调用hashcode测试hashcode ：thread+hashcode&gt;64位
——————–BiasedTest02——–验证hashcode加锁前后mark头数据———-
7.10.3 撤销-其他线程使用对象当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁
——————–BiasedTest03——–
7.10.4 撤销-调用wait/notify7.10.5 批量重偏向如果对象虽然被多个线程访问，但没有竞争，这时偏向了T1的线程仍有机会重新偏向T2，重偏向会重置对象的Thread ID
当撤销偏向锁阈值达到20次后，jvm会觉得，自己是不是偏向错了，于是会再给这些对象加锁时，重新偏向至加锁线程。
——————–BiasedTest04——–
7.10.6 批量撤销当撤销偏向锁阈值达到40次后，jvm会觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的。新建的对象也是不可偏向的。
——————–BiasedTest05——–
7.11 锁消除锁消除是发生在编译器级别的一种锁优化方式。有时候我们写的代码完全不需要加锁，却执行了加锁操作。
JIT即时编译器，会对热点代码进行优化。
123456789class Test&#123;    static int x = 0;    public void method01()&#123;        Object o = new Object();        synchronized(o) &#123;// 对方法内对象变量加锁，不会发生任何竞争，JIT即时编译器去将锁去掉            x++;        &#125;    &#125;&#125;

锁消除默认时打开的，可以通过 -XX:-EliminateLocks 去掉
7.11 死锁7.11.1 定义存在这样的情况，一个线程同时获取多把锁，这时就容易产生死锁。
   线程1获得A对象锁，接下来想获取B对象锁
   线程2获得B对象锁，接下来想获取A对象锁
———————–DeadLockTest———————————-
7.11.2 死锁定位
命令行工具
   jps
  jstack 进程id

jconsonle  ， jvisualvm


7.11.3 死锁现象-哲学家就餐
——————-DeadLockEatTest———————–
8.ReentrantLockjava.util.concurrent下的一个类，
ReentrantLock类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁中断、超时，和多个条件变量等一些特性
12345678Lock lock = new ReentrantLock();lock.lock();try &#123;   // 临界区&#125;finally &#123;  lock.unlock(); &#125;

8.1 可重入可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获得这把锁
如果是不可重入锁，那么第二次获得锁时，自己也会被挡住
123456789101112131415161718192021222324252627282930private static ReentrantLock lock = new ReentrantLock();  public static void main(String[] args) &#123;    lock.lock();    try &#123;      log.debug(&quot;main&quot;);      method1();    &#125; finally &#123;      lock.unlock();    &#125;  &#125;  public static void method1() &#123;    lock.lock();    try &#123;      log.debug(&quot;method1&quot;);      method2();    &#125; finally &#123;      lock.unlock();    &#125;  &#125;  public static void method2() &#123;    lock.lock();    try &#123;      log.debug(&quot;method2&quot;);    &#125; finally &#123;      lock.unlock();    &#125;  &#125;



8.2 可打断调用线程的interrupt方法将正在等待锁的线程终止等待
————-Test03—————–
8.3 锁超时可打断是一种被动避免死等的方式，需要别的线程来执行interrupt方法。
锁超时是一种主动避免死等的方式
12boolean tryLock();   //尝试获取锁。true:获取到，可以进入临界区；false:未获取到。boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException //尝试一定时间获取锁

————-Test04—————–
8.4 哲学家就餐问题的解决——————-DeadLockEatTest———————–
9.wait&amp;notify

线程获得到锁后，Owner线程发现自己往下执行的条件不满足，调用锁对象的wait方法，即可进入waitset变为waiting状态。
BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片，BLOCKED是未获得锁，WAITING是获得了锁，但自己又放弃了锁。
BLOCKED线程会在Owner线程释放锁时唤醒
WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进图EntryList重新竞争

9.1 API介绍
obj.wait()让进入object锁的线程到waitSet等待。
obj.notify()让object上正在waitSet上等待的线程挑一个来唤醒
obj.notifyAll()让object上正在waitSet上等待的线程全部唤醒

他们都是线程之间进行协作的手段，都属于Object对象的方法，由锁对象来调用。
必须获得此对象锁，成为owner后，才能调用这几个方法
——————-WaitTest01———————–
——————-WaitTest02———————–
9.2 wait sleep区别
10.线程状态转换

                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/06/03/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/">Maven知识库</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-06-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/06/03/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/">
                    <p>
                        
                            MavenMaven的作用？1.添加第三方jar包
2.解决jar包之间的依赖关系
3.获取第三方jar包
4.将项目拆成多个工程模块
Maven 是什么？是Apache软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。
构建过程1.清理：删除以前的编译结果，为重新编译做好准备。
2.编译：将 Java 源程序为字编译为节码文件。
3.测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。
4.报告：在每一次测试后以标准的格式记录和展示测试结果
5.打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。
6.安装：在 Maven 环境下特指将打包的结果—— jar 包或 war 包安装到本地仓库。
7.部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。
Maven 核心概念1.POM
2.约定的目录结构
3.坐标
4.依赖管理
5.仓库管理
6.生命周期
7.插件和目标
8.继承
9.聚合
原理与约定Maven 的核心程序中仅仅定义了抽象的声明周期，具体的操作是由 Maven 的插件完成的。Maven 的插件不包含在 Maven 的核心程序中，在首次使用时需要联网下载。
下载的插件被保存在本地仓库，本地仓库的默认位置是：~.m2\repository
约定的目录结构对于 Maven 实现自动化构建是必不可缺的一环，Maven 必须能找到 Java 源文件，编译后的字节码也有一个存储的位置，所以约定至关重要。
项目
  src
​    main
​      java
​      resources
​    test
​      java
​      resources
target
src：源码目录 main：主程序目录 main-&gt;java：主程序的Java源文件目录 main-&gt;resources：主程序的资源文件目录 test：测试程序目录 test-&gt;java：测试程序的Java源文件目录 test-&gt;resources：测试程序的资源文件目录
POMProject Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。
Maven 坐标
在空间中需要 x、y、z三个向量确定一个点
使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程(gav)。
1.groupid：公司或组织的域名倒叙+当前项目名称
2.artifactid：当前项目的模块名称
3.version：当前模块的版本
com.ihdou.maven
Hello
0.0.1-SNAPSHOT
使用命令 mvn install 执行安装后 Maven 工程进入仓库，通过两个步骤查找 jar 包。
1.将 gav 三个向量连起来
1com. ihdou.maven+Hello+0.0.1-SNAPSHOT

2.以连起来的的字符串作为目录结构到仓库中查找
1com&#x2F; ihdou &#x2F;maven&#x2F;Hello&#x2F;0.0.1-SNAPSHOT&#x2F;Hello-0.0.1-SNAPSHOT.jar

依赖使用 Maven 就是为了使用它的依赖功能，当 A jar 包用到了 B jar 包的某些类时，A 对 B 产生了依赖。
实现依赖：
123456&lt;dependency&gt;    &lt;groupId&gt;com.ihdou.maven&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;Hello&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;    &lt;scope&gt;compile&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;

依赖的范围有：compile(编译)、test(测试)、provided(部署)
依赖的传递：A 依赖 B，B 依赖 C ，A 是否能使用 C？要看 B 依赖 C 的范围是不是 compile
依赖的排除：
12345678910111213&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.ihdou&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;TestDB&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;            &lt;&#x2F;exclusion&gt;        &lt;&#x2F;exclusions&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;

对版本号进行统一： 1.统一声明版本号
123&lt;properties&gt;    &lt;mysql-connector.version&gt;5.1.47&lt;&#x2F;mysql-connector.version&gt;&lt;&#x2F;properties&gt;

2.引用前面声明的版本号：
12345&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;mysql-connector.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;

仓库仓库有本地仓库和远程仓库，远程仓库包含私服、中央仓库、中央仓库的镜像。
仓库中存储的文件有 Maven 的插件、我们自己开发的项目的模块、第三方框架或工具的 jar 包
生命周期Maven 生命周期定义了各个构建缓解的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。
有3套相互独立的生命周期，分别是：
\1. Clean Lifecycle 在进行真正的构建之前进行的一些清理工具。
\2. Default Lifecycle 构建的核心部分，编译，测试，打包，安装部署等等。
\3. Site Lifecycle 生成项目报告，站点，发布站点
它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。也可以直接运行 mvn clean install site 运行所有这三套声明周期
Clean 生命周期的阶段：
\1. pre-clean 执行一些需要在 clean 之前完成的工作
\2. clean 移除所有上一次构建生成的文件
\3. post-clean 执行一些需要在 clean 之后立刻完成的工作
Site 生命周期的阶段：
\1.   pre-site 执行一些需要在生成站点文档之前完成的工作
\2.   site 生成项目的站点文档
\3.   post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备
\4.   site-deploy 将生成的站点文档部署到特定的服务器上
Default 生命周期的阶段
Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：
validate
generate-sources
process-sources
generate-resources
process-resources 复制并处理资源文件，至目标目录，准备打包
compile 编译项目的源代码
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources 复制并处理资源文件，至目标测试目录
test-compile 编译测试源代码
process-test-classes
test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署
prepare-package
package 接受编译好的代码，打包成可发布的格式，如 JAR
pre-integration-test
integration-test
verify
install 将包安装至本地仓库，以让其他项目依赖
deploy 将最终的包复制到远程的仓库，以让其他开发人员与项目共享或部署到服务器上运行
运行任何一个阶段的时候，它前面的所有阶段都会被运行
插件和目标Maven 的核心仅仅定义了抽象的声明周期，具体的任务都是交给插件完成的。
每个插件都能实现多个功能，每个功能就是一个插件目标
Maven 的声明周期与插件目标相互绑定，以完成某个具体的构建任务
继承非 compile 范文的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。



工程
依赖



Hello
&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;


HelloFriend
&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;


MakeFriend
&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;


如果将各模块的版本统一为 4.9，各个模块单独修改是不可取的，可以使用继承机制将依赖信息统一提取到父工程模块中进行统一管理。
实现继承1.创建父工程：打包方式设置为 pom
2.在子工程中引用父工程
1234567&lt;parent&gt;    &lt;!-- 父工程坐标 --&gt;    &lt;groupId&gt;...&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;...&lt;&#x2F;artifactId&gt;    &lt;version&gt;...&lt;&#x2F;version&gt;    &lt;relativePath&gt;从当前目录到父项目的 pom.xml文件的相对路径&lt;&#x2F;relativePath&gt;&lt;&#x2F;parent&gt;

如果此时子工程的 groupId 和 version 和父工程重复则可以删除
3.在父工程中管理依赖 将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来
123456789&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.2.17&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt;

在子项目中重新制定需要的依赖，删除范围和版本号
123456 &lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;

聚合(多模块)将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需药逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。
配置聚合：
在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径集合
1234&lt;modules&gt;    &lt;module&gt;test&lt;&#x2F;module&gt;    &lt;module&gt;b&lt;&#x2F;module&gt;&lt;&#x2F;modules&gt;


                        
                    </p>
                </a>
            </div>

            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/06/03/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/">Redis集群安装部署</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-06-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/06/03/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/">
                    <p>
                        
                            Redis1  Redis下载从该网站http://www.redis.net.cn/下载redis稳定版本[Redis 5.0.4](http://download.redis.io/releases/redis-3.0.6.tar.gz)(redis-5.0.4.tar.gz)。
模式: 三主三从
5.0版本后不需要ruby支持，其底层改由C实现
主从配置、leader选举由redis自己实现
1.1 测试服务器操作系统: centos
192.168.102.33:6379 192.168.102.33:6380
192.168.102.34:6379 192.168.102.34:6380
192.168.102.35:6379 192.168.102.35:6380
1.2 安装redisyum install gcc
yum install tcl
make 安装需要gcc和tcl
#在集群服务器做出以下操作：
cd /usr/local/
tar xzf redis-5.0.4.tar.gz
cd redis-5.0.4
执行make install
至此redis安装完成
运行#make test 测试
2  redis配置文件cp redis.conf nodes-6379.conf 
cp redis.conf nodes-6380.conf
分别编辑nodes-6379.conf 、nodes-6380.conf
#bind 127.0.0.1（注释掉）
daemonize yes  //后台启动
port 6379（分别对每个机器的端口号进行设置）
dir /usr/local/redis-data/6379/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）
cluster-enabled yes（启动集群模式）
cluster-config-file nodes-6379.conf（集群节点信息文件，这里63xx最好和port对应上）
cluster-node-timeout 5000
protected-mode no  （关闭保护模式）
appendonly yes （启动：设置yes,修改默认的appendonly no,改为yes
将有数据的aof文件复制一份保存到对应目录(config get dir)
恢复：重启redis然后重新加载） 
requirepass admin （配置redis服务器密码，不配的话jedis连接会报如下错误）
以上配置每台都需要调整，nodes-6379.conf，nodes-6380.conf
3  启动redis实例cd /usr/local/
mkdir redis-data/6379
mkdir redis-data/6380
Redis启动时不会自动创建数据文件存放目录，启动前手动创建
cd /usr/local/ redis-5.0.4/scr
启动
./redis-server ../nodes-6379.conf
./redis-server ../nodes-6380.conf
以此步骤启动每个机器上的redis实例
4  redis配置集群任选一台 我这使用192.168.102.33
cd /usr/local/redis-5.0.4/src/
./redis-cli –cluster create –cluster-replicas 1 192.168.102.33:6379 192.168.102.33:6380 192.168.102.34:6379 192.168.102.34:6380 192.168.102.35:6379 192.168.102.35:6380 –cluster-replicas 1 -a admin
注意–cluster-replicas 1 -a admin 带上密码 否则集群创建不成功
以上redis5.0.4集群搭建完毕
5  测试
                        
                    </p>
                </a>
            </div>

            
        </article>
    



            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture" /></p>
        <p class="name">
            xuesongtan
        </p>
        <p class="slogan">流连矣 忘景幻云催 峦栈醺醺说旧梦 重山迟迟映霞辉 向晚共邀归</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/12/03/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">Docker 教程讲解</a></li>
            
        
            
                <li><a href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">Docker 搭建私有仓库</a></li>
            
        
            
                <li><a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 命令大全</a></li>
            
        
            
                <li><a href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">Docker Dockerfile</a></li>
            
        
            
                <li><a href="/2020/08/03/Elasticsearch%E9%9B%86%E7%BE%A4/">Elasticsearch集群搭建</a></li>
            
        
            
                <li><a href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程讲解</a></li>
            
        
            
                <li><a href="/2020/06/03/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/">Maven知识库</a></li>
            
        
            
                <li><a href="/2020/06/03/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/">Redis集群安装部署</a></li>
            
        
    </ul>
</div>

    
        
    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">2020-12</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">2020-09</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">2020-08</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">2020-07</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">2020-06</a><span class="archive-list-count">2</span></li></ul>
  </div>

    
        
    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>