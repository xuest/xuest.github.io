<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content=""/>



    <meta name="description" content=""/>


<meta name="Robots" content="all">


    <title>Augustxuesong</title>


<link rel="icon" href="/images/favicon.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/style.css">


<script src="/js/highlight.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >Home</a>
            
                <a class="nav-item" href="/resume"
                
                >Resume</a>
            
                <a class="nav-item" href="/mood"
                
                   target="_blank"
                
                >Mood</a>
            
                <a class="nav-item" href="/amusement/tetris"
                
                   target="_blank"
                
                >Amusement</a>
            
                <a class="nav-item" href="/about"
                
                >About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程讲解</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-07-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
                    <p>
                        
                            1.查看线程信息：
方法1：
   jps
   top -H -p 进程id

方法2：
 jstack 进程id

方法3  
jconsonle  ， jvisualvm


  cd /usr/local/
  java -Djava.rmi.server.hostname=192.168.102.19 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false  Thread01
2.线程状态
操作系统层面：5种

【初始状态】：创建了线程对象
【可运行状态】：（就绪状态）线程对象创建后，该状态的线程位于可运行线程池中，等待调度，获取cpu 的使用权 。
【运行状态】：可运行状态的线程获得了cpu 时间片 ，执行程序代码。
​    ·当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换。
【阻塞状态】：阻塞状态是指线程因为某种原因放弃了cpu 使用权，让出了cpu时间片，暂时停止运行。直到线程进入可运行)状态，才有机会再次获得cpu时间片转到运行状态。

(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。

(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
 ·对阻塞状态的线程来说只要他们一直不被唤醒，调度器就一直不回考虑调度他们。


【中止状态】：线程执行完毕，生命周期结束，不会再转换为其他状态。

根据Thread.State枚举，分为6种状态。


1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2.运行(RUNNABLE)：调用了start方法后，Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态涵盖了操作系统层面的【可运行状态】，【运行状态】和【阻塞状态】(由于BIO导致的线程阻塞，在java中无法区分，仍然认为是可运行。)
3.阻塞(BLOCKED)：表示线程阻塞于锁。
4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6.终止(TERMINATED)：表示该线程已经执行完毕。
————-StateTest—————
3.守护线程默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。
也就是说，如果没有普通线程，那么守护线程也没有存活下去的意义了。
垃圾回收器线程就是 一种守护线程。
————-DaemonTest—————
4.线程上下文切换（Thread Context Switch）因为以下一些原因，导致cpu不再执行当前线程，转而执行另一个线程的代码：

线程cpu时间片用完（被动）
垃圾回收（被动）
有更高优先级线程执行（被动）
线程自己调用了sleep，wait，yield，join，park，synchronized，lock等方法（主动）

当context switch发生时，需要操作系统保存当前线程的状态，并恢复另一个线程的状态。
context switch频繁发生会影响性能。
5.常见方法


sleep&amp;yield


​    3.yield()方法的作用是放弃当前的CPU资源，让其 他任务去占用CPU执行时间，放弃的时间不确定， 有可能刚刚放弃，马上又获得CPU时间片。

join

如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才 从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。
体现了多线程中同步的应用，即调用方需要等待线程的结果。

interrupt


打断sleep，wait，join的线程

通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。（打断标记:false）
———-InterruptTest01——————–

如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。（打断标记:true）
————InterruptTest02———————–


6.两阶段终止模式—interrupt实现
当我们想要结束一个线程时候，通过此模式可以优雅安全的关闭线程，让线程可以完成它本应完成的当前任务并可以附加一些收尾工作后再进行关闭
是一种线程设计模式，并不在传统23中设计模式中
此模式下关闭线程会有一定延迟，主要在于被关闭线程需要执行完后，再进行关闭


​     错误方式



模拟场景—监控处理


———————–TwoPhaseTerminationTest————————
7.锁7.1 临界区：一段代码内如果存在对共享资源的的多线程读写操作，称这段代码为临界区。
1234567891011static int counter = 0;static void increament()     // 临界区&#123;    count++;&#125;static void decreament()       // 临界区&#123;    count--;&#125;

7.2竞态条件多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件
例：
——————SynTest01——-查看字节码————

当前线程获得锁后，执行临界区代码；执行中其他线程进入临界区时则进入阻塞；指到当前线程释放锁

7.3方法上synchronizedsynchronized是指在对象上加锁。
synchronized(lock): 是指对lock对象加锁
synchronized(this): 是指对当前对象加锁
12345678910111213class Test&#123;    public synchronized void test()&#123;            &#125;&#125;等价于class Test&#123;    public void test()&#123;        synchronized(this)&#123;                &#125;    &#125;&#125;

123456789101112class Test&#123;    public synchronized static void test()&#123;            &#125;&#125;等价于class Test&#123;    public static void test()&#123;        synchronized(Test.class)&#123;                &#125;    &#125;



7.4 Java对象头
Java对象由 Java对象头和成员变量组成

对象头以32位虚拟机为例：
普通对象
​      
数组对象    
其中Mark Word结构为

7.5 MonitorMonitor被翻译为监视器或管程，是java synchronized锁的底层原理
每个Java对象都可以关联一个Monitor对象，当使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word就被设置指向Monitor的指针。
Monitor结构如下


https://www.processon.com/diagraming/5fa279bc0791291e95ccb764
7.6 synchronized字节码———————————-SynTest01————————————–
7.7 轻量级锁轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。
轻量级锁对使用者是透明的，预发仍然是synchronized。
假设有两个方法同步块，利用同一个对象加锁。
12345678910111213static final Object obj = new Object();public static void method1() &#123;  synchronized (obj) &#123;    // 同步代码块1    method2();  &#125;&#125;public static void method2() &#123;  synchronized (obj) &#123;    // 同步代码块2  &#125;&#125;







7.8 锁膨胀如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这是需要进行锁膨胀，将轻量级锁升级成重量级锁。



7.9 自旋优化


7.10 偏向锁轻量级锁在没有竞争时(就自己这个线程)，每次锁冲入仍然要执行CAS操作。
JAVA6中引入偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID时自己的就表示没有竞争，不用重新CAS，以后只要不发生竞争，这个对象锁就归该线程所有。
12345678910111213static final Object obj = new Object();public static void method1() &#123;  synchronized (obj) &#123;    // 同步代码块1    method2();  &#125;&#125;public static void method2() &#123;  synchronized (obj) &#123;//------------锁重入    // 同步代码块2  &#125;&#125;



7.10.1 偏向状态
一个对象创建时：

如果开启了偏向锁(默认开启)，那么对象创建后，markword值为0x05，即最后3位为101，这时它的thread，epoch，age都为0
偏向锁默认是有延迟的，不会再程序启动时立即生效，如果想避免延迟，可以加VM参数：-XX:BiasedLockingStartupDelay=0来禁用延迟。
如果没有开启偏向锁，那么对象创建后，markword的值为0x01，即最后3位为001，这时它的hashcode，age都为0，第一次用到hashcode时才会赋值

——————–BiasedTest01——-验证对象创建mark头数据，vm参数等———–
——————–BiasedTest02——–验证加锁前后mark头数据———-
7.10.2 撤销-调用hashcode测试hashcode ：thread+hashcode&gt;64位
——————–BiasedTest02——–验证hashcode加锁前后mark头数据———-
7.10.3 撤销-其他线程使用对象当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁
——————–BiasedTest03——–
7.10.4 撤销-调用wait/notify7.10.5 批量重偏向如果对象虽然被多个线程访问，但没有竞争，这时偏向了T1的线程仍有机会重新偏向T2，重偏向会重置对象的Thread ID
当撤销偏向锁阈值达到20次后，jvm会觉得，自己是不是偏向错了，于是会再给这些对象加锁时，重新偏向至加锁线程。
——————–BiasedTest04——–
7.10.6 批量撤销当撤销偏向锁阈值达到40次后，jvm会觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的。新建的对象也是不可偏向的。
——————–BiasedTest05——–
7.11 锁消除锁消除是发生在编译器级别的一种锁优化方式。有时候我们写的代码完全不需要加锁，却执行了加锁操作。
JIT即时编译器，会对热点代码进行优化。
123456789class Test&#123;    static int x = 0;    public void method01()&#123;        Object o = new Object();        synchronized(o) &#123;// 对方法内对象变量加锁，不会发生任何竞争，JIT即时编译器去将锁去掉            x++;        &#125;    &#125;&#125;

锁消除默认时打开的，可以通过 -XX:-EliminateLocks 去掉
7.11 死锁7.11.1 定义存在这样的情况，一个线程同时获取多把锁，这时就容易产生死锁。
   线程1获得A对象锁，接下来想获取B对象锁
   线程2获得B对象锁，接下来想获取A对象锁
———————–DeadLockTest———————————-
7.11.2 死锁定位
命令行工具
   jps
  jstack 进程id

jconsonle  ， jvisualvm


7.11.3 死锁现象-哲学家就餐
——————-DeadLockEatTest———————–
8.ReentrantLockjava.util.concurrent下的一个类，
ReentrantLock类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁中断、超时，和多个条件变量等一些特性
12345678Lock lock = new ReentrantLock();lock.lock();try &#123;   // 临界区&#125;finally &#123;  lock.unlock(); &#125;

8.1 可重入可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获得这把锁
如果是不可重入锁，那么第二次获得锁时，自己也会被挡住
123456789101112131415161718192021222324252627282930private static ReentrantLock lock = new ReentrantLock();  public static void main(String[] args) &#123;    lock.lock();    try &#123;      log.debug(&quot;main&quot;);      method1();    &#125; finally &#123;      lock.unlock();    &#125;  &#125;  public static void method1() &#123;    lock.lock();    try &#123;      log.debug(&quot;method1&quot;);      method2();    &#125; finally &#123;      lock.unlock();    &#125;  &#125;  public static void method2() &#123;    lock.lock();    try &#123;      log.debug(&quot;method2&quot;);    &#125; finally &#123;      lock.unlock();    &#125;  &#125;



8.2 可打断调用线程的interrupt方法将正在等待锁的线程终止等待
————-Test03—————–
8.3 锁超时可打断是一种被动避免死等的方式，需要别的线程来执行interrupt方法。
锁超时是一种主动避免死等的方式
12boolean tryLock();   //尝试获取锁。true:获取到，可以进入临界区；false:未获取到。boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException //尝试一定时间获取锁

————-Test04—————–
8.4 哲学家就餐问题的解决——————-DeadLockEatTest———————–
9.wait&amp;notify

线程获得到锁后，Owner线程发现自己往下执行的条件不满足，调用锁对象的wait方法，即可进入waitset变为waiting状态。
BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片，BLOCKED是未获得锁，WAITING是获得了锁，但自己又放弃了锁。
BLOCKED线程会在Owner线程释放锁时唤醒
WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进图EntryList重新竞争

9.1 API介绍
obj.wait()让进入object锁的线程到waitSet等待。
obj.notify()让object上正在waitSet上等待的线程挑一个来唤醒
obj.notifyAll()让object上正在waitSet上等待的线程全部唤醒

他们都是线程之间进行协作的手段，都属于Object对象的方法，由锁对象来调用。
必须获得此对象锁，成为owner后，才能调用这几个方法
——————-WaitTest01———————–
——————-WaitTest02———————–
9.2 wait sleep区别
10.线程状态转换

                        
                    </p>
                </a>
            </div>

            
        </article>
    



            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture" /></p>
        <p class="name">
            xuesongtan
        </p>
        <p class="slogan">流连矣 忘景幻云催 峦栈醺醺说旧梦 重山迟迟映霞辉 向晚共邀归</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/12/03/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">Docker 教程讲解</a></li>
            
        
            
                <li><a href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">Docker 搭建私有仓库</a></li>
            
        
            
                <li><a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 命令大全</a></li>
            
        
            
                <li><a href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">Docker Dockerfile</a></li>
            
        
            
                <li><a href="/2020/08/03/Elasticsearch%E9%9B%86%E7%BE%A4/">Elasticsearch集群搭建</a></li>
            
        
            
                <li><a href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程讲解</a></li>
            
        
            
                <li><a href="/2020/06/03/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/">Maven知识库</a></li>
            
        
            
                <li><a href="/2020/06/03/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/">Redis集群安装部署</a></li>
            
        
    </ul>
</div>

    
        
    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">2020-12</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">2020-09</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">2020-08</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">2020-07</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">2020-06</a><span class="archive-list-count">2</span></li></ul>
  </div>

    
        
    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>