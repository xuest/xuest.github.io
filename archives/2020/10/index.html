<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content=""/>



    <meta name="description" content=""/>


<meta name="Robots" content="all">


    <title>Augustxuesong</title>


<link rel="icon" href="/images/favicon.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/style.css">


<script src="/js/highlight.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >Home</a>
            
                <a class="nav-item" href="/resume"
                
                >Resume</a>
            
                <a class="nav-item" href="/mood"
                
                   target="_blank"
                
                >Mood</a>
            
                <a class="nav-item" href="/amusement/tetris"
                
                   target="_blank"
                
                >Amusement</a>
            
                <a class="nav-item" href="/about"
                
                >About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 命令大全</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
                    <p>
                        
                            命令介绍docker是传统的CS架构分为docker client和docker server
docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。
docker的镜像管理#查看镜像列表: 
docker images 
docker image ls 
#导出镜像: 
docker image save centos &gt; docker-centos6.9.tar.gz 
#导入镜像: 
docker image load -i docker-centos6.9.tar.gz 
#删除镜像: 
docker image rm centos:latest 
docker image rm 578c3 
#搜索镜像     
docker search + 镜像名字 
#给源中镜像打标签: 
docker tag nginx:latest 10.0.0.11:80/nginx:latest 
#推送指定镜像到docker镜像源服务器 
docker push 10.0.0.11:80/nginx:latest 
#获取镜像    
docker pull image_name 
#官方pull    
docker pull centos:6.8（没有指定版本，默认会下载最新版） 
#私有仓库pull    
docker pull daocloud.io/huangzhichong/alpine-cn:latest 
#显示一个镜像的历史
docker history image_name    
#使用当前目录下的Dockerfile构建镜像
docker build -t  .   
docker的容器管理#查看版本
docker -v     
#查看docker信息    
docker info     
#运行容器 
docker run –name 容器名 -d -p 3306:3306 mysql  
#docker 启动容器 
docker run image_name 
docker run -d -p 80:80 nginx:latest 
（run 创建并运行一个容器 -d 放在后台  -p 端口映射 :docker的容器端口 -P 随机分配端口 
​    -v 源地址(宿主机):目标地址(容器) )
#启动容器
docker run image_name   
#停止容器 
docker stop container_id  
#杀死容器
docker kill container_name   
#查看容器列表
docker ps (-a -l -q)    
#停用并删除容器
docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)
#停止多有容器
docker stop $(docker ps -q)
#删除所有容器
docker rm $(docker ps -aq)
#查看容器列表 
docker ps -a  
#进容器
docker exec -it 77cd6bef4dc9 /bin/bash   
#开启/停止 指定容器id或者容器名称的容器 
docker start/stop container-id||container-name 
#启动容器 -v
docker run -d -p 80:80 -v /opt/xuest:/usr/share/nginx/html nginx:latest 
#查看容器日志
docker logs container-name/container-id     
#查看容器状态 
docker ps | grep ${CONTAINER_ID}    
镜像打包 (保存对容器的修改) 
docker commit ID new_image_name     
提交的描述信息” -a=”作者” 容器id  要创建的目标镜像名:[标签名] 
docker commit -m=””
#查看容器内部详情细节 
docker inspect &lt;id/container_name&gt;   
#登录
docker login 
#退出而不关闭容器 Ctrl+P+Q     
docker run -it –rm –name centos6 centos:6.9 /bin/bash  
-it 分配交互式的终端  
–name 指定容器的名字  
/bin/sh覆盖容器的初始命令 
启动命名：docker run -d -p 80:80  -v   waibulj:内部路径  –name
docker命令集


命令
说明



容器生命周期管理



run
创建一个新容器并运行


start
开启一个容器并使其在后台运行


stop
停止一个容器


restart
重启一个容器


kill
杀掉一个容器进程


rm
删除容器


pause
暂停容器


unpause
恢复暂停容器


create
从镜像中创建一个容器


exec
对一个容器执行shell命令


容器操作



ps
列出容器


inspect
获取容器或镜像的元数据


top
查看正在运行中的容器进程信息


attach
链接正在运行的容器


events
从docker服务器获取事件


logs
获取docker日志


wait
让一个容器进入等待，使其进入阻塞状态


export
讲一个容器的文件系统打包至tar


port
列出一个容器的端口映射情况


container
管理已经运行的容器的


deploy
部署新的堆栈或更新已有堆栈的


update
更新容器


rename
重命名容器


volume
卷管理


容器文件系统操作



commit
提交一个容器的文件系统，使之生成一个新的镜像


cp
向一个正在运行的容器复制文件，或将容器中的文件复制出来


diff
检查一个容器文件系统更改情况


镜像仓库操作



login
docker登入


logout
docker登出


pull
拉取镜像


push
推送镜像至服务器


search
在docker hub上查询镜像


镜像管理



images
列出镜像


rmi
删除镜像


tag
修改本地某一镜像的标记，使其镜像属于某一仓库


build
通过指定Dockerfile文件编译镜像


history
查看镜像历史


save
将制定镜像保存成tar文件


load
从tar中恢复镜像


import
从tar中创建一个新镜像


checkpoint
设置checkpoint，类似于恢复点，可以让镜像撤销到曾经设置的某一个checkpoint上


image
docker镜像管理


manifest
docker镜像清单管理


trust
docker可信镜像管理


集群管理



swarm
docker集群管理工具


node
docker集群节点控制


stack
docker集群堆栈管理


其他命令



info
查询docker信息


version
查询docker版本


system
docker系统管理


stats
docker容器资源使用统计


config
管理docker配置


network
docker网络管理


plugin
docker插件管理


secret
docker敏感信息管理


service
docker服务管理


run命令
docker run命令是创建一个新容器并运行，若本地不存在该容器镜像会直接去镜像仓库中查找并自动下载。

语法：
12docker run [OPTIONS] IMAGE [COMMAND] [ARG...]1

命令参数说明：



参数名
默认
说明
特殊示例



–add-host

为容器添加一个host to ip的映射关系，可以添加若干个，且容器重启后不会消失。若直接修改容器中的/etc/hosts文件，容器重启后会消失
docker run –add-host localhost:127.0.0.1 ubuntu:latest


–attach(-a)

将容器的stdin,stdout,stderr【标准输入，标准输出，错误输出】关联到本地shell中，在执行docker run时，将所有输入输出指定到本地shell中，若执行时携带此参数，可以指定将stdin,stdout,stderr的某一个或某几个关联到本地shell



–blkio-weight
0
限制容器读写权重，当宿主机有1个以上容器时，可以设置容器的读写优先权，权重值在10～1000之间，0为关闭权重（该参数默认为0）



–blkio-weight-device
0
设置针对指定设备的权重，权重值在10～1000之间，且优先级高于blkio.weight
docker run –blkio-weight-device “/dev/sda:100” ubuntu:latest


–cap-add

增强linux能力，在docker容器内限制了大部分的linux能力，在之前，需要开启这些功能需要结合--privileged开启特权模式才能使用这些参数，考虑到安全性，可以通过该参数来开启指定的linux功能【默认开启的功能及全部定义详见docker runc】，若参数为all则默认开启所有linux能力



–cap-drop

移除linux能力



–cgroup-parent

配置容器的控制组，继承该控制组的资源限制模式。扩展阅读:linux cgroup



–cidfile

创建一个容器，并将该容器的pid输出到某一文件中，若该文件存在，则会返回一个错误
docker run –cidfile /tmp/docker_test.cid ubuntu echo “test”


–cpu-count
0
设置容器cpu数量仅限Windows版本



–cpu-percent
0
设置容器CPU使用百分比仅限Windows版本



–cpu-period
0
与参数–cpu-quota配合使用，用于设定cpu从新分配资源的时间周期,时间周期结束后，会对cpu进行重新分配。



–cpu-quota
0
与参数–cpu-period配合使用，用于设定该容器在资源分配周期内占用cpu的时间，若容器设定–cpu-quota=1000000 –cpu-period=500000，则该容器在这个时间周期内权重为50%，这两个参数主要是提升宿主机内某一容器的权重比，可以用来解决宿主机内若干容器的资源抢占导致重要容器cpu性能不足的场景。该模式应用于Linux 的CFS模式，扩展阅读：完全公平调度程序(CFS)



–cpu-rt-period
0
–cpu-period的微秒版



–cpu-rt-runtime
0
在一个cpu资源分配周期内，优先保证某容器的cpu使用的最大微秒数。例如，默认周期为 1000000 微秒（1秒），设置 –cpu-rt-runtime=950000 可确保使用实时调度程序的容器每 1000000 微秒可运行 950000 微秒，并保留至少 50000 微秒用于非实时任务。



–cpu-shares(-c)
0
设置容器CPU权重，可以用于调整容器在单位分配周期内的资源优先使用比



–cpus

设置容器使用cpu的数量，该参数为1.3新增参数用于快速设置容器对于cpu的占用，例如示例，可以直接设置该容器使用多少cpu
docker run –cpus=”.5” ubuntu:latest


–cpuset-cpus

设置容器允许在哪个cpu上执行该进程，譬如–cpuset-cpus=”1,3”为指定在cpu 1 和cpu 3上执行，–cpuset-cpus=”0-2”为指定在cpu0,cpu1,cpu2上执行
docker run –cpuset-cpus=”1,3” ubuntu:latest docker run –cpuset-cpus=”0-2” ubuntu:latest


–cpuset-mems

同参数--cpuset-cpus，但该参数是作用于NUMA 架构的 CPU
docker run –cpuset-mems=”1,3” ubuntu:latest docker run –cpuset-mems=”0-2” ubuntu:latest


–detach(-d)
false
指定该容器运行于前台还是后台



–detach-keys

设置容器的键盘映射键位，在容器被链接到前台时，若宿主机的键盘键位与容器键位冲突，可以使用该指令对容器的键位进行重新映射



–device

将宿主机的设备映射至容器



–device-cgroup-rule

将宿主机的设备添加到cgroup规则列表中



–device-read-bps

以字节数/每秒的形式限制设备的读取速率
docker run –device-read-bps /dev/sda:100KB ubuntu:latest


–device-read-iops

以每秒所执行IO操作的次数的形式限制设备的读取速率
docker run –device-read-iops /dev/sda:10 ubuntu:latest


–device-write-bps

以字节数/每秒的形式限制设备的写入速率



–device-write-iops

以每秒所执行IO操作的次数的形式限制设备的写入速率



–disable-content-trust
true
忽略镜像的校验



–dns

指定容器使用的DNS服务器，默认和宿主一致



–dns-opt

设置DNS选项，同修改/etc/resolv.conf文件



–dns-option

设置DNS选项，同修改/etc/resolv.conf文件



–dns-search

指定容器DNS搜索域名，默认和宿主一致



–entrypoint

覆盖Dockerfile中设置的entrypoint命令



–env(-e)

设置/新增环境变量



–env-file

读取本地环境变量文件，并加载到容器中



–expose

开放一个端口或一组端口



–group-add

为容器添加用户组



–health-cmd

执行一个健康检查命令



–health-interval
0
配合--health-cmd参数，设置健康检查的执行的间隔时间（ms | s | m | h）



–health-retries
0
配合--health-cmd参数，设置健康检查命令失败重试的次数



–health-start-period
0
配合--health-cmd参数，设置健康检查的启动时间（ms | s | m | h）



–health-timeout
0
配合--health-cmd参数，设置健康检查命令超时时间（ms | s | m | h）



–help
false
帮助



–hostname(-h)

指定容器的hostname



–init
false
使用tini工具在容器中新增一个守护进程，来预防该容器出现僵尸进程的可能性



–interactive (-i)
false
以交互模式运行容器，并将容器的STDIN（标准输入）打开，通常与参数--tty (-t)配合使用



–io-maxbandwidth
0
限制容器IO最大速率仅限Windows版本



–io-maxiops
0
以每秒所执行IO操作的次数的形式限制设备的读取速率仅限Windows版本



–ip

设置容器的IPv4地址



–ip6

设置容器的IPv6地址



–ipc

启用ipc命名空间。在docker容器中进程交互采用了Linux常见的进程间交互方法(interprocess communication - IPC), 包括信号量、消息队列和共享内存等。容器的进程间交互实际上还是host上具有相同pid命名空间中的进程间交互，因此需要在IPC资源申请时加入命名空间信息，每个IPC资源有一个唯一的32位id。



–isolation

使用容器隔离。该参数拥有三个值 (1)default 即与使用dockerd –exec-opt的参数默认效果相同 (2)process 使用linux内核命名空间进行隔离，该参数不支持windows环境。 （3）使用微软的Hyper-V虚拟技术进行隔离，该参数仅限windows环境



–kernel-memory
0
限制该容器内核的内存使用



–label (-l)

设置该容器的元数据



–label-file

通过本地文件导入元数据至该容器



–link

指定容器间的关联，使用其他容器的IP、env等信息



–link-local-ip

设置本地链路地址（link-local address）ip



–log-driver

设置一个指定日志接受工具，用于动态收集日志。扩展阅读日志处理与log-driver实现



–log-opt

配合参数--log-driver使用，用于设置日志输出参数



–mac-address

设置该容器mac地址



–memory -m
0
限制该容器内存使用



–memory-reservation
0
软限制该容器的内存使用，当宿主机内存空闲时，该容器的内存使用可以一定比例超出限制，但当宿主机内存紧张时，会强制该容器内存使用限制在该参数之内



–memory-swap
0
内存交换分区大小限制。配合参数--memory使用，且最小内存交换限制应该大于内存限制。该参数有4种情况： (1)不设置–memory与该参数:则该容器默认可以用完宿舍机的所有内存和 宿主机 swap 分区。 (2)设置–memory 50MB 不设置–memory-swap（默认为0）:则–memory-swap值等于限制内存大小，即该容器能够申请的最大内存为100MB。 (3)设置–memory 50MB –memory-swap为-1:则该容器最大可以申请的内存为50MB+宿主机swap分区大小 (4)设置–memory 50MB –memory-swap 100MB：则该容器可以申请的最大内存为100MB-50MB=50MB



–memory-swappiness
-1
用于调整虚拟内存的控制行为，为0～100之间的整数。在linux内存管理中，将内存中不活跃的页交换至硬盘中，以缓解内存紧张，该参数设置为0则认定该容器所有内存中的内容均不允许交换至硬盘，用以保障最大性能，若设置为100，则认为该容器所有内存中的数据均可以交换至硬盘。扩展阅读Linux内存管理



–mount

将文件系统挂载附加到容器



–name

设置该容器的名称



–net

将容器连接到网络，支持bridge/host/none/container四种类型



–net-alias

设置该容器在网络上的别名



–network

将容器连接到网络，支持bridge/host/none/container四种类型



–network-alias

设置该容器在网络上的别名



–no-healthcheck
false
禁止一切健康检查行为



–oom-kill-disable
false
设置是否禁止oom kill行为，若该容器因为需要大量请求内存，导致宿主机内存不足或触发到内存限制，导致杀死该容器进程，若设置该参数为true则会关闭这个检查



–oom-score-adj
0
调整主机的OOM首选项（从-1000到1000）此处需要注意的是，非专业人士docker官方是不建议用户修改--oom-score-adj``--oom-kill-disable这两个参数的



–pid

自定义设置该容器的pid



–pids-limit
0
该参数值为整数，为限制该容器所能创建的最大进程数。



–privileged
false
在该容器上开启特权模式，让该容器拥有所有的linux能力



–publish -p

将容器的端口映射到宿主机上
docker run -p 8000:8000 ubuntu


–publish-all (-P)
false
将该容器的所有端口均随机映射至宿主机



–read-only
false
设置该容器只读



–restart
no
在退出该容器时重启该容器



–rm
false
当退出该容器时自动删除该容器资源



–runtime

指定该容器关联一个runtime的容器，在使用该参数时注意runtime specified必须在dockerd --add-runtime注册过。扩展阅读什么是容器的runtime与Docker、Containerd、RunC之间的进程关系



–security-opt

设置安全属性，在windows上使用CredentialSpec模块来执行身份识别。



–shm-size
0
设置/dev/shm/目录的大小



–sig-proxy
true
代理进程所接收的所有字符,当指定–sig-proxy=false时，ctrl+c和ctrl+d 不会传递信号给docker进程而关闭容器。



–stop-signal
SIGTERM
停止带有信号的容器，在linux环境下输入kill -l,就可以看到所有信号名称，可以指定容器发出某种信号时停止该容器，譬如SIGKILL



–stop-timeout
0
设置容器调用命令超时后自动退出。该参数可以设置容器在调用命令时导致超时后多少秒退出，0为永远不退出，该参数单位为秒



–storage-opt

设定该容器的存储空间，可以分别指定dm.basesize、dm.loopdatasize、dm.loopmetadatasize等项,指定单个容器可用数据空间、docker可用数据空间、元数据可用数据空。
docker run –storage-opt dm.basesize=20G ubuntu


–sysctl
map[]
修改内核参数，对应修改容器中的/etc/sysctl.conf文件



–tmpfs

指定挂载一个tmpfs目录，tmpfs是一种虚拟内存文件系统。可以不经由镜像直接创建一个容器
docker run -d –tmpfs /run:rw,noexec,nosuid,size=65536k my_image


–tty (-t)
false
为容器重新分配一个伪输入终端，通常与参数--interactive (-i)同时使用



–ulimit

设置容器的ulimit选项，扩展阅读ulimit命令



–user (-u)

在该容器下添加新用户



–userns

指定该容器运行在指定host user namespace中



–uts

使用uts命名空间。扩展阅读Linux命名空间入门



–volume (-v)

在该容器下挂载新卷



–volume-driver

挂载一个卷容器，该卷可以是一个本地共享卷或者一个远程服务，配合docker volume create命令创建一个卷



–volumes-from

可以将任意文件夹反挂载到卷中，从而快速实现对该容器的备份与迁移。
docker run –rm –volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata


–workdir (-w)

指定容器的工作目录与Dockerfile中的WORKDIR作用相同










start命令
docker start是用于启动容器的命令


语法：
12docker start [OPTIONS] CONTAINER [CONTAINER...]1

容器运维操作–attach命令docker attach命令对应开发者很有用，可以连接到正在运行的容器，观察容器的运行状况，或与容器的主进程进行交互。
–inspect命令用于查看镜像和容器的详细信息，默认会列出全部信息，可以通过–format参数来指定输出的模板格式，以便输出特定信息。
查看容器的信息container（ps）docker ps命令可以查看容器的CONTAINER ID、NAME、IMAGE NAME、端口开启及绑定、容器启动后执行的COMMNAD。最常用的功能是通过ps来找到CONTAINER_ID，以便对特定容器进行操作。docker ps 默认显示当前正在运行中的containerdocker ps -a 查看包括已经停止的所有容器docker ps -l 显示最新启动的一个容器（包括已停止的）
示例
1234[devadmin@swarm1 ~]$ docker ps -lCONTAINER ID        IMAGE                                            COMMAND              CREATED             STATUS              PORTS                      NAMES1cfb8ad8642e        regloc.com&#x2F;test&#x2F;settlequery:201711271708   &quot;sh entrypoint.sh&quot;   22 hours ago        Up 22 hours         0.0.0.0:18182-&gt;18182&#x2F;tcp   settlequery.z4taavbos34np74za1bu674az.ncj2uocqbh15ljxhui0yccd9t[devadmin@swarm1 ~]$ 



– 列出机器上的镜像（images）1234# docker images REPOSITORY               TAG             IMAGE ID        CREATED         VIRTUAL SIZEubuntu                   14.10           2185fd50e2ca    13 days ago     236.9 MB…

其中我们可以根据REPOSITORY来判断这个镜像是来自哪个服务器，如果没有 / 则表示官方镜像，类似于username/repos_name表示Github的个人公共库，类似于regsistory.example.com:5000/repos_name则表示的是私服。IMAGE ID列其实是缩写，要显示完整则带上--no-trunc选项
2. 在docker index中搜索image（search）1234Usage: docker search TERM# docker search seanloNAME                DESCRIPTION           STARS     OFFICIAL   AUTOMATEDseanloook&#x2F;centos6   sean&#39;s docker repos         0

搜索的范围是官方镜像和所有个人公共镜像。NAME列的 / 后面是仓库的名字。
3. 从docker registry server 中下拉image或repository（pull）12Usage: docker pull [OPTIONS] NAME[:TAG]# docker pull centos

上面的命令需要注意，在docker v1.2版本以前，会下载官方镜像的centos仓库里的所有镜像，而从v.13开始官方文档里的说明变了：will pull the centos:latest image, its intermediate layers and any aliases of the same id，也就是只会下载tag为latest的镜像（以及同一images id的其他tag）。也可以明确指定具体的镜像：
1# docker pull centos:centos6

当然也可以从某个人的公共仓库（包括自己是私人仓库）拉取，形如docker pull username/repository&lt;:tag_name&gt; ：
1# docker pull seanlook&#x2F;centos:centos6

如果你没有网络，或者从其他私服获取镜像，形如docker pull registry.domain.com:5000/repos:&lt;tag_name&gt;
1# docker pull dl.dockerpool.com:5000&#x2F;mongo:latest

4. 推送一个image或repository到registry（push）与上面的pull对应，可以推送到Docker Hub的Public、Private以及私服，但不能推送到Top Level Repository。
12# docker push seanlook&#x2F;mongo# docker push registry.tp-link.net:5000&#x2F;mongo:2014-10-27

registry.tp-link.net也可以写成IP，172.29.88.222。在repository不存在的情况下，命令行下push上去的会为我们创建为私有库，然而通过浏览器创建的默认为公共库。
5. 从image启动一个container（run）docker run命令首先会从特定的image创之上create一层可写的container，然后通过start命令来启动它。停止的container可以重新启动并保留原来的修改。run命令启动参数有很多，以下是一些常规使用说明当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：

检查本地是否存在指定的镜像，不存在就从公有仓库下载
利用镜像创建并启动一个容器
分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
从地址池配置一个 ip 地址给容器
执行用户指定的应用程序
执行完毕后容器被终止

1Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

5.1 使用image创建container并执行相应命令，然后停止12# docker run ubuntu echo &quot;hello world&quot;hello word

这是最简单的方式，跟在本地直接执行echo &#39;hello world&#39; 几乎感觉不出任何区别，而实际上它会从本地ubuntu:latest镜像启动到一个容器，并执行打印命令后退出（docker ps -l可查看）。需要注意的是，默认有一个--rm=true参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。容器启动后会自动随机生成一个CONTAINER ID，这个ID在后面commit命令后可以变为IMAGE ID
使用image创建container并进入交互模式, login shell是/bin/bash12# docker run -i -t --name mytest centos:centos6 &#x2F;bin&#x2F;bashbash-4.1#

上面的--name参数可以指定启动后的容器名字，如果不指定则docker会帮我们取一个名字。镜像centos:centos6也可以用IMAGE ID (68edf809afe7) 代替），并且会启动一个伪终端，但通过ps或top命令我们却只能看到一两个进程，因为容器的核心是所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外，并没有其它的资源，可见Docker对资源的利用率极高。此时使用exit或Ctrl+D退出后，这个容器也就消失了（消失后的容器并没有完全删除？）（那么多个TAG不同而IMAGE ID相同的的镜像究竟会运行以哪一个TAG启动呢
5.2 运行出一个container放到后台运行12# docker run -d ubuntu &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 2; done&quot;ae60c4b642058fefcc61ada85a610914bed9f5df0e2aa147100eab85cea785dc

它将直接把启动的container挂起放在后台运行（这才叫saas），并且会输出一个CONTAINER ID，通过docker ps可以看到这个容器的信息，可在container外面查看它的输出docker logs ae60c4b64205，也可以通过docker attach ae60c4b64205连接到这个正在运行的终端，此时在Ctrl+C退出container就消失了，按ctrl-p ctrl-q可以退出到宿主机，而保持container仍然在运行另外，如果-d启动但后面的命令执行完就结束了，如/bin/bash、echo test，则container做完该做的时候依然会终止。而且-d不能与–rm同时使用可以通过这种方式来运行memcached、apache等。
5.3 映射host到container的端口和目录映射主机到容器的端口是很有用的，比如在container中运行memcached，端口为11211，运行容器的host可以连接container的 internel_ip:11211 访问，如果有从其他主机访问memcached需求那就可以通过-p选项，形如-p &lt;host_port:contain_port&gt;，存在以下几种写法：
1234-p 11211:11211 这个即是默认情况下，绑定主机所有网卡（0.0.0.0）的11211端口到容器的11211端口上-p 127.0.0.1:11211:11211 只绑定localhost这个接口的11211端口-p 127.0.0.1::5000-p 127.0.0.1:80:8080

目录映射其实是“绑定挂载”host的路径到container的目录，这对于内外传送文件比较方便，在搭建私服那一节，为了避免私服container停止以后保存的images不被删除，就要把提交的images保存到挂载的主机目录下。使用比较简单，-v &lt;host_path:container_path&gt;，绑定多个目录时再加-v。
1-v &#x2F;tmp&#x2F;docker:&#x2F;tmp&#x2F;docker

另外在两个container之间建立联系可用--link，下面是一个例子：
1234# docker run --name nginx_test \&gt; -v &#x2F;tmp&#x2F;docker:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:ro \&gt; -p 80:80 -d \&gt; nginx:1.7.6

在主机的/tmp/docker下建立index.html，就可以通过http://localhost:80/或http://host-ip:80访问了。
6. 将一个container固化为一个新的image（commit）当我们在制作自己的镜像的时候，会在container中安装一些工具、修改配置，如果不做commit保存起来，那么container停止以后再启动，这些更改就消失了。docker commit &lt;container&gt; [repo:tag]后面的repo:tag可选只能提交正在运行的container，即通过docker ps可以看见的容器，
123456789101112131415161718查看刚运行过的容器# docker ps -lCONTAINER ID   IMAGE     COMMAND      CREATED       STATUS        PORTS   NAMESc9fdf26326c9   nginx:1   nginx -g..   3 hours ago   Exited (0)..     nginx_test启动一个已存在的容器（run是从image新建容器后再启动），以下也可以使用docker start nginx_test代替  [root@hostname docker]# docker start c9fdf26326c9c9fdf26326c9docker run -i -t --sig-proxy&#x3D;false 21ffe545748baf &#x2F;bin&#x2F;bashnginx服务没有启动# docker commit -m &quot;some tools installed&quot; fcbd0a5348ca seanlook&#x2F;ubuntu:14.10_tutorialfe022762070b09866eaab47bc943ccb796e53f3f416abf3f2327481b446a9503请注意，当你反复去commit一个容器的时候，每次都会得到一个新的&#96;IMAGE ID&#96;，假如后面的&#96;repository:tag&#96;没有变，通过&#96;docker images&#96;可以看到，之前提交的那份镜像的&#96;repository:tag&#96;就会变成&#96;&lt;none&gt;:&lt;none&gt;&#96;，所以尽量避免反复提交。另外，观察以下几点:


commit container只会pause住容器，这是为了保证容器文件系统的一致性，但不会stop。如果你要对这个容器继续做其他修改：
你可以重新提交得到新image2，删除次新的image1
也可以关闭容器用新image1启动，继续修改，提交image2后删除image1
当然这样会很痛苦，所以一般是采用Dockerfile来build得到最终image，参考[]


虽然产生了一个新的image，并且你可以看到大小有100MB，但从commit过程很快就可以知道实际上它并没有独立占用100MB的硬盘空间，而只是在旧镜像的基础上修改，它们共享大部分公共的“片”。

下
1. 开启/停止/重启container（start/stop/restart）容器可以通过run新建一个来运行，也可以重新start已经停止的container，但start不能够再指定容器启动时运行的指令，因为docker只能有一个前台进程。容器stop（或Ctrl+D）时，会在保存当前容器的状态之后退出，下次start时保有上次关闭时更改。而且每次进入attach进去的界面是一样的，与第一次run启动或commit提交的时刻相同。
123CONTAINER_ID&#x3D;$(docker start &lt;containner_id&gt;)docker stop $CONTAINER_IDdocker restart $CONTAINER_ID

2. 连接到正在运行中的container（attach）要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。
1# docker attach --sig-proxy&#x3D;false $CONTAINER_ID

3. 查看image或container的底层信息（inspect）inspect的对象可以是image、运行中的container和停止的container。
123查看容器的内部IP# docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; $CONTAINER_ID172.17.42.35

4. 删除一个或多个container、image（rm、rmi）你可能在使用过程中会build或commit许多镜像，无用的镜像需要删除。但删除这些镜像是有一些条件的：

同一个IMAGE ID可能会有多个TAG（可能还在不同的仓库），首先你要根据这些 image names 来删除标签，当删除最后一个tag的时候就会自动删除镜像；
承上，如果要删除的多个IMAGE NAME在同一个REPOSITORY，可以通过docker rmi &lt;image_id&gt;来同时删除剩下的TAG；若在不同Repo则还是需要手动逐个删除TAG；
还存在由这个镜像启动的container时（即便已经停止），也无法删除镜像；

TO-DO如何查看镜像与容器的依存关系
删除容器docker rm &lt;container_id/contaner_name&gt;
12删除所有停止的容器docker rm $(docker ps -a -q)

删除镜像docker rmi &lt;image_id/image_name …&gt;`
5. docker build 使用此配置生成新的imagebuild命令可以从Dockerfile和上下文来创建镜像：docker build [OPTIONS] PATH | URL | -上面的PATH或URL中的文件被称作上下文，build image的过程会先把这些文件传送到docker的服务端来进行的。如果PATH直接就是一个单独的Dockerfile文件则可以不需要上下文；如果URL是一个Git仓库地址，那么创建image的过程中会自动git clone一份到本机的临时目录，它就成为了本次build的上下文。无论指定的PATH是什么，Dockerfile是至关重要的，请参考Dockerfile Reference。请看下面的例子：
123456789101112131415161718# cat Dockerfile FROM seanlook&#x2F;nginx:bash_vimEXPOSE 80ENTRYPOINT &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &amp;&amp; &#x2F;bin&#x2F;bash# docker build -t seanlook&#x2F;nginx:bash_vim_Df .Sending build context to Docker daemon 73.45 MBSending build context to Docker daemon Step 0 : FROM seanlook&#x2F;nginx:bash_vim ---&gt; aa8516fa0bb7Step 1 : EXPOSE 80 ---&gt; Using cache ---&gt; fece07e2b515Step 2 : ENTRYPOINT &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &amp;&amp; &#x2F;bin&#x2F;bash ---&gt; Running in e08963fd5afb ---&gt; d9bbd13f5066Removing intermediate container e08963fd5afbSuccessfully built d9bbd13f5066

上面的PATH为.，所以在当前目录下的所有文件（不包括.dockerignore中的）将会被tar打包并传送到docker daemon（一般在本机），从输出我们可以到Sending build context...，最后有个Removing intermediate container的过程，可以通过--rm=false来保留容器。TO-DOdocker build github.com/creack/docker-firefox失败。
6. 给镜像打上标签（tag）tag的作用主要有两点：一是为镜像起一个容易理解的名字，二是可以通过docker tag来重新指定镜像的仓库，这样在push时自动提交到仓库。
12345将同一IMAGE_ID的所有tag，合并为一个新的# docker tag 195eb90b5349 seanlook&#x2F;ubuntu:rm_test新建一个tag，保留旧的那条记录# docker tag Registry&#x2F;Repos:Tag New_Registry&#x2F;New_Repos:New_Tag

7. 查看容器的信息container（ps）docker ps命令可以查看容器的CONTAINER ID、NAME、IMAGE NAME、端口开启及绑定、容器启动后执行的COMMNAD。经常通过ps来找到CONTAINER_ID。docker ps 默认显示当前正在运行中的containerdocker ps -a 查看包括已经停止的所有容器docker ps -l 显示最新启动的一个容器（包括已停止的）
8. 查看容器中正在运行的进程（top）容器运行时不一定有/bin/bash终端来交互执行top命令，查看container中正在运行的进程，况且还不一定有top命令，这是docker top &lt;container_id/container_name&gt;就很有用了。实际上在host上使用ps -ef|grep docker也可以看到一组类似的进程信息，把container里的进程看成是host上启动docker的子进程就对了。
9. 其他命令docker还有一些如login、cp、logs、export、import、load、kill等不是很常用的命令，比较简单，请参考官网。
events、history和logs命令这3个命令用于查看Docker的系统日志信息。events命令会打印出实时的系统事件；history命令会打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的命令记录；logs命令会打印出容器中进程的运行日志。
docker events [options] ：从服务器获取实时事件。
OPTIONS说明：

-f ：根据条件过滤事件；
–since ：从指定的时间戳后显示所有事件;
–until ：流水时间显示到指定的时间为止；

docker history [options] image：查看指定镜像的创建历史。
OPTIONS说明：

**-H :**以可读的格式打印镜像大小和日期，默认为true；
**–no-trunc :**显示完整的提交记录；
**-q :**仅列出提交记录ID。

docker logs [options] container
123456Options:        --details        显示更多的信息    -f, --follow         跟踪日志输出，最后一行为当前时间戳的日志        --since string   显示自具体某个时间或时间段的日志        --tail string    从日志末尾显示多少行日志， 默认是all    -t, --timestamps     显示时间戳

FROM registry.ihdou.com/node:10.15.3-alpineMAINTAINER CharlieENV NODE_ENV=productionENV HOST 0.0.0.0RUN mkdir -p /social-statics-appCOPY . /social-statics-appWORKDIR /social-statics-appEXPOSE 3000RUN apk add –no-cache make gcc g++ pythonRUN npm installRUN npm rebuild node-sassRUN npm run buildRUN npm cache clean –forceRUN apk del make gcc g++ pythonCMD [“npm”, “start”]
镜像构建：
docker build -t social-statics-app .
docker build -t registry.ihdou.com/search .
项目启动命令：
docker run -dt –rm  -p 3000:3000 social-statics-app
docker run -it –rm  -v /usr/local/jars:/logs –name zuul zuul
docker run -it –rm -p 10014:10014  -v /usr/local/jars:/logs –name search search:v1
docker run -it –rm -p 38012:38012  -v /usr/local/jars:/logs registry.ihdou.com/4.0/wallet

                        
                    </p>
                </a>
            </div>

            
        </article>
    



            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture" /></p>
        <p class="name">
            xuesongtan
        </p>
        <p class="slogan">流连矣 忘景幻云催 峦栈醺醺说旧梦 重山迟迟映霞辉 向晚共邀归</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/12/03/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">Docker 教程讲解</a></li>
            
        
            
                <li><a href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">Docker 搭建私有仓库</a></li>
            
        
            
                <li><a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 命令大全</a></li>
            
        
            
                <li><a href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">Docker Dockerfile</a></li>
            
        
            
                <li><a href="/2020/08/03/Elasticsearch%E9%9B%86%E7%BE%A4/">Elasticsearch集群搭建</a></li>
            
        
            
                <li><a href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程讲解</a></li>
            
        
            
                <li><a href="/2020/06/03/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/">Maven知识库</a></li>
            
        
            
                <li><a href="/2020/06/03/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/">Redis集群安装部署</a></li>
            
        
    </ul>
</div>

    
        
    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">2020-12</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">2020-09</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">2020-08</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">2020-07</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">2020-06</a><span class="archive-list-count">2</span></li></ul>
  </div>

    
        
    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>