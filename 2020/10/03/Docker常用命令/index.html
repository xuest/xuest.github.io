<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="命令介绍docker是传统的CS架构分为docker client和docker server docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。 docker的镜像管理#查看镜像列表:  docker images  docker image ls  #导出镜像:  docker image save centos &gt; doc">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 命令大全">
<meta property="og:url" content="http://example.com/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="Augustxuesong">
<meta property="og:description" content="命令介绍docker是传统的CS架构分为docker client和docker server docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。 docker的镜像管理#查看镜像列表:  docker images  docker image ls  #导出镜像:  docker image save centos &gt; doc">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-10-03T05:59:50.000Z">
<meta property="article:modified_time" content="2020-12-04T03:01:38.667Z">
<meta property="article:author" content="xuesongtan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Docker 命令大全 | Augustxuesong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Augustxuesong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Augustxuesong</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xuesongtan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Augustxuesong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker 命令大全
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-03 13:59:50" itemprop="dateCreated datePublished" datetime="2020-10-03T13:59:50+08:00">2020-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-04 11:01:38" itemprop="dateModified" datetime="2020-12-04T11:01:38+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><p>docker是传统的CS架构分为docker client和docker server</p>
<p>docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。</p>
<h3 id="docker的镜像管理"><a href="#docker的镜像管理" class="headerlink" title="docker的镜像管理"></a><strong>docker的镜像管理</strong></h3><p>#查看镜像列表: </p>
<p>docker images </p>
<p>docker image ls </p>
<p>#导出镜像: </p>
<p>docker image save centos &gt; docker-centos6.9.tar.gz </p>
<p>#导入镜像: </p>
<p>docker image load -i docker-centos6.9.tar.gz </p>
<p>#删除镜像: </p>
<p>docker image rm centos:latest </p>
<p>docker image rm 578c3 </p>
<p>#搜索镜像     </p>
<p>docker search + 镜像名字 </p>
<p>#给源中镜像打标签: </p>
<p>docker tag nginx:latest 10.0.0.11:80/nginx:latest </p>
<p>#推送指定镜像到docker镜像源服务器 </p>
<p>docker push 10.0.0.11:80/nginx:latest </p>
<p>#获取镜像    </p>
<p>docker pull image_name </p>
<p>#官方pull    </p>
<p>docker pull centos:6.8（没有指定版本，默认会下载最新版） </p>
<p>#私有仓库pull    </p>
<p>docker pull daocloud.io/huangzhichong/alpine-cn:latest </p>
<p>#显示一个镜像的历史</p>
<p>docker history image_name    </p>
<p>#使用当前目录下的Dockerfile构建镜像</p>
<p>docker build -t <image-name> .   </p>
<h3 id="docker的容器管理"><a href="#docker的容器管理" class="headerlink" title="docker的容器管理"></a><strong>docker的容器管理</strong></h3><p>#查看版本</p>
<p>docker -v     </p>
<p>#查看docker信息    </p>
<p>docker info     </p>
<p>#运行容器 </p>
<p>docker run –name 容器名 -d -p 3306:3306 mysql  </p>
<p>#docker 启动容器 </p>
<p>docker run image_name </p>
<p>docker run -d -p 80:80 nginx:latest </p>
<p>（run 创建并运行一个容器 -d 放在后台  -p 端口映射 :docker的容器端口 -P 随机分配端口 </p>
<p>​    -v 源地址(宿主机):目标地址(容器) )</p>
<p>#启动容器</p>
<p>docker run image_name   </p>
<p>#停止容器 </p>
<p>docker stop container_id  </p>
<p>#杀死容器</p>
<p>docker kill container_name   </p>
<p>#查看容器列表</p>
<p>docker ps (-a -l -q)    </p>
<p>#停用并删除容器</p>
<p>docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</p>
<p>#停止多有容器</p>
<p>docker stop $(docker ps -q)</p>
<p>#删除所有容器</p>
<p>docker rm $(docker ps -aq)</p>
<p>#查看容器列表 </p>
<p>docker ps -a  </p>
<p>#进容器</p>
<p>docker exec -it 77cd6bef4dc9 /bin/bash   </p>
<p>#开启/停止 指定容器id或者容器名称的容器 </p>
<p>docker start/stop container-id||container-name </p>
<p>#启动容器 -v</p>
<p>docker run -d -p 80:80 -v /opt/xuest:/usr/share/nginx/html nginx:latest </p>
<p>#查看容器日志</p>
<p>docker logs container-name/container-id     </p>
<p>#查看容器状态 </p>
<p>docker ps | grep ${CONTAINER_ID}    </p>
<p>镜像打包 (保存对容器的修改) </p>
<p>docker commit ID new_image_name     </p>
<p>提交的描述信息” -a=”作者” 容器id  要创建的目标镜像名:[标签名] </p>
<p>docker commit -m=””</p>
<p>#查看容器内部详情细节 </p>
<p>docker inspect &lt;id/container_name&gt;   </p>
<p>#登录</p>
<p>docker login </p>
<p>#退出而不关闭容器 Ctrl+P+Q     </p>
<p>docker run -it –rm –name centos6 centos:6.9 /bin/bash  </p>
<p>-it 分配交互式的终端  </p>
<p>–name 指定容器的名字  </p>
<p>/bin/sh覆盖容器的初始命令 </p>
<p>启动命名：docker run -d -p 80:80  -v   waibulj:内部路径  –name</p>
<h3 id="docker命令集"><a href="#docker命令集" class="headerlink" title="docker命令集"></a>docker命令集</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>容器生命周期管理</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#run">run</a></td>
<td>创建一个新容器并运行</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#start">start</a></td>
<td>开启一个容器并使其在后台运行</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#stop">stop</a></td>
<td>停止一个容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#restart">restart</a></td>
<td>重启一个容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#kill">kill</a></td>
<td>杀掉一个容器进程</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#rm">rm</a></td>
<td>删除容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#pause">pause</a></td>
<td>暂停容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#unpause">unpause</a></td>
<td>恢复暂停容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#create">create</a></td>
<td>从镜像中创建一个容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#exec">exec</a></td>
<td>对一个容器执行shell命令</td>
</tr>
<tr>
<td><code>容器操作</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#ps">ps</a></td>
<td>列出容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#inspect">inspect</a></td>
<td>获取容器或镜像的元数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#top">top</a></td>
<td>查看正在运行中的容器进程信息</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#attach">attach</a></td>
<td>链接正在运行的容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#events">events</a></td>
<td>从docker服务器获取事件</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#logs">logs</a></td>
<td>获取docker日志</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#wait">wait</a></td>
<td>让一个容器进入等待，使其进入阻塞状态</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#export">export</a></td>
<td>讲一个容器的文件系统打包至tar</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#port">port</a></td>
<td>列出一个容器的端口映射情况</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#container">container</a></td>
<td>管理已经运行的容器的</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#deploy">deploy</a></td>
<td>部署新的堆栈或更新已有堆栈的</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#update">update</a></td>
<td>更新容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#rename">rename</a></td>
<td>重命名容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#volume">volume</a></td>
<td>卷管理</td>
</tr>
<tr>
<td><code>容器文件系统操作</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#commit">commit</a></td>
<td>提交一个容器的文件系统，使之生成一个新的镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#cp">cp</a></td>
<td>向一个正在运行的容器复制文件，或将容器中的文件复制出来</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#diff">diff</a></td>
<td>检查一个容器文件系统更改情况</td>
</tr>
<tr>
<td><code>镜像仓库操作</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#login">login</a></td>
<td>docker登入</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#logout">logout</a></td>
<td>docker登出</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#pull">pull</a></td>
<td>拉取镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#push">push</a></td>
<td>推送镜像至服务器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#search">search</a></td>
<td>在docker hub上查询镜像</td>
</tr>
<tr>
<td><code>镜像管理</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#images">images</a></td>
<td>列出镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#rmi">rmi</a></td>
<td>删除镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#tag">tag</a></td>
<td>修改本地某一镜像的标记，使其镜像属于某一仓库</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#build">build</a></td>
<td>通过指定Dockerfile文件编译镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#history">history</a></td>
<td>查看镜像历史</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#save">save</a></td>
<td>将制定镜像保存成tar文件</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#load">load</a></td>
<td>从tar中恢复镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#import">import</a></td>
<td>从tar中创建一个新镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#checkpoint">checkpoint</a></td>
<td>设置checkpoint，类似于恢复点，可以让镜像撤销到曾经设置的某一个checkpoint上</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#image">image</a></td>
<td>docker镜像管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#manifest">manifest</a></td>
<td>docker镜像清单管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#trust">trust</a></td>
<td>docker可信镜像管理</td>
</tr>
<tr>
<td><code>集群管理</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#swarm">swarm</a></td>
<td>docker集群管理工具</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#node">node</a></td>
<td>docker集群节点控制</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#stack">stack</a></td>
<td>docker集群堆栈管理</td>
</tr>
<tr>
<td><code>其他命令</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#info">info</a></td>
<td>查询docker信息</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#version">version</a></td>
<td>查询docker版本</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#system">system</a></td>
<td>docker系统管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#stats">stats</a></td>
<td>docker容器资源使用统计</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#config">config</a></td>
<td>管理docker配置</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#network">network</a></td>
<td>docker网络管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#plugin">plugin</a></td>
<td>docker插件管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#secret">secret</a></td>
<td>docker敏感信息管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#service">service</a></td>
<td>docker服务管理</td>
</tr>
</tbody></table>
<h3 id="run命令"><a href="#run命令" class="headerlink" title="run命令"></a>run命令</h3><blockquote>
<p>docker run命令是创建一个新容器并运行，若本地不存在该容器镜像会直接去镜像仓库中查找并自动下载。</p>
</blockquote>
<p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>命令参数说明：</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>默认</th>
<th>说明</th>
<th>特殊示例</th>
</tr>
</thead>
<tbody><tr>
<td>–add-host</td>
<td></td>
<td>为容器添加一个host to ip的映射关系，可以添加若干个，且容器重启后不会消失。若直接修改容器中的/etc/hosts文件，容器重启后会消失</td>
<td>docker run –add-host localhost:127.0.0.1 ubuntu:latest</td>
</tr>
<tr>
<td>–attach(-a)</td>
<td></td>
<td>将容器的stdin,stdout,stderr【标准输入，标准输出，错误输出】关联到本地shell中，在执行docker run时，将所有输入输出指定到本地shell中，若执行时携带此参数，可以指定将stdin,stdout,stderr的某一个或某几个关联到本地shell</td>
<td></td>
</tr>
<tr>
<td>–blkio-weight</td>
<td>0</td>
<td>限制容器读写权重，当宿主机有1个以上容器时，可以设置容器的读写优先权，权重值在10～1000之间，0为关闭权重（该参数默认为0）</td>
<td></td>
</tr>
<tr>
<td>–blkio-weight-device</td>
<td>0</td>
<td>设置针对指定设备的权重，权重值在10～1000之间，且优先级高于blkio.weight</td>
<td>docker run –blkio-weight-device “/dev/sda:100” ubuntu:latest</td>
</tr>
<tr>
<td>–cap-add</td>
<td></td>
<td>增强linux能力，在docker容器内限制了大部分的linux能力，在之前，需要开启这些功能需要结合<code>--privileged</code>开启特权模式才能使用这些参数，考虑到安全性，可以通过该参数来开启指定的linux功能【默认开启的功能及全部定义详见<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/2c632d1a2de0192c3f18a2542ccb6f30a8719b1f/libcontainer/SPEC.md#security">docker runc</a>】，若参数为all则默认开启所有linux能力</td>
<td></td>
</tr>
<tr>
<td>–cap-drop</td>
<td></td>
<td>移除linux能力</td>
<td></td>
</tr>
<tr>
<td>–cgroup-parent</td>
<td></td>
<td>配置容器的控制组，继承该控制组的资源限制模式。扩展阅读:<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html">linux cgroup</a></td>
<td></td>
</tr>
<tr>
<td>–cidfile</td>
<td></td>
<td>创建一个容器，并将该容器的pid输出到某一文件中，若该文件存在，则会返回一个错误</td>
<td>docker run –cidfile /tmp/docker_test.cid ubuntu echo “test”</td>
</tr>
<tr>
<td>–cpu-count</td>
<td>0</td>
<td>设置容器cpu数量<code>仅限Windows版本</code></td>
<td></td>
</tr>
<tr>
<td>–cpu-percent</td>
<td>0</td>
<td>设置容器CPU使用百分比<code>仅限Windows版本</code></td>
<td></td>
</tr>
<tr>
<td>–cpu-period</td>
<td>0</td>
<td>与参数–cpu-quota配合使用，用于设定cpu从新分配资源的时间周期,时间周期结束后，会对cpu进行重新分配。</td>
<td></td>
</tr>
<tr>
<td>–cpu-quota</td>
<td>0</td>
<td>与参数–cpu-period配合使用，用于设定该容器在资源分配周期内占用cpu的时间，若容器设定–cpu-quota=1000000 –cpu-period=500000，则该容器在这个时间周期内权重为50%，这两个参数主要是提升宿主机内某一容器的权重比，可以用来解决宿主机内若干容器的资源抢占导致重要容器cpu性能不足的场景。该模式应用于Linux 的CFS模式，扩展阅读：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cfs/">完全公平调度程序(CFS)</a></td>
<td></td>
</tr>
<tr>
<td>–cpu-rt-period</td>
<td>0</td>
<td>–cpu-period的微秒版</td>
<td></td>
</tr>
<tr>
<td>–cpu-rt-runtime</td>
<td>0</td>
<td>在一个cpu资源分配周期内，优先保证某容器的cpu使用的最大微秒数。例如，默认周期为 1000000 微秒（1秒），设置 –cpu-rt-runtime=950000 可确保使用实时调度程序的容器每 1000000 微秒可运行 950000 微秒，并保留至少 50000 微秒用于非实时任务。</td>
<td></td>
</tr>
<tr>
<td>–cpu-shares(-c)</td>
<td>0</td>
<td>设置容器CPU权重，可以用于调整容器在单位分配周期内的资源优先使用比</td>
<td></td>
</tr>
<tr>
<td>–cpus</td>
<td></td>
<td>设置容器使用cpu的数量，该参数为1.3新增参数用于快速设置容器对于cpu的占用，例如示例，可以直接设置该容器使用多少cpu</td>
<td>docker run –cpus=”.5” ubuntu:latest</td>
</tr>
<tr>
<td>–cpuset-cpus</td>
<td></td>
<td>设置容器允许在哪个cpu上执行该进程，譬如–cpuset-cpus=”1,3”为指定在cpu 1 和cpu 3上执行，–cpuset-cpus=”0-2”为指定在cpu0,cpu1,cpu2上执行</td>
<td>docker run –cpuset-cpus=”1,3” ubuntu:latest docker run –cpuset-cpus=”0-2” ubuntu:latest</td>
</tr>
<tr>
<td>–cpuset-mems</td>
<td></td>
<td>同参数<code>--cpuset-cpus</code>，但该参数是作用于NUMA 架构的 CPU</td>
<td>docker run –cpuset-mems=”1,3” ubuntu:latest docker run –cpuset-mems=”0-2” ubuntu:latest</td>
</tr>
<tr>
<td>–detach(-d)</td>
<td>false</td>
<td>指定该容器运行于前台还是后台</td>
<td></td>
</tr>
<tr>
<td>–detach-keys</td>
<td></td>
<td>设置容器的键盘映射键位，在容器被链接到前台时，若宿主机的键盘键位与容器键位冲突，可以使用该指令对容器的键位进行重新映射</td>
<td></td>
</tr>
<tr>
<td>–device</td>
<td></td>
<td>将宿主机的设备映射至容器</td>
<td></td>
</tr>
<tr>
<td>–device-cgroup-rule</td>
<td></td>
<td>将宿主机的设备添加到cgroup规则列表中</td>
<td></td>
</tr>
<tr>
<td>–device-read-bps</td>
<td></td>
<td>以字节数/每秒的形式限制设备的读取速率</td>
<td>docker run –device-read-bps /dev/sda:100KB ubuntu:latest</td>
</tr>
<tr>
<td>–device-read-iops</td>
<td></td>
<td>以每秒所执行IO操作的次数的形式限制设备的读取速率</td>
<td>docker run –device-read-iops /dev/sda:10 ubuntu:latest</td>
</tr>
<tr>
<td>–device-write-bps</td>
<td></td>
<td>以字节数/每秒的形式限制设备的写入速率</td>
<td></td>
</tr>
<tr>
<td>–device-write-iops</td>
<td></td>
<td>以每秒所执行IO操作的次数的形式限制设备的写入速率</td>
<td></td>
</tr>
<tr>
<td>–disable-content-trust</td>
<td>true</td>
<td>忽略镜像的校验</td>
<td></td>
</tr>
<tr>
<td>–dns</td>
<td></td>
<td>指定容器使用的DNS服务器，默认和宿主一致</td>
<td></td>
</tr>
<tr>
<td>–dns-opt</td>
<td></td>
<td>设置DNS选项，同修改/etc/resolv.conf文件</td>
<td></td>
</tr>
<tr>
<td>–dns-option</td>
<td></td>
<td>设置DNS选项，同修改/etc/resolv.conf文件</td>
<td></td>
</tr>
<tr>
<td>–dns-search</td>
<td></td>
<td>指定容器DNS搜索域名，默认和宿主一致</td>
<td></td>
</tr>
<tr>
<td>–entrypoint</td>
<td></td>
<td>覆盖Dockerfile中设置的entrypoint命令</td>
<td></td>
</tr>
<tr>
<td>–env(-e)</td>
<td></td>
<td>设置/新增环境变量</td>
<td></td>
</tr>
<tr>
<td>–env-file</td>
<td></td>
<td>读取本地环境变量文件，并加载到容器中</td>
<td></td>
</tr>
<tr>
<td>–expose</td>
<td></td>
<td>开放一个端口或一组端口</td>
<td></td>
</tr>
<tr>
<td>–group-add</td>
<td></td>
<td>为容器添加用户组</td>
<td></td>
</tr>
<tr>
<td>–health-cmd</td>
<td></td>
<td>执行一个健康检查命令</td>
<td></td>
</tr>
<tr>
<td>–health-interval</td>
<td>0</td>
<td>配合<code>--health-cmd</code>参数，设置健康检查的执行的间隔时间（ms | s | m | h）</td>
<td></td>
</tr>
<tr>
<td>–health-retries</td>
<td>0</td>
<td>配合<code>--health-cmd</code>参数，设置健康检查命令失败重试的次数</td>
<td></td>
</tr>
<tr>
<td>–health-start-period</td>
<td>0</td>
<td>配合<code>--health-cmd</code>参数，设置健康检查的启动时间（ms | s | m | h）</td>
<td></td>
</tr>
<tr>
<td>–health-timeout</td>
<td>0</td>
<td>配合<code>--health-cmd</code>参数，设置健康检查命令超时时间（ms | s | m | h）</td>
<td></td>
</tr>
<tr>
<td>–help</td>
<td>false</td>
<td>帮助</td>
<td></td>
</tr>
<tr>
<td>–hostname(-h)</td>
<td></td>
<td>指定容器的hostname</td>
<td></td>
</tr>
<tr>
<td>–init</td>
<td>false</td>
<td>使用tini工具在容器中新增一个守护进程，来预防该容器出现僵尸进程的可能性</td>
<td></td>
</tr>
<tr>
<td>–interactive (-i)</td>
<td>false</td>
<td>以交互模式运行容器，并将容器的STDIN（标准输入）打开，通常与参数<code>--tty (-t)</code>配合使用</td>
<td></td>
</tr>
<tr>
<td>–io-maxbandwidth</td>
<td>0</td>
<td>限制容器IO最大速率<code>仅限Windows版本</code></td>
<td></td>
</tr>
<tr>
<td>–io-maxiops</td>
<td>0</td>
<td>以每秒所执行IO操作的次数的形式限制设备的读取速率<code>仅限Windows版本</code></td>
<td></td>
</tr>
<tr>
<td>–ip</td>
<td></td>
<td>设置容器的IPv4地址</td>
<td></td>
</tr>
<tr>
<td>–ip6</td>
<td></td>
<td>设置容器的IPv6地址</td>
<td></td>
</tr>
<tr>
<td>–ipc</td>
<td></td>
<td>启用ipc命名空间。在docker容器中进程交互采用了Linux常见的进程间交互方法(interprocess communication - IPC), 包括信号量、消息队列和共享内存等。容器的进程间交互实际上还是host上具有相同pid命名空间中的进程间交互，因此需要在IPC资源申请时加入命名空间信息，每个IPC资源有一个唯一的32位id。</td>
<td></td>
</tr>
<tr>
<td>–isolation</td>
<td></td>
<td>使用容器隔离。该参数拥有三个值 (1)default 即与使用dockerd –exec-opt的参数默认效果相同 (2)process 使用linux内核命名空间进行隔离，该参数不支持windows环境。 （3）使用微软的Hyper-V虚拟技术进行隔离，该参数仅限windows环境</td>
<td></td>
</tr>
<tr>
<td>–kernel-memory</td>
<td>0</td>
<td>限制该容器内核的内存使用</td>
<td></td>
</tr>
<tr>
<td>–label (-l)</td>
<td></td>
<td>设置该容器的元数据</td>
<td></td>
</tr>
<tr>
<td>–label-file</td>
<td></td>
<td>通过本地文件导入元数据至该容器</td>
<td></td>
</tr>
<tr>
<td>–link</td>
<td></td>
<td>指定容器间的关联，使用其他容器的IP、env等信息</td>
<td></td>
</tr>
<tr>
<td>–link-local-ip</td>
<td></td>
<td>设置本地链路地址（link-local address）ip</td>
<td></td>
</tr>
<tr>
<td>–log-driver</td>
<td></td>
<td>设置一个指定日志接受工具，用于动态收集日志。扩展阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/ZYQDuron/article/details/54614461?utm_source=blogxgwz0">日志处理与log-driver实现</a></td>
<td></td>
</tr>
<tr>
<td>–log-opt</td>
<td></td>
<td>配合参数<code>--log-driver</code>使用，用于设置日志输出参数</td>
<td></td>
</tr>
<tr>
<td>–mac-address</td>
<td></td>
<td>设置该容器mac地址</td>
<td></td>
</tr>
<tr>
<td>–memory -m</td>
<td>0</td>
<td>限制该容器内存使用</td>
<td></td>
</tr>
<tr>
<td>–memory-reservation</td>
<td>0</td>
<td>软限制该容器的内存使用，当宿主机内存空闲时，该容器的内存使用可以一定比例超出限制，但当宿主机内存紧张时，会强制该容器内存使用限制在该参数之内</td>
<td></td>
</tr>
<tr>
<td>–memory-swap</td>
<td>0</td>
<td>内存交换分区大小限制。配合参数<code>--memory</code>使用，且最小内存交换限制应该大于内存限制。该参数有4种情况： (1)不设置–memory与该参数:则该容器默认可以用完宿舍机的所有内存和 宿主机 swap 分区。 (2)设置–memory 50MB 不设置–memory-swap（默认为0）:则–memory-swap值等于限制内存大小，即该容器能够申请的最大内存为100MB。 (3)设置–memory 50MB –memory-swap为-1:则该容器最大可以申请的内存为50MB+宿主机swap分区大小 (4)设置–memory 50MB –memory-swap 100MB：则该容器可以申请的最大内存为100MB-50MB=50MB</td>
<td></td>
</tr>
<tr>
<td>–memory-swappiness</td>
<td>-1</td>
<td>用于调整虚拟内存的控制行为，为0～100之间的整数。在linux内存管理中，将内存中不活跃的页交换至硬盘中，以缓解内存紧张，该参数设置为0则认定该容器所有内存中的内容均不允许交换至硬盘，用以保障最大性能，若设置为100，则认为该容器所有内存中的数据均可以交换至硬盘。扩展阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/jasonchen_gbd/article/details/79462014">Linux内存管理</a></td>
<td></td>
</tr>
<tr>
<td>–mount</td>
<td></td>
<td>将文件系统挂载附加到容器</td>
<td></td>
</tr>
<tr>
<td>–name</td>
<td></td>
<td>设置该容器的名称</td>
<td></td>
</tr>
<tr>
<td>–net</td>
<td></td>
<td>将容器连接到网络，支持bridge/host/none/container四种类型</td>
<td></td>
</tr>
<tr>
<td>–net-alias</td>
<td></td>
<td>设置该容器在网络上的别名</td>
<td></td>
</tr>
<tr>
<td>–network</td>
<td></td>
<td>将容器连接到网络，支持bridge/host/none/container四种类型</td>
<td></td>
</tr>
<tr>
<td>–network-alias</td>
<td></td>
<td>设置该容器在网络上的别名</td>
<td></td>
</tr>
<tr>
<td>–no-healthcheck</td>
<td>false</td>
<td>禁止一切健康检查行为</td>
<td></td>
</tr>
<tr>
<td>–oom-kill-disable</td>
<td>false</td>
<td>设置是否禁止oom kill行为，若该容器因为需要大量请求内存，导致宿主机内存不足或触发到内存限制，导致杀死该容器进程，若设置该参数为true则会关闭这个检查</td>
<td></td>
</tr>
<tr>
<td>–oom-score-adj</td>
<td>0</td>
<td>调整主机的OOM首选项（从-1000到1000）此处需要注意的是，非专业人士docker官方是不建议用户修改<code>--oom-score-adj``--oom-kill-disable</code>这两个参数的</td>
<td></td>
</tr>
<tr>
<td>–pid</td>
<td></td>
<td>自定义设置该容器的pid</td>
<td></td>
</tr>
<tr>
<td>–pids-limit</td>
<td>0</td>
<td>该参数值为整数，为限制该容器所能创建的最大进程数。</td>
<td></td>
</tr>
<tr>
<td>–privileged</td>
<td>false</td>
<td>在该容器上开启特权模式，让该容器拥有所有的linux能力</td>
<td></td>
</tr>
<tr>
<td>–publish -p</td>
<td></td>
<td>将容器的端口映射到宿主机上</td>
<td>docker run -p 8000:8000 ubuntu</td>
</tr>
<tr>
<td>–publish-all (-P)</td>
<td>false</td>
<td>将该容器的所有端口均随机映射至宿主机</td>
<td></td>
</tr>
<tr>
<td>–read-only</td>
<td>false</td>
<td>设置该容器只读</td>
<td></td>
</tr>
<tr>
<td>–restart</td>
<td>no</td>
<td>在退出该容器时重启该容器</td>
<td></td>
</tr>
<tr>
<td>–rm</td>
<td>false</td>
<td>当退出该容器时自动删除该容器资源</td>
<td></td>
</tr>
<tr>
<td>–runtime</td>
<td></td>
<td>指定该容器关联一个runtime的容器，在使用该参数时注意runtime specified必须在<code>dockerd --add-runtime</code>注册过。扩展阅读<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009583199">什么是容器的runtime</a>与<a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2017/02/Docker-Containerd-RunC">Docker、Containerd、RunC之间的进程关系</a></td>
<td></td>
</tr>
<tr>
<td>–security-opt</td>
<td></td>
<td>设置安全属性，在windows上使用CredentialSpec模块来执行身份识别。</td>
<td></td>
</tr>
<tr>
<td>–shm-size</td>
<td>0</td>
<td>设置/dev/shm/目录的大小</td>
<td></td>
</tr>
<tr>
<td>–sig-proxy</td>
<td>true</td>
<td>代理进程所接收的所有字符,当指定–sig-proxy=false时，ctrl+c和ctrl+d 不会传递信号给docker进程而关闭容器。</td>
<td></td>
</tr>
<tr>
<td>–stop-signal</td>
<td>SIGTERM</td>
<td>停止带有信号的容器，在linux环境下输入<code>kill -l</code>,就可以看到所有信号名称，可以指定容器发出某种信号时停止该容器，譬如<code>SIGKILL</code></td>
<td></td>
</tr>
<tr>
<td>–stop-timeout</td>
<td>0</td>
<td>设置容器调用命令超时后自动退出。该参数可以设置容器在调用命令时导致超时后多少秒退出，0为永远不退出，该参数单位为秒</td>
<td></td>
</tr>
<tr>
<td>–storage-opt</td>
<td></td>
<td>设定该容器的存储空间，可以分别指定dm.basesize、dm.loopdatasize、dm.loopmetadatasize等项,指定单个容器可用数据空间、docker可用数据空间、元数据可用数据空。</td>
<td>docker run –storage-opt dm.basesize=20G ubuntu</td>
</tr>
<tr>
<td>–sysctl</td>
<td>map[]</td>
<td>修改内核参数，对应修改容器中的<code>/etc/sysctl.conf</code>文件</td>
<td></td>
</tr>
<tr>
<td>–tmpfs</td>
<td></td>
<td>指定挂载一个tmpfs目录，tmpfs是一种虚拟内存文件系统。可以不经由镜像直接创建一个容器</td>
<td>docker run -d –tmpfs /run:rw,noexec,nosuid,size=65536k my_image</td>
</tr>
<tr>
<td>–tty (-t)</td>
<td>false</td>
<td>为容器重新分配一个伪输入终端，通常与参数<code>--interactive (-i)</code>同时使用</td>
<td></td>
</tr>
<tr>
<td>–ulimit</td>
<td></td>
<td>设置容器的ulimit选项，扩展阅读<a target="_blank" rel="noopener" href="http://man.linuxde.net/ulimit">ulimit命令</a></td>
<td></td>
</tr>
<tr>
<td>–user (-u)</td>
<td></td>
<td>在该容器下添加新用户</td>
<td></td>
</tr>
<tr>
<td>–userns</td>
<td></td>
<td>指定该容器运行在指定host user namespace中</td>
<td></td>
</tr>
<tr>
<td>–uts</td>
<td></td>
<td>使用uts命名空间。扩展阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/weifenghai/article/details/52836109">Linux命名空间入门</a></td>
<td></td>
</tr>
<tr>
<td>–volume (-v)</td>
<td></td>
<td>在该容器下挂载新卷</td>
<td></td>
</tr>
<tr>
<td>–volume-driver</td>
<td></td>
<td>挂载一个卷容器，该卷可以是一个本地共享卷或者一个远程服务，配合<code>docker volume create</code>命令创建一个卷</td>
<td></td>
</tr>
<tr>
<td>–volumes-from</td>
<td></td>
<td>可以将任意文件夹反挂载到卷中，从而快速实现对该容器的备份与迁移。</td>
<td>docker run –rm –volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</td>
</tr>
<tr>
<td>–workdir (-w)</td>
<td></td>
<td>指定容器的工作目录与Dockerfile中的<code>WORKDIR</code>作用相同</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="start命令"><a href="#start命令" class="headerlink" title="start命令"></a>start命令</h3><blockquote>
<p>docker start是用于启动容器的命令</p>
</blockquote>
<hr>
<p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="容器运维操作"><a href="#容器运维操作" class="headerlink" title="容器运维操作"></a>容器运维操作</h3><h4 id="–attach命令"><a href="#–attach命令" class="headerlink" title="–attach命令"></a>–attach命令</h4><p>docker attach命令对应开发者很有用，可以连接到正在运行的容器，观察容器的运行状况，或与容器的主进程进行交互。</p>
<h4 id="–inspect命令"><a href="#–inspect命令" class="headerlink" title="–inspect命令"></a>–inspect命令</h4><p>用于查看镜像和容器的详细信息，默认会列出全部信息，可以通过–format参数来指定输出的模板格式，以便输出特定信息。</p>
<h4 id="查看容器的信息container（ps）"><a href="#查看容器的信息container（ps）" class="headerlink" title="查看容器的信息container（ps）"></a>查看容器的信息container（ps）</h4><p><code>docker ps</code>命令可以查看容器的<code>CONTAINER ID</code>、<code>NAME</code>、<code>IMAGE NAME</code>、端口开启及绑定、容器启动后执行的<code>COMMNAD</code>。最常用的功能是通过<code>ps</code>来找到<code>CONTAINER_ID，以便对特定容器进行操作。</code><br><code>docker ps</code> 默认显示当前正在运行中的container<br><code>docker ps -a</code> 查看包括已经停止的所有容器<br><code>docker ps -l</code> 显示最新启动的一个容器（包括已停止的）</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[devadmin@swarm1 ~]$ docker ps -l</span><br><span class="line">CONTAINER ID        IMAGE                                            COMMAND              CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">1cfb8ad8642e        regloc.com&#x2F;test&#x2F;settlequery:201711271708   &quot;sh entrypoint.sh&quot;   22 hours ago        Up 22 hours         0.0.0.0:18182-&gt;18182&#x2F;tcp   settlequery.z4taavbos34np74za1bu674az.ncj2uocqbh15ljxhui0yccd9t</span><br><span class="line">[devadmin@swarm1 ~]$ </span><br></pre></td></tr></table></figure>



<h3 id="–-列出机器上的镜像（images）"><a href="#–-列出机器上的镜像（images）" class="headerlink" title="– 列出机器上的镜像（images）"></a>– 列出机器上的镜像（images）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker images </span><br><span class="line">REPOSITORY               TAG             IMAGE ID        CREATED         VIRTUAL SIZE</span><br><span class="line">ubuntu                   14.10           2185fd50e2ca    13 days ago     236.9 MB</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>其中我们可以根据REPOSITORY来判断这个镜像是来自哪个服务器，如果没有 / 则表示官方镜像，类似于<code>username/repos_name</code>表示Github的个人公共库，类似于<code>regsistory.example.com:5000/repos_name</code>则表示的是私服。<br>IMAGE ID列其实是缩写，要显示完整则带上<code>--no-trunc</code>选项</p>
<h3 id="2-在docker-index中搜索image（search）"><a href="#2-在docker-index中搜索image（search）" class="headerlink" title="2. 在docker index中搜索image（search）"></a>2. 在docker index中搜索image（search）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker search TERM</span><br><span class="line"># docker search seanlo</span><br><span class="line">NAME                DESCRIPTION           STARS     OFFICIAL   AUTOMATED</span><br><span class="line">seanloook&#x2F;centos6   sean&#39;s docker repos         0</span><br></pre></td></tr></table></figure>

<p>搜索的范围是官方镜像和所有个人公共镜像。NAME列的 / 后面是仓库的名字。</p>
<h3 id="3-从docker-registry-server-中下拉image或repository（pull）"><a href="#3-从docker-registry-server-中下拉image或repository（pull）" class="headerlink" title="3. 从docker registry server 中下拉image或repository（pull）"></a>3. 从docker registry server 中下拉image或repository（pull）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line"># docker pull centos</span><br></pre></td></tr></table></figure>

<p>上面的命令需要注意，在docker v1.2版本以前，会下载官方镜像的centos仓库里的所有镜像，而从v.13开始官方文档里的说明变了：will pull the centos:latest image, its intermediate layers and any aliases of the same id，也就是只会下载tag为latest的镜像（以及同一images id的其他tag）。<br>也可以明确指定具体的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull centos:centos6</span><br></pre></td></tr></table></figure>

<p>当然也可以从某个人的公共仓库（包括自己是私人仓库）拉取，形如<code>docker pull username/repository&lt;:tag_name&gt;</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull seanlook&#x2F;centos:centos6</span><br></pre></td></tr></table></figure>

<p>如果你没有网络，或者从其他私服获取镜像，形如<code>docker pull registry.domain.com:5000/repos:&lt;tag_name&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull dl.dockerpool.com:5000&#x2F;mongo:latest</span><br></pre></td></tr></table></figure>

<h3 id="4-推送一个image或repository到registry（push）"><a href="#4-推送一个image或repository到registry（push）" class="headerlink" title="4. 推送一个image或repository到registry（push）"></a>4. 推送一个image或repository到registry（push）</h3><p>与上面的pull对应，可以推送到Docker Hub的Public、Private以及私服，但不能推送到Top Level Repository。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker push seanlook&#x2F;mongo</span><br><span class="line"># docker push registry.tp-link.net:5000&#x2F;mongo:2014-10-27</span><br></pre></td></tr></table></figure>

<p>registry.tp-link.net也可以写成IP，172.29.88.222。<br>在repository不存在的情况下，命令行下push上去的会为我们创建为私有库，然而通过浏览器创建的默认为公共库。</p>
<h3 id="5-从image启动一个container（run）"><a href="#5-从image启动一个container（run）" class="headerlink" title="5. 从image启动一个container（run）"></a>5. 从image启动一个container（run）</h3><p><code>docker run</code>命令首先会从特定的image创之上create一层可写的container，然后通过start命令来启动它。停止的container可以重新启动并保留原来的修改。run命令启动参数有很多，以下是一些常规使用说明<br>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<h4 id="5-1-使用image创建container并执行相应命令，然后停止"><a href="#5-1-使用image创建container并执行相应命令，然后停止" class="headerlink" title="5.1 使用image创建container并执行相应命令，然后停止"></a>5.1 使用image创建container并执行相应命令，然后停止</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run ubuntu echo &quot;hello world&quot;</span><br><span class="line">hello word</span><br></pre></td></tr></table></figure>

<p>这是最简单的方式，跟在本地直接执行<code>echo &#39;hello world&#39;</code> 几乎感觉不出任何区别，而实际上它会从本地ubuntu:latest镜像启动到一个容器，并执行打印命令后退出（<code>docker ps -l</code>可查看）。需要注意的是，默认有一个<code>--rm=true</code>参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。<br>容器启动后会自动随机生成一个<code>CONTAINER ID</code>，这个ID在后面commit命令后可以变为<code>IMAGE ID</code></p>
<h4 id="使用image创建container并进入交互模式-login-shell是-bin-bash"><a href="#使用image创建container并进入交互模式-login-shell是-bin-bash" class="headerlink" title="使用image创建container并进入交互模式, login shell是/bin/bash"></a>使用image创建container并进入交互模式, login shell是/bin/bash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run -i -t --name mytest centos:centos6 &#x2F;bin&#x2F;bash</span><br><span class="line">bash-4.1#</span><br></pre></td></tr></table></figure>

<p>上面的<code>--name</code>参数可以指定启动后的容器名字，如果不指定则docker会帮我们取一个名字。镜像<code>centos:centos6</code>也可以用<code>IMAGE ID</code> (68edf809afe7) 代替），并且会启动一个伪终端，但通过ps或top命令我们却只能看到一两个进程，因为容器的核心是所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外，并没有其它的资源，可见Docker对资源的利用率极高。此时使用exit或Ctrl+D退出后，这个容器也就消失了（消失后的容器并没有完全删除？）<br>（那么多个TAG不同而IMAGE ID相同的的镜像究竟会运行以哪一个TAG启动呢</p>
<h4 id="5-2-运行出一个container放到后台运行"><a href="#5-2-运行出一个container放到后台运行" class="headerlink" title="5.2 运行出一个container放到后台运行"></a>5.2 运行出一个container放到后台运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d ubuntu &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 2; done&quot;</span><br><span class="line">ae60c4b642058fefcc61ada85a610914bed9f5df0e2aa147100eab85cea785dc</span><br></pre></td></tr></table></figure>

<p>它将直接把启动的container挂起放在后台运行（这才叫saas），并且会输出一个<code>CONTAINER ID</code>，通过<code>docker ps</code>可以看到这个容器的信息，可在container外面查看它的输出<code>docker logs ae60c4b64205</code>，也可以通过<code>docker attach ae60c4b64205</code>连接到这个正在运行的终端，此时在<code>Ctrl+C</code>退出container就消失了，按ctrl-p ctrl-q可以退出到宿主机，而保持container仍然在运行<br>另外，如果-d启动但后面的命令执行完就结束了，如<code>/bin/bash</code>、<code>echo test</code>，则container做完该做的时候依然会终止。而且-d不能与–rm同时使用<br>可以通过这种方式来运行memcached、apache等。</p>
<h4 id="5-3-映射host到container的端口和目录"><a href="#5-3-映射host到container的端口和目录" class="headerlink" title="5.3 映射host到container的端口和目录"></a>5.3 映射host到container的端口和目录</h4><p>映射主机到容器的端口是很有用的，比如在container中运行memcached，端口为11211，运行容器的host可以连接container的 internel_ip:11211 访问，如果有从其他主机访问memcached需求那就可以通过-p选项，形如<code>-p &lt;host_port:contain_port&gt;</code>，存在以下几种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p 11211:11211 这个即是默认情况下，绑定主机所有网卡（0.0.0.0）的11211端口到容器的11211端口上</span><br><span class="line">-p 127.0.0.1:11211:11211 只绑定localhost这个接口的11211端口</span><br><span class="line">-p 127.0.0.1::5000</span><br><span class="line">-p 127.0.0.1:80:8080</span><br></pre></td></tr></table></figure>

<p>目录映射其实是“绑定挂载”host的路径到container的目录，这对于内外传送文件比较方便，在搭建私服那一节，为了避免私服container停止以后保存的images不被删除，就要把提交的images保存到挂载的主机目录下。使用比较简单，<code>-v &lt;host_path:container_path&gt;</code>，绑定多个目录时再加<code>-v</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v &#x2F;tmp&#x2F;docker:&#x2F;tmp&#x2F;docker</span><br></pre></td></tr></table></figure>

<p>另外在两个container之间建立联系可用<code>--link</code>，<br>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker run --name nginx_test \</span><br><span class="line">&gt; -v &#x2F;tmp&#x2F;docker:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:ro \</span><br><span class="line">&gt; -p 80:80 -d \</span><br><span class="line">&gt; nginx:1.7.6</span><br></pre></td></tr></table></figure>

<p>在主机的/tmp/docker下建立index.html，就可以通过<code>http://localhost:80/</code>或<code>http://host-ip:80</code>访问了。</p>
<h3 id="6-将一个container固化为一个新的image（commit）"><a href="#6-将一个container固化为一个新的image（commit）" class="headerlink" title="6. 将一个container固化为一个新的image（commit）"></a>6. 将一个container固化为一个新的image（commit）</h3><p>当我们在制作自己的镜像的时候，会在container中安装一些工具、修改配置，如果不做commit保存起来，那么container停止以后再启动，这些更改就消失了。<br><code>docker commit &lt;container&gt; [repo:tag]</code><br>后面的repo:tag可选<br>只能提交正在运行的container，即通过<code>docker ps</code>可以看见的容器，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">查看刚运行过的容器</span><br><span class="line"># docker ps -l</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND      CREATED       STATUS        PORTS   NAMES</span><br><span class="line">c9fdf26326c9   nginx:1   nginx -g..   3 hours ago   Exited (0)..     nginx_test</span><br><span class="line"></span><br><span class="line">启动一个已存在的容器（run是从image新建容器后再启动），以下也可以使用docker start nginx_test代替  </span><br><span class="line">[root@hostname docker]# docker start c9fdf26326c9</span><br><span class="line">c9fdf26326c9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -i -t --sig-proxy&#x3D;false 21ffe545748baf &#x2F;bin&#x2F;bash</span><br><span class="line">nginx服务没有启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># docker commit -m &quot;some tools installed&quot; fcbd0a5348ca seanlook&#x2F;ubuntu:14.10_tutorial</span><br><span class="line">fe022762070b09866eaab47bc943ccb796e53f3f416abf3f2327481b446a9503</span><br><span class="line">请注意，当你反复去commit一个容器的时候，每次都会得到一个新的&#96;IMAGE ID&#96;，假如后面的&#96;repository:tag&#96;没有变，通过&#96;docker images&#96;可以看到，之前提交的那份镜像的&#96;repository:tag&#96;就会变成&#96;&lt;none&gt;:&lt;none&gt;&#96;，所以尽量避免反复提交。</span><br><span class="line">另外，观察以下几点:</span><br></pre></td></tr></table></figure>

<ul>
<li>commit container只会pause住容器，这是为了保证容器文件系统的一致性，但不会stop。如果你要对这个容器继续做其他修改：<ul>
<li>你可以重新提交得到新image2，删除次新的image1</li>
<li>也可以关闭容器用新image1启动，继续修改，提交image2后删除image1</li>
<li>当然这样会很痛苦，所以一般是采用<code>Dockerfile</code>来<code>build</code>得到最终image，参考[]</li>
</ul>
</li>
<li>虽然产生了一个新的image，并且你可以看到大小有100MB，但从commit过程很快就可以知道实际上它并没有独立占用100MB的硬盘空间，而只是在旧镜像的基础上修改，它们共享大部分公共的“片”。</li>
</ul>
<p>下</p>
<h3 id="1-开启-停止-重启container（start-stop-restart）"><a href="#1-开启-停止-重启container（start-stop-restart）" class="headerlink" title="1. 开启/停止/重启container（start/stop/restart）"></a>1. 开启/停止/重启container（start/stop/restart）</h3><p>容器可以通过<code>run</code>新建一个来运行，也可以重新<code>start</code>已经停止的container，但<code>start</code>不能够再指定容器启动时运行的指令，因为docker只能有一个前台进程。<br>容器stop（或<code>Ctrl+D</code>）时，会在保存当前容器的状态之后退出，下次start时保有上次关闭时更改。而且每次进入<code>attach</code>进去的界面是一样的，与第一次run启动或commit提交的时刻相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER_ID&#x3D;$(docker start &lt;containner_id&gt;)</span><br><span class="line">docker stop $CONTAINER_ID</span><br><span class="line">docker restart $CONTAINER_ID</span><br></pre></td></tr></table></figure>

<h3 id="2-连接到正在运行中的container（attach）"><a href="#2-连接到正在运行中的container（attach）" class="headerlink" title="2. 连接到正在运行中的container（attach）"></a>2. 连接到正在运行中的container（attach）</h3><p>要<code>attach</code>上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与<code>screen</code>命令的attach类似）。<br>官方文档中说<code>attach</code>后可以通过<code>CTRL-C</code>来detach，但实际上经过我的测试，如果container当前在运行bash，<code>CTRL-C</code>自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，<code>CTRL-C</code>不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在<code>attach</code>是可以带上<code>--sig-proxy=false</code>来确保<code>CTRL-D</code>或<code>CTRL-C</code>不会关闭容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker attach --sig-proxy&#x3D;false $CONTAINER_ID</span><br></pre></td></tr></table></figure>

<h3 id="3-查看image或container的底层信息（inspect）"><a href="#3-查看image或container的底层信息（inspect）" class="headerlink" title="3. 查看image或container的底层信息（inspect）"></a>3. 查看image或container的底层信息（inspect）</h3><p><code>inspect</code>的对象可以是image、运行中的container和停止的container。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看容器的内部IP</span><br><span class="line"># docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; $CONTAINER_ID</span><br><span class="line">172.17.42.35</span><br></pre></td></tr></table></figure>

<h3 id="4-删除一个或多个container、image（rm、rmi）"><a href="#4-删除一个或多个container、image（rm、rmi）" class="headerlink" title="4. 删除一个或多个container、image（rm、rmi）"></a>4. 删除一个或多个container、image（rm、rmi）</h3><p>你可能在使用过程中会<code>build</code>或<code>commit</code>许多镜像，无用的镜像需要删除。但删除这些镜像是有一些条件的：</p>
<ul>
<li>同一个<code>IMAGE ID</code>可能会有多个<code>TAG</code>（可能还在不同的仓库），首先你要根据这些 image names 来删除标签，当删除最后一个tag的时候就会自动删除镜像；</li>
<li>承上，如果要删除的多个<code>IMAGE NAME</code>在同一个<code>REPOSITORY</code>，可以通过<code>docker rmi &lt;image_id&gt;</code>来同时删除剩下的<code>TAG</code>；若在不同Repo则还是需要手动逐个删除<code>TAG</code>；</li>
<li>还存在由这个镜像启动的container时（即便已经停止），也无法删除镜像；</li>
</ul>
<p>TO-DO<br>如何查看镜像与容器的依存关系</p>
<p>删除容器<br><code>docker rm &lt;container_id/contaner_name&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除所有停止的容器</span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>

<p>删除镜像<br>docker rmi &lt;image_id/image_name …&gt;`</p>
<h3 id="5-docker-build-使用此配置生成新的image"><a href="#5-docker-build-使用此配置生成新的image" class="headerlink" title="5. docker build 使用此配置生成新的image"></a>5. docker build 使用此配置生成新的image</h3><p><code>build</code>命令可以从<code>Dockerfile</code>和上下文来创建镜像：<br><code>docker build [OPTIONS] PATH | URL | -</code><br>上面的<code>PATH</code>或<code>URL</code>中的文件被称作上下文，build image的过程会先把这些文件传送到docker的服务端来进行的。<br>如果<code>PATH</code>直接就是一个单独的<code>Dockerfile</code>文件则可以不需要上下文；如果<code>URL</code>是一个Git仓库地址，那么创建image的过程中会自动<code>git clone</code>一份到本机的临时目录，它就成为了本次build的上下文。无论指定的<code>PATH</code>是什么，<code>Dockerfile</code>是至关重要的，请参考<a target="_blank" rel="noopener" href="http://docs.docker.com/reference/builder/">Dockerfile Reference</a>。<br>请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># cat Dockerfile </span><br><span class="line">FROM seanlook&#x2F;nginx:bash_vim</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTRYPOINT &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &amp;&amp; &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># docker build -t seanlook&#x2F;nginx:bash_vim_Df .</span><br><span class="line">Sending build context to Docker daemon 73.45 MB</span><br><span class="line">Sending build context to Docker daemon </span><br><span class="line">Step 0 : FROM seanlook&#x2F;nginx:bash_vim</span><br><span class="line"> ---&gt; aa8516fa0bb7</span><br><span class="line">Step 1 : EXPOSE 80</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; fece07e2b515</span><br><span class="line">Step 2 : ENTRYPOINT &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &amp;&amp; &#x2F;bin&#x2F;bash</span><br><span class="line"> ---&gt; Running in e08963fd5afb</span><br><span class="line"> ---&gt; d9bbd13f5066</span><br><span class="line">Removing intermediate container e08963fd5afb</span><br><span class="line">Successfully built d9bbd13f5066</span><br></pre></td></tr></table></figure>

<p>上面的<code>PATH</code>为<code>.</code>，所以在当前目录下的所有文件（不包括<code>.dockerignore</code>中的）将会被<code>tar</code>打包并传送到<code>docker daemon</code>（一般在本机），从输出我们可以到<code>Sending build context...</code>，最后有个<code>Removing intermediate container</code>的过程，可以通过<code>--rm=false</code>来保留容器。<br>TO-DO<br><code>docker build github.com/creack/docker-firefox</code>失败。</p>
<h3 id="6-给镜像打上标签（tag）"><a href="#6-给镜像打上标签（tag）" class="headerlink" title="6. 给镜像打上标签（tag）"></a>6. 给镜像打上标签（tag）</h3><p>tag的作用主要有两点：一是为镜像起一个容易理解的名字，二是可以通过<code>docker tag</code>来重新指定镜像的仓库，这样在<code>push</code>时自动提交到仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将同一IMAGE_ID的所有tag，合并为一个新的</span><br><span class="line"># docker tag 195eb90b5349 seanlook&#x2F;ubuntu:rm_test</span><br><span class="line"></span><br><span class="line">新建一个tag，保留旧的那条记录</span><br><span class="line"># docker tag Registry&#x2F;Repos:Tag New_Registry&#x2F;New_Repos:New_Tag</span><br></pre></td></tr></table></figure>

<h3 id="7-查看容器的信息container（ps）"><a href="#7-查看容器的信息container（ps）" class="headerlink" title="7. 查看容器的信息container（ps）"></a>7. 查看容器的信息container（ps）</h3><p><code>docker ps</code>命令可以查看容器的<code>CONTAINER ID</code>、<code>NAME</code>、<code>IMAGE NAME</code>、端口开启及绑定、容器启动后执行的<code>COMMNAD</code>。经常通过<code>ps</code>来找到<code>CONTAINER_ID</code>。<br><code>docker ps</code> 默认显示当前正在运行中的container<br><code>docker ps -a</code> 查看包括已经停止的所有容器<br><code>docker ps -l</code> 显示最新启动的一个容器（包括已停止的）</p>
<h3 id="8-查看容器中正在运行的进程（top）"><a href="#8-查看容器中正在运行的进程（top）" class="headerlink" title="8. 查看容器中正在运行的进程（top）"></a>8. 查看容器中正在运行的进程（top）</h3><p>容器运行时不一定有<code>/bin/bash</code>终端来交互执行top命令，查看container中正在运行的进程，况且还不一定有<code>top</code>命令，这是<code>docker top &lt;container_id/container_name&gt;</code>就很有用了。实际上在host上使用<code>ps -ef|grep docker</code>也可以看到一组类似的进程信息，把container里的进程看成是host上启动docker的子进程就对了。</p>
<h3 id="9-其他命令"><a href="#9-其他命令" class="headerlink" title="9. 其他命令"></a>9. 其他命令</h3><p>docker还有一些如<code>login</code>、<code>cp</code>、<code>logs</code>、<code>export</code>、<code>import</code>、<code>load</code>、<code>kill</code>等不是很常用的命令，比较简单，请参考官网。</p>
<h3 id="events、history和logs命令"><a href="#events、history和logs命令" class="headerlink" title="events、history和logs命令"></a>events、history和logs命令</h3><p>这3个命令用于查看Docker的系统日志信息。events命令会打印出实时的系统事件；history命令会打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的命令记录；logs命令会打印出容器中进程的运行日志。</p>
<p>docker events [options] ：从服务器获取实时事件。</p>
<p>OPTIONS说明：</p>
<ul>
<li><strong>-f ：</strong>根据条件过滤事件；</li>
<li><strong>–since ：</strong>从指定的时间戳后显示所有事件;</li>
<li><strong>–until ：</strong>流水时间显示到指定的时间为止；</li>
</ul>
<p>docker history [options] image：查看指定镜像的创建历史。</p>
<p>OPTIONS说明：</p>
<ul>
<li>**-H :**以可读的格式打印镜像大小和日期，默认为true；</li>
<li>**–no-trunc :**显示完整的提交记录；</li>
<li>**-q :**仅列出提交记录ID。</li>
</ul>
<p>docker logs [options] container</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">        --details        显示更多的信息</span><br><span class="line">    -f, --follow         跟踪日志输出，最后一行为当前时间戳的日志</span><br><span class="line">        --since string   显示自具体某个时间或时间段的日志</span><br><span class="line">        --tail string    从日志末尾显示多少行日志， 默认是all</span><br><span class="line">    -t, --timestamps     显示时间戳</span><br></pre></td></tr></table></figure>

<p>FROM registry.ihdou.com/node:10.15.3-alpine<br>MAINTAINER Charlie<br>ENV NODE_ENV=production<br>ENV HOST 0.0.0.0<br>RUN mkdir -p /social-statics-app<br>COPY . /social-statics-app<br>WORKDIR /social-statics-app<br>EXPOSE 3000<br>RUN apk add –no-cache make gcc g++ python<br>RUN npm install<br>RUN npm rebuild node-sass<br>RUN npm run build<br>RUN npm cache clean –force<br>RUN apk del make gcc g++ python<br>CMD [“npm”, “start”]</p>
<p>镜像构建：</p>
<p>docker build -t social-statics-app .</p>
<p>docker build -t registry.ihdou.com/search .</p>
<p>项目启动命令：</p>
<p>docker run -dt –rm  -p 3000:3000 social-statics-app</p>
<p>docker run -it –rm  -v /usr/local/jars:/logs –name zuul zuul</p>
<p>docker run -it –rm -p 10014:10014  -v /usr/local/jars:/logs –name search search:v1</p>
<p>docker run -it –rm -p 38012:38012  -v /usr/local/jars:/logs registry.ihdou.com/4.0/wallet</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/" rel="prev" title="Docker Dockerfile">
      <i class="fa fa-chevron-left"></i> Docker Dockerfile
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/" rel="next" title="Docker 搭建私有仓库">
      Docker 搭建私有仓库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">命令介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#docker%E7%9A%84%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">docker的镜像管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">docker的容器管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker%E5%91%BD%E4%BB%A4%E9%9B%86"><span class="nav-number">1.3.</span> <span class="nav-text">docker命令集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#run%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.</span> <span class="nav-text">run命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#start%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">start命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.</span> <span class="nav-text">容器运维操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%93attach%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.1.</span> <span class="nav-text">–attach命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%93inspect%E5%91%BD%E4%BB%A4"><span class="nav-number">1.6.2.</span> <span class="nav-text">–inspect命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BF%A1%E6%81%AFcontainer%EF%BC%88ps%EF%BC%89"><span class="nav-number">1.6.3.</span> <span class="nav-text">查看容器的信息container（ps）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%93-%E5%88%97%E5%87%BA%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%88images%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">– 列出机器上的镜像（images）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9C%A8docker-index%E4%B8%AD%E6%90%9C%E7%B4%A2image%EF%BC%88search%EF%BC%89"><span class="nav-number">1.8.</span> <span class="nav-text">2. 在docker index中搜索image（search）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BB%8Edocker-registry-server-%E4%B8%AD%E4%B8%8B%E6%8B%89image%E6%88%96repository%EF%BC%88pull%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">3. 从docker registry server 中下拉image或repository（pull）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8E%A8%E9%80%81%E4%B8%80%E4%B8%AAimage%E6%88%96repository%E5%88%B0registry%EF%BC%88push%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">4. 推送一个image或repository到registry（push）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BB%8Eimage%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAcontainer%EF%BC%88run%EF%BC%89"><span class="nav-number">1.11.</span> <span class="nav-text">5. 从image启动一个container（run）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E4%BD%BF%E7%94%A8image%E5%88%9B%E5%BB%BAcontainer%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%BA%94%E5%91%BD%E4%BB%A4%EF%BC%8C%E7%84%B6%E5%90%8E%E5%81%9C%E6%AD%A2"><span class="nav-number">1.11.1.</span> <span class="nav-text">5.1 使用image创建container并执行相应命令，然后停止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8image%E5%88%9B%E5%BB%BAcontainer%E5%B9%B6%E8%BF%9B%E5%85%A5%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F-login-shell%E6%98%AF-bin-bash"><span class="nav-number">1.11.2.</span> <span class="nav-text">使用image创建container并进入交互模式, login shell是&#x2F;bin&#x2F;bash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E8%BF%90%E8%A1%8C%E5%87%BA%E4%B8%80%E4%B8%AAcontainer%E6%94%BE%E5%88%B0%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="nav-number">1.11.3.</span> <span class="nav-text">5.2 运行出一个container放到后台运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E6%98%A0%E5%B0%84host%E5%88%B0container%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="nav-number">1.11.4.</span> <span class="nav-text">5.3 映射host到container的端口和目录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%B0%86%E4%B8%80%E4%B8%AAcontainer%E5%9B%BA%E5%8C%96%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84image%EF%BC%88commit%EF%BC%89"><span class="nav-number">1.12.</span> <span class="nav-text">6. 将一个container固化为一个新的image（commit）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%80%E5%90%AF-%E5%81%9C%E6%AD%A2-%E9%87%8D%E5%90%AFcontainer%EF%BC%88start-stop-restart%EF%BC%89"><span class="nav-number">1.13.</span> <span class="nav-text">1. 开启&#x2F;停止&#x2F;重启container（start&#x2F;stop&#x2F;restart）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84container%EF%BC%88attach%EF%BC%89"><span class="nav-number">1.14.</span> <span class="nav-text">2. 连接到正在运行中的container（attach）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9F%A5%E7%9C%8Bimage%E6%88%96container%E7%9A%84%E5%BA%95%E5%B1%82%E4%BF%A1%E6%81%AF%EF%BC%88inspect%EF%BC%89"><span class="nav-number">1.15.</span> <span class="nav-text">3. 查看image或container的底层信息（inspect）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAcontainer%E3%80%81image%EF%BC%88rm%E3%80%81rmi%EF%BC%89"><span class="nav-number">1.16.</span> <span class="nav-text">4. 删除一个或多个container、image（rm、rmi）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-docker-build-%E4%BD%BF%E7%94%A8%E6%AD%A4%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84image"><span class="nav-number">1.17.</span> <span class="nav-text">5. docker build 使用此配置生成新的image</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BB%99%E9%95%9C%E5%83%8F%E6%89%93%E4%B8%8A%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89"><span class="nav-number">1.18.</span> <span class="nav-text">6. 给镜像打上标签（tag）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BF%A1%E6%81%AFcontainer%EF%BC%88ps%EF%BC%89"><span class="nav-number">1.19.</span> <span class="nav-text">7. 查看容器的信息container（ps）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%88top%EF%BC%89"><span class="nav-number">1.20.</span> <span class="nav-text">8. 查看容器中正在运行的进程（top）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="nav-number">1.21.</span> <span class="nav-text">9. 其他命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#events%E3%80%81history%E5%92%8Clogs%E5%91%BD%E4%BB%A4"><span class="nav-number">1.22.</span> <span class="nav-text">events、history和logs命令</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xuesongtan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuesongtan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
