<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Docker 教程讲解 | Augustxuesong</title>
  <meta name="author" content="xuesongtan">
  
  <meta name="description" content="一、Docker简介Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。
Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。基于容器技术的轻量级虚拟化解决方案。
">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Docker 教程讲解"/>
  <meta property="og:site_name" content="Augustxuesong"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 5.2.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Augustxuesong</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Docker 教程讲解</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h2><p>Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。基于容器技术的轻量级虚拟化解决方案。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低</p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p>
<p>Docker是什么，一句话总结？</p>
<p><strong>有助于持续集成和部署的 容器虚拟化技术，运行环境和配置的标准化解决方案</strong>。</p>
<p>Docker解决了什么问题？</p>
<p>​     一款产品从开发到上线，从操作系统，到环境运行，在到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司不得不面对的问题，特别是各版本的迭代之后，不同版本环境的兼容，对运维人员都是考验。</p>
<p>​     Docker对此给出了一个标准化的解决方案。</p>
<p>​     环境配置如此麻烦，换一台机器，就要重来一次，费力费时。那么软件可以不可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用Docker可以消除协作编码时“在我的机器上可以正常工作”的问题</p>
<h3 id="二、Docker-的优点"><a href="#二、Docker-的优点" class="headerlink" title="二、Docker 的优点"></a>二、Docker 的优点</h3><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
<h4 id="1、快速，一致地交付您的应用程序"><a href="#1、快速，一致地交付您的应用程序" class="headerlink" title="1、快速，一致地交付您的应用程序"></a>1、快速，一致地交付您的应用程序</h4><h4 id="2、响应式部署和扩展"><a href="#2、响应式部署和扩展" class="headerlink" title="2、响应式部署和扩展"></a>2、响应式部署和扩展</h4><h4 id="3、在同一硬件上运行更多工作负载"><a href="#3、在同一硬件上运行更多工作负载" class="headerlink" title="3、在同一硬件上运行更多工作负载"></a>3、在同一硬件上运行更多工作负载</h4><p>秒级启动，秒级停止，空间资源占用极少 *M，实现进程级别的隔离，可以再普通服务器上建立上百个docker实例</p>
<p>加快开发测试部署的速度，简化版本管理</p>
<h3 id="三、Docker-架构组成"><a href="#三、Docker-架构组成" class="headerlink" title="三、Docker 架构组成"></a>三、Docker 架构组成</h3><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p>
<p>Docker 包括三个基本概念:</p>
<ul>
<li>镜像（image）：Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器。</li>
<li>容器（container）：Docker 利用容器 独立运行一个或一组应用。容器是用镜像创建的运行实例。</li>
<li>仓库（Repository）：仓库是集中存放镜像文件的场所。仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/)%EF%BC%8C%E5%9B%BD%E5%86%85%E7%9A%84%E5%85%AC%E5%BC%80%E4%BB%93%E5%BA%93%E5%8C%85%E6%8B%AC%E9%98%BF%E9%87%8C%E4%BA%91">https://hub.docker.com/)，国内的公开仓库包括阿里云</a> 、网易云 等</li>
</ul>
<p>Docker架构图解：</p>
<p><img src="D:\hexo\myblog\source_posts\images\1348730-20190907174043356-642187228.png" alt="1348730-20190907174043356-642187228"></p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。容器和镜像最大的区别为：镜像是静态的只读文件，而容器带有运行时需要的可写文件层，同时，容器中的应用进程处于运行状态</p>
<p>个人理解：</p>
<p>仓库是“应用市场或者是存放下载安装包的地方”</p>
<p>镜像是“应用市场里的QQ安装包”</p>
<p>容器则是“安装后的的QQ所运行的载体”</p>
<h3 id="四、Docker安装"><a href="#四、Docker安装" class="headerlink" title="四、Docker安装"></a>四、Docker安装</h3><p>Docker 支持以下的 64 位 CentOS 版本：</p>
<ul>
<li>CentOS 7</li>
<li>CentOS 8</li>
<li>更高版本..</li>
</ul>
<h4 id="使用官方安装脚本自动安装"><a href="#使用官方安装脚本自动安装" class="headerlink" title="使用官方安装脚本自动安装"></a>使用官方安装脚本自动安装</h4><p>安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>也可以使用国内 daocloud 一键安装命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh</span><br></pre></td></tr></table></figure>



<p>卸载旧版本</p>
<p>$ <strong>sudo</strong> <strong>yum remove</strong> docker <br>         docker-client <br>         docker-client-latest <br>         docker-common <br>         docker-latest <br>         docker-latest-logrotate <br>         docker-logrotate <br>         docker-engine</p>
<p>列出docker安装过的相关包：<br>   sudo yum list installed | grep docker<br>删除相关安装包sudo yum -y remove docker-ce.x86_64<br>sudo yum -y remove docker-ce-selinux.noarch</p>
<p>sudo yum remove docker  docker-common docker-selinux docker-engine</p>
<h3 id="五、Docker-容器运行"><a href="#五、Docker-容器运行" class="headerlink" title="五、Docker 容器运行"></a>五、Docker 容器运行</h3><p>在运行一个容器前需要本地有对应的镜像，如果镜像不存在，Docker会尝试从默认镜像仓库下载（默认使用Docker Hub公共注册服务器中的仓库），当然用户也可以通过配置，使用自定义的镜像仓库。</p>
<h4 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h4><p>我们可以使用 <strong>docker images</strong> 来列出本地主机上的镜像。</p>
<p>REPOSITORY                                  TAG                 IMAGE ID            CREATED             SIZE<br>registry.ihdou.com/4.0/v4manage             latest              6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/4.0/v4manage                 latest              6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/4.0/v4manage                 v1                  6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/v4manage                     latest              6f4c3cf49540        30 hours ago        156MB</p>
<p>各个选项说明:</p>
<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 v4manage             仓库源里，有 v1、latest               等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p>使用镜像来运行容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i 192.168.102.78&#x2F;4.0&#x2F;v4manage:v1 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p><strong>-i</strong>: 交互式操作。</p>
</li>
<li><p><strong>-t</strong>: 终端。</p>
</li>
<li><p><strong>ubuntu:15.10</strong>: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</p>
</li>
<li><p><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</p>
<p><img src="C:\Users\XUEST\AppData\Roaming\Typora\typora-user-images\image-20201221162433508.png" alt="image-20201221162433508"></p>
</li>
</ul>
<h4 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h4><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure>

<p>OPTIONS说明：</p>
<p>-a :拉取所有 tagged 镜像</p>
<p>–disable-content-trust :忽略镜像的校验,默认开启</p>
<p>NAME是镜像仓库名称（用来区分镜像）, TAG是镜像的标签（往往用来表示版本信息）。通常情况下，描述一个镜像需要包括“名称+标签”信息。严格地讲，镜像的仓库名称中还应该添加仓库地址（即registry，注册服务器）作为前缀，只是默认使用的是官方Docker Hub服务，所以该前缀可以忽略。如果从非官方的仓库下载，则要在仓库名称前指定完整的仓库地址</p>
<p>实例</p>
<p>docker pull 192.168.102.78/4.0/v4manage</p>
<h4 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h4><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search v4</span><br></pre></td></tr></table></figure>

<p><strong>NAME:</strong> 镜像仓库源的名称</p>
<p><strong>DESCRIPTION:</strong> 镜像的描述</p>
<p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p>
<p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
<p><strong>AUTOMATED:</strong> 自动构建</p>
<p>我们决定使用上图中的 httpd 官方版本的镜像，使用命令 docker pull 来下载镜像。</p>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>镜像删除使用 <strong>docker rmi</strong> 命令，存在基于当前镜像正在运行的或者stop的容器时，需先停用删除容器，再删除镜像</p>
<p>[root@k8s-master harbor]# docker rmi 6dd206182a84<br>Deleted: sha256:6dd206182a849cad478ba4c1de76bfe3e32625e3e49a56a2585c7000efeaf33f<br>Deleted: sha256:b4d4ea2b50ffda7360439fefde67d6bcc61f9fa1f8ce627261bc44ba5b1c3ab8<br>Deleted: sha256:f12cb102ecabd70a1381e2c5e3b5306d3b30e328d52f5c53c39540cc78e4626f<br>Deleted: sha256:64d6980d5059ddbd51a9dea09062d213dfedf89b25822a629f45d3f4aab4159b<br>Deleted: sha256:38f5bf067c29598625aee277b503b95af493e2d61866012cc90a221b9db2fe67<br>Deleted: sha256:5fc71dd3e480565be4631ad5ca7da3e86ec35becafa8333837e630268971d236<br>Deleted: sha256:f552c10bfa44c286856f36a7d00723448f4e8fd392fab6ac3969840daaabd03e<br>[root@k8s-master harbor]# </p>
<h4 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h4><p>更新镜像之前，我们需要使用镜像来创建一个容器。在运行的容器内部使用 <strong>apt-get update</strong> 命令进行更新</p>
<p>[root@k8s-master harbor]# docker run -t -i 192.168.102.78/4.0/v4manage:v1 /bin/bash<br>root@d36a4bcbe790:/# apt-get update<br>Get:1 <a target="_blank" rel="noopener" href="http://security.debian.org/debian-security">http://security.debian.org/debian-security</a> buster/updates InRelease [65.4 kB]<br>Get:2 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster InRelease [121 kB]<br>Get:3 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster-updates InRelease [51.9 kB]<br>Get:4 <a target="_blank" rel="noopener" href="http://security.debian.org/debian-security">http://security.debian.org/debian-security</a> buster/updates/main amd64 Packages [253 kB]<br>Get:5 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster/main amd64 Packages [7906 kB]<br>Get:6 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster-updates/main amd64 Packages [7856 B]<br>Fetched 8406 kB in 8s (1052 kB/s)<br>Reading package lists… Done<br>root@d36a4bcbe790:/# </p>
<p>在完成操作之后，输入 exit 命令来退出这个容器。</p>
<p>此时 ID 为 d36a4bcbe790的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p>
<p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li>d36a4bcbe790：**容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li>
</ul>
<h4 id="新增镜像"><a href="#新增镜像" class="headerlink" title="新增镜像"></a>新增镜像</h4><p>我们使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This Nuxt.js Dockerfile</span></span><br><span class="line"><span class="comment"># FROM </span></span><br><span class="line">MAINTAINER Xuest</span><br><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM registry.ihdou.com/node:10.15.3-alpine</span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER Xuest </span><br><span class="line"><span class="comment">#ENV 设置环境变量</span></span><br><span class="line">ENV NODE_ENV=production</span><br><span class="line">ENV HOST 0.0.0.0</span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN mkdir -p /social-statics-app</span><br><span class="line"><span class="comment">#COPY </span></span><br><span class="line">COPY . /social-statics-app</span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /social-statics-app</span><br><span class="line"><span class="comment">#EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line">RUN npm install</span><br><span class="line">RUN npm rebuild node-sass</span><br><span class="line">RUN npm run build</span><br><span class="line">RUN npm cache clean --force</span><br><span class="line"><span class="comment">#CMD 运行以下命令</span></span><br><span class="line">CMD [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Docker-仓库管理"><a href="#Docker-仓库管理" class="headerlink" title="Docker 仓库管理"></a>Docker 仓库管理</h3><p>仓库（Repository）是集中存放镜像的地方。以下介绍一下 [Docker Hub]。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的</p>
<h4 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h4><p>目前 Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。</p>
<p>大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h4 id="登录和退出"><a href="#登录和退出" class="headerlink" title="登录和退出"></a>登录和退出</h4><p>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>

<h5 id="退出"><a href="#退出" class="headerlink" title="退出"></a><strong>退出</strong></h5><p>退出 docker hub 可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logout</span><br></pre></td></tr></table></figure>

<p>拉取镜像</p>
<p>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</p>
<p>以 ubuntu 为关键词进行搜索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search ubuntu</span><br></pre></td></tr></table></figure>

<p>使用 docker pull 将官方 ubuntu 镜像下载到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu </span><br></pre></td></tr></table></figure>

<h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 username 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username&#x2F;ubuntu:18.04</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG        IMAGE ID            CREATED           ...  </span><br><span class="line">ubuntu          18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">username&#x2F;ubuntu 18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">$ docker push username&#x2F;ubuntu:18.04</span><br><span class="line">$ docker search username&#x2F;ubuntu</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED</span><br><span class="line">username&#x2F;ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><h4 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h4><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>如果你还不了解 YML 文件配置，可以先阅读 <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程</a>。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<p>docker-compose.yml 的配置案例如下（配置参数参考下文）：</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2020/12/15/K8s搭建部署/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2020/11/03/Docker私有仓库搭建/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2020-12-01 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2021 xuesongtan
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
