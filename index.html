<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>Augustxuesong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Augustxuesong">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Augustxuesong">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="xuesongtan">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.2.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Augustxuesong" rel="home">Augustxuesong</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">首页</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">文章</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/shopping/">商城系统</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/about/">关于我</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-Docker教程讲解" class="post-Docker教程讲解 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/12/01/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">Docker 教程讲解</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/12/01/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/" data-id="ckv99zk5t00047ohxevh60k2g" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h2><p>Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。基于容器技术的轻量级虚拟化解决方案。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低</p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p>
<p>Docker是什么，一句话总结？</p>
<p><strong>有助于持续集成和部署的 容器虚拟化技术，运行环境和配置的标准化解决方案</strong>。</p>
<p>Docker解决了什么问题？</p>
<p>​     一款产品从开发到上线，从操作系统，到环境运行，在到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司不得不面对的问题，特别是各版本的迭代之后，不同版本环境的兼容，对运维人员都是考验。</p>
<p>​     Docker对此给出了一个标准化的解决方案。</p>
<p>​     环境配置如此麻烦，换一台机器，就要重来一次，费力费时。那么软件可以不可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用Docker可以消除协作编码时“在我的机器上可以正常工作”的问题</p>
<h3 id="二、Docker-的优点"><a href="#二、Docker-的优点" class="headerlink" title="二、Docker 的优点"></a>二、Docker 的优点</h3><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
<h4 id="1、快速，一致地交付您的应用程序"><a href="#1、快速，一致地交付您的应用程序" class="headerlink" title="1、快速，一致地交付您的应用程序"></a>1、快速，一致地交付您的应用程序</h4><h4 id="2、响应式部署和扩展"><a href="#2、响应式部署和扩展" class="headerlink" title="2、响应式部署和扩展"></a>2、响应式部署和扩展</h4><h4 id="3、在同一硬件上运行更多工作负载"><a href="#3、在同一硬件上运行更多工作负载" class="headerlink" title="3、在同一硬件上运行更多工作负载"></a>3、在同一硬件上运行更多工作负载</h4><p>秒级启动，秒级停止，空间资源占用极少 *M，实现进程级别的隔离，可以再普通服务器上建立上百个docker实例</p>
<p>加快开发测试部署的速度，简化版本管理</p>
<h3 id="三、Docker-架构组成"><a href="#三、Docker-架构组成" class="headerlink" title="三、Docker 架构组成"></a>三、Docker 架构组成</h3><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p>
<p>Docker 包括三个基本概念:</p>
<ul>
<li>镜像（image）：Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器。</li>
<li>容器（container）：Docker 利用容器 独立运行一个或一组应用。容器是用镜像创建的运行实例。</li>
<li>仓库（Repository）：仓库是集中存放镜像文件的场所。仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/)%EF%BC%8C%E5%9B%BD%E5%86%85%E7%9A%84%E5%85%AC%E5%BC%80%E4%BB%93%E5%BA%93%E5%8C%85%E6%8B%AC%E9%98%BF%E9%87%8C%E4%BA%91">https://hub.docker.com/)，国内的公开仓库包括阿里云</a> 、网易云 等</li>
</ul>
<p>Docker架构图解：</p>
<p><img src="D:\hexo\myblog\source_posts\images\1348730-20190907174043356-642187228.png" alt="1348730-20190907174043356-642187228"></p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。容器和镜像最大的区别为：镜像是静态的只读文件，而容器带有运行时需要的可写文件层，同时，容器中的应用进程处于运行状态</p>
<p>个人理解：</p>
<p>仓库是“应用市场或者是存放下载安装包的地方”</p>
<p>镜像是“应用市场里的QQ安装包”</p>
<p>容器则是“安装后的的QQ所运行的载体”</p>
<h3 id="四、Docker安装"><a href="#四、Docker安装" class="headerlink" title="四、Docker安装"></a>四、Docker安装</h3><p>Docker 支持以下的 64 位 CentOS 版本：</p>
<ul>
<li>CentOS 7</li>
<li>CentOS 8</li>
<li>更高版本..</li>
</ul>
<h4 id="使用官方安装脚本自动安装"><a href="#使用官方安装脚本自动安装" class="headerlink" title="使用官方安装脚本自动安装"></a>使用官方安装脚本自动安装</h4><p>安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>也可以使用国内 daocloud 一键安装命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh</span><br></pre></td></tr></table></figure>



<p>卸载旧版本</p>
<p>$ <strong>sudo</strong> <strong>yum remove</strong> docker <br>         docker-client <br>         docker-client-latest <br>         docker-common <br>         docker-latest <br>         docker-latest-logrotate <br>         docker-logrotate <br>         docker-engine</p>
<p>列出docker安装过的相关包：<br>   sudo yum list installed | grep docker<br>删除相关安装包sudo yum -y remove docker-ce.x86_64<br>sudo yum -y remove docker-ce-selinux.noarch</p>
<p>sudo yum remove docker  docker-common docker-selinux docker-engine</p>
<h3 id="五、Docker-容器运行"><a href="#五、Docker-容器运行" class="headerlink" title="五、Docker 容器运行"></a>五、Docker 容器运行</h3><p>在运行一个容器前需要本地有对应的镜像，如果镜像不存在，Docker会尝试从默认镜像仓库下载（默认使用Docker Hub公共注册服务器中的仓库），当然用户也可以通过配置，使用自定义的镜像仓库。</p>
<h4 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h4><p>我们可以使用 <strong>docker images</strong> 来列出本地主机上的镜像。</p>
<p>REPOSITORY                                  TAG                 IMAGE ID            CREATED             SIZE<br>registry.ihdou.com/4.0/v4manage             latest              6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/4.0/v4manage                 latest              6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/4.0/v4manage                 v1                  6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/v4manage                     latest              6f4c3cf49540        30 hours ago        156MB</p>
<p>各个选项说明:</p>
<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 v4manage             仓库源里，有 v1、latest               等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p>使用镜像来运行容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i 192.168.102.78&#x2F;4.0&#x2F;v4manage:v1 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p><strong>-i</strong>: 交互式操作。</p>
</li>
<li><p><strong>-t</strong>: 终端。</p>
</li>
<li><p><strong>ubuntu:15.10</strong>: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</p>
</li>
<li><p><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</p>
<p><img src="C:\Users\XUEST\AppData\Roaming\Typora\typora-user-images\image-20201221162433508.png" alt="image-20201221162433508"></p>
</li>
</ul>
<h4 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h4><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure>

<p>OPTIONS说明：</p>
<p>-a :拉取所有 tagged 镜像</p>
<p>–disable-content-trust :忽略镜像的校验,默认开启</p>
<p>NAME是镜像仓库名称（用来区分镜像）, TAG是镜像的标签（往往用来表示版本信息）。通常情况下，描述一个镜像需要包括“名称+标签”信息。严格地讲，镜像的仓库名称中还应该添加仓库地址（即registry，注册服务器）作为前缀，只是默认使用的是官方Docker Hub服务，所以该前缀可以忽略。如果从非官方的仓库下载，则要在仓库名称前指定完整的仓库地址</p>
<p>实例</p>
<p>docker pull 192.168.102.78/4.0/v4manage</p>
<h4 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h4><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search v4</span><br></pre></td></tr></table></figure>

<p><strong>NAME:</strong> 镜像仓库源的名称</p>
<p><strong>DESCRIPTION:</strong> 镜像的描述</p>
<p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p>
<p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
<p><strong>AUTOMATED:</strong> 自动构建</p>
<p>我们决定使用上图中的 httpd 官方版本的镜像，使用命令 docker pull 来下载镜像。</p>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>镜像删除使用 <strong>docker rmi</strong> 命令，存在基于当前镜像正在运行的或者stop的容器时，需先停用删除容器，再删除镜像</p>
<p>[root@k8s-master harbor]# docker rmi 6dd206182a84<br>Deleted: sha256:6dd206182a849cad478ba4c1de76bfe3e32625e3e49a56a2585c7000efeaf33f<br>Deleted: sha256:b4d4ea2b50ffda7360439fefde67d6bcc61f9fa1f8ce627261bc44ba5b1c3ab8<br>Deleted: sha256:f12cb102ecabd70a1381e2c5e3b5306d3b30e328d52f5c53c39540cc78e4626f<br>Deleted: sha256:64d6980d5059ddbd51a9dea09062d213dfedf89b25822a629f45d3f4aab4159b<br>Deleted: sha256:38f5bf067c29598625aee277b503b95af493e2d61866012cc90a221b9db2fe67<br>Deleted: sha256:5fc71dd3e480565be4631ad5ca7da3e86ec35becafa8333837e630268971d236<br>Deleted: sha256:f552c10bfa44c286856f36a7d00723448f4e8fd392fab6ac3969840daaabd03e<br>[root@k8s-master harbor]# </p>
<h4 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h4><p>更新镜像之前，我们需要使用镜像来创建一个容器。在运行的容器内部使用 <strong>apt-get update</strong> 命令进行更新</p>
<p>[root@k8s-master harbor]# docker run -t -i 192.168.102.78/4.0/v4manage:v1 /bin/bash<br>root@d36a4bcbe790:/# apt-get update<br>Get:1 <a target="_blank" rel="noopener" href="http://security.debian.org/debian-security">http://security.debian.org/debian-security</a> buster/updates InRelease [65.4 kB]<br>Get:2 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster InRelease [121 kB]<br>Get:3 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster-updates InRelease [51.9 kB]<br>Get:4 <a target="_blank" rel="noopener" href="http://security.debian.org/debian-security">http://security.debian.org/debian-security</a> buster/updates/main amd64 Packages [253 kB]<br>Get:5 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster/main amd64 Packages [7906 kB]<br>Get:6 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster-updates/main amd64 Packages [7856 B]<br>Fetched 8406 kB in 8s (1052 kB/s)<br>Reading package lists… Done<br>root@d36a4bcbe790:/# </p>
<p>在完成操作之后，输入 exit 命令来退出这个容器。</p>
<p>此时 ID 为 d36a4bcbe790的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p>
<p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li>d36a4bcbe790：**容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li>
</ul>
<h4 id="新增镜像"><a href="#新增镜像" class="headerlink" title="新增镜像"></a>新增镜像</h4><p>我们使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This Nuxt.js Dockerfile</span></span><br><span class="line"><span class="comment"># FROM </span></span><br><span class="line">MAINTAINER Xuest</span><br><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM registry.ihdou.com/node:10.15.3-alpine</span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER Xuest </span><br><span class="line"><span class="comment">#ENV 设置环境变量</span></span><br><span class="line">ENV NODE_ENV=production</span><br><span class="line">ENV HOST 0.0.0.0</span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN mkdir -p /social-statics-app</span><br><span class="line"><span class="comment">#COPY </span></span><br><span class="line">COPY . /social-statics-app</span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /social-statics-app</span><br><span class="line"><span class="comment">#EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line">RUN npm install</span><br><span class="line">RUN npm rebuild node-sass</span><br><span class="line">RUN npm run build</span><br><span class="line">RUN npm cache clean --force</span><br><span class="line"><span class="comment">#CMD 运行以下命令</span></span><br><span class="line">CMD [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Docker-仓库管理"><a href="#Docker-仓库管理" class="headerlink" title="Docker 仓库管理"></a>Docker 仓库管理</h3><p>仓库（Repository）是集中存放镜像的地方。以下介绍一下 [Docker Hub]。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的</p>
<h4 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h4><p>目前 Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。</p>
<p>大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h4 id="登录和退出"><a href="#登录和退出" class="headerlink" title="登录和退出"></a>登录和退出</h4><p>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>

<h5 id="退出"><a href="#退出" class="headerlink" title="退出"></a><strong>退出</strong></h5><p>退出 docker hub 可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logout</span><br></pre></td></tr></table></figure>

<p>拉取镜像</p>
<p>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</p>
<p>以 ubuntu 为关键词进行搜索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search ubuntu</span><br></pre></td></tr></table></figure>

<p>使用 docker pull 将官方 ubuntu 镜像下载到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu </span><br></pre></td></tr></table></figure>

<h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 username 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username&#x2F;ubuntu:18.04</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG        IMAGE ID            CREATED           ...  </span><br><span class="line">ubuntu          18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">username&#x2F;ubuntu 18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">$ docker push username&#x2F;ubuntu:18.04</span><br><span class="line">$ docker search username&#x2F;ubuntu</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED</span><br><span class="line">username&#x2F;ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><h4 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h4><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>如果你还不了解 YML 文件配置，可以先阅读 <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程</a>。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<p>docker-compose.yml 的配置案例如下（配置参数参考下文）：</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/12/01/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">
    <time datetime="2020-12-01T06:13:43.992Z" class="entry-date">
        2020-12-01
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-Docker私有仓库搭建" class="post-Docker私有仓库搭建 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">Docker 搭建私有仓库</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/" data-id="ckv99zk5u00057ohxdtsa78qa" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="Harbor私有仓库"><a href="#Harbor私有仓库" class="headerlink" title="Harbor私有仓库"></a>Harbor私有仓库</h2><p>以Harbor为列搭建私有仓库</p>
<h3 id="一、Harbor概述"><a href="#一、Harbor概述" class="headerlink" title="一、Harbor概述"></a>一、Harbor概述</h3><p>Habor是由VMWare公司开源的容器镜像仓库。事实上，Habor是在Docker Registry上进行了相应的</p>
<p>企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访</p>
<p>问控制 ，AD/LDAP集成以及审计日志等，足以满足基本企业需求。</p>
<p>官方地址：<a target="_blank" rel="noopener" href="https://vmware.github.io/harbor/cn/">https://vmware.github.io/harbor/cn/</a></p>
<p>Github项目地址：<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p>
<p>安装包下载地址：<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a></p>
<ul>
<li><strong>Harbor相关组件</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>harbor-adminserver</td>
<td>配置管理中心</td>
</tr>
<tr>
<td>harbor-db</td>
<td>Mysql数据库</td>
</tr>
<tr>
<td>harbor-jobservice</td>
<td>负责镜像复制</td>
</tr>
<tr>
<td>harbor-log</td>
<td>记录操作日志</td>
</tr>
<tr>
<td>harbor-ui</td>
<td>Web管理页面和API</td>
</tr>
<tr>
<td>nginx</td>
<td>前端代理，负责前端页面和镜像上传/下载转发</td>
</tr>
<tr>
<td>redis</td>
<td>会话</td>
</tr>
<tr>
<td>registry</td>
<td>镜像存储</td>
</tr>
</tbody></table>
<h3 id="二、Harbor安装"><a href="#二、Harbor安装" class="headerlink" title="二、Harbor安装"></a>二、Harbor安装</h3><p>1、先安装docker-compose</p>
<p>curl -L <a target="_blank" rel="noopener" href="https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-%60uname">https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname</a> -s<code>-</code>uname -m` &gt; /usr/local/bin/docker-compose </p>
<p>给docker-compose添加执行权限</p>
<p>chmod +x /usr/local/bin/docker-compose</p>
<p>查看docker-compose是否安装成功</p>
<p>docker-compose -version</p>
<p>docker-compose version 1.27.3, build 4092ae5d</p>
<p>2、下载Harbor的压缩包v2.1.1</p>
<p>wget <a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases/download/v2.1.1/harbor-offline-installer-v2.1.1.tgz">https://github.com/goharbor/harbor/releases/download/v2.1.1/harbor-offline-installer-v2.1.1.tgz</a></p>
<p>上传压缩包到linux，并解压</p>
<p>tar zxvf harbor-offline-installer-v2.1.1.tgz</p>
<p>修改配置:</p>
<p>cp harbor.yml.tmpl  harbor.yml</p>
<p>vim harbor.yml</p>
<p>修改hostname: 192.168.102.78   密码hd123456</p>
<p>注释掉https默认（如有https另说）</p>
<p>3、安装Harbor</p>
<p>./prepare </p>
<p>./install.sh</p>
<p>4、启动、停止Harbor</p>
<p>docker-compose up -d 启动 </p>
<p>docker-compose stop 停止 </p>
<p>docker-compose restart 重新启动</p>
<p>5、访问Harbor</p>
<p><a target="_blank" rel="noopener" href="http://192.168.102.78/">http://192.168.102.78</a></p>
<p>默认账户密码：admin/hd12345</p>
<p>6、配置http镜像仓库可信任</p>
<p>vim /etc/docker/daemon.json    </p>
<h3 id="编辑配置文件-添加一行信任授权内容："><a href="#编辑配置文件-添加一行信任授权内容：" class="headerlink" title="编辑配置文件 添加一行信任授权内容："></a>编辑配置文件 添加一行信任授权内容：</h3><p> {  </p>
<p>​       “insecure-registries”: [“192.168.102.78”]   </p>
<p> } </p>
<p>添加完成后重启docker服务： systemctl restart docker</p>
<p><img src="C:\Users\XUEST\AppData\Roaming\Typora\typora-user-images\image-20201201105746658.png" alt="image-20201201105746658"></p>
<p>测试实例</p>
<p>docker login 192.168.102.78</p>
<p>admin</p>
<p>hd123456</p>
<p>docker push 192.168.102.78/4.0/v4manage</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">
    <time datetime="2020-11-03T05:59:50.000Z" class="entry-date">
        2020-11-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-Docker常用命令" class="post-Docker常用命令 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 命令大全</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="ckv99zk63000b7ohx6m0g9qii" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><p>docker是传统的CS架构分为docker client和docker server</p>
<p>docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。</p>
<h3 id="docker的镜像管理"><a href="#docker的镜像管理" class="headerlink" title="docker的镜像管理"></a><strong>docker的镜像管理</strong></h3><p>#查看镜像列表: </p>
<p>docker images </p>
<p>docker image ls </p>
<p>#导出镜像: </p>
<p>docker image save centos &gt; docker-centos6.9.tar.gz </p>
<p>#导入镜像: </p>
<p>docker image load -i docker-centos6.9.tar.gz </p>
<p>#删除镜像: </p>
<p>docker image rm centos:latest </p>
<p>docker image rm 578c3 </p>
<p>#搜索镜像     </p>
<p>docker search + 镜像名字 </p>
<p>#给源中镜像打标签: </p>
<p>docker tag nginx:latest 10.0.0.11:80/nginx:latest </p>
<p>#推送指定镜像到docker镜像源服务器 </p>
<p>docker push 10.0.0.11:80/nginx:latest </p>
<p>#获取镜像    </p>
<p>docker pull image_name </p>
<p>#官方pull    </p>
<p>docker pull centos:6.8（没有指定版本，默认会下载最新版） </p>
<p>#私有仓库pull    </p>
<p>docker pull daocloud.io/huangzhichong/alpine-cn:latest </p>
<p>#显示一个镜像的历史</p>
<p>docker history image_name    </p>
<p>#使用当前目录下的Dockerfile构建镜像</p>
<p>docker build -t <image-name> .   </p>
<h3 id="docker的容器管理"><a href="#docker的容器管理" class="headerlink" title="docker的容器管理"></a><strong>docker的容器管理</strong></h3><p>#查看版本</p>
<p>docker -v     </p>
<p>#查看docker信息    </p>
<p>docker info     </p>
<p>#运行容器 </p>
<p>docker run –name 容器名 -d -p 3306:3306 mysql  </p>
<p>#docker 启动容器 </p>
<p>docker run image_name </p>
<p>docker run -d -p 80:80 nginx:latest </p>
<p>（run 创建并运行一个容器 -d 放在后台  -p 端口映射 :docker的容器端口 -P 随机分配端口 </p>
<p>​    -v 源地址(宿主机):目标地址(容器) )</p>
<p>#启动容器</p>
<p>docker run image_name   </p>
<p>#停止容器 </p>
<p>docker stop container_id  </p>
<p>#杀死容器</p>
<p>docker kill container_name   </p>
<p>#查看容器列表</p>
<p>docker ps (-a -l -q)    </p>
<p>#停用并删除容器</p>
<p>docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</p>
<p>#停止多有容器</p>
<p>docker stop $(docker ps -q)</p>
<p>#删除所有容器</p>
<p>docker rm $(docker ps -aq)</p>
<p>#查看容器列表 </p>
<p>docker ps -a  </p>
<p>#进容器</p>
<p>docker exec -it 77cd6bef4dc9 /bin/bash   </p>
<p>#开启/停止 指定容器id或者容器名称的容器 </p>
<p>docker start/stop container-id||container-name </p>
<p>#启动容器 -v</p>
<p>docker run -d -p 80:80 -v /opt/xuest:/usr/share/nginx/html nginx:latest </p>
<p>#查看容器日志</p>
<p>docker logs container-name/container-id     </p>
<p>#查看容器状态 </p>
<p>docker ps | grep ${CONTAINER_ID}    </p>
<p>镜像打包 (保存对容器的修改) </p>
<p>docker commit ID new_image_name     </p>
<p>提交的描述信息” -a=”作者” 容器id  要创建的目标镜像名:[标签名] </p>
<p>docker commit -m=””</p>
<p>#查看容器内部详情细节 </p>
<p>docker inspect &lt;id/container_name&gt;   </p>
<p>#登录</p>
<p>docker login </p>
<p>#退出而不关闭容器 Ctrl+P+Q     </p>
<p>docker run -it –rm –name centos6 centos:6.9 /bin/bash  </p>
<p>-it 分配交互式的终端  </p>
<p>–name 指定容器的名字  </p>
<p>/bin/sh覆盖容器的初始命令 </p>
<p>启动命名：docker run -d -p 80:80  -v   waibulj:内部路径  –name</p>
<h3 id="docker命令集"><a href="#docker命令集" class="headerlink" title="docker命令集"></a>docker命令集</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>容器生命周期管理</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#run">run</a></td>
<td>创建一个新容器并运行</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#start">start</a></td>
<td>开启一个容器并使其在后台运行</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#stop">stop</a></td>
<td>停止一个容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#restart">restart</a></td>
<td>重启一个容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#kill">kill</a></td>
<td>杀掉一个容器进程</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#rm">rm</a></td>
<td>删除容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#pause">pause</a></td>
<td>暂停容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#unpause">unpause</a></td>
<td>恢复暂停容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#create">create</a></td>
<td>从镜像中创建一个容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#exec">exec</a></td>
<td>对一个容器执行shell命令</td>
</tr>
<tr>
<td><code>容器操作</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#ps">ps</a></td>
<td>列出容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#inspect">inspect</a></td>
<td>获取容器或镜像的元数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#top">top</a></td>
<td>查看正在运行中的容器进程信息</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#attach">attach</a></td>
<td>链接正在运行的容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#events">events</a></td>
<td>从docker服务器获取事件</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#logs">logs</a></td>
<td>获取docker日志</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#wait">wait</a></td>
<td>让一个容器进入等待，使其进入阻塞状态</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#export">export</a></td>
<td>讲一个容器的文件系统打包至tar</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#port">port</a></td>
<td>列出一个容器的端口映射情况</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#container">container</a></td>
<td>管理已经运行的容器的</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#deploy">deploy</a></td>
<td>部署新的堆栈或更新已有堆栈的</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#update">update</a></td>
<td>更新容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#rename">rename</a></td>
<td>重命名容器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#volume">volume</a></td>
<td>卷管理</td>
</tr>
<tr>
<td><code>容器文件系统操作</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#commit">commit</a></td>
<td>提交一个容器的文件系统，使之生成一个新的镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#cp">cp</a></td>
<td>向一个正在运行的容器复制文件，或将容器中的文件复制出来</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#diff">diff</a></td>
<td>检查一个容器文件系统更改情况</td>
</tr>
<tr>
<td><code>镜像仓库操作</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#login">login</a></td>
<td>docker登入</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#logout">logout</a></td>
<td>docker登出</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#pull">pull</a></td>
<td>拉取镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#push">push</a></td>
<td>推送镜像至服务器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#search">search</a></td>
<td>在docker hub上查询镜像</td>
</tr>
<tr>
<td><code>镜像管理</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#images">images</a></td>
<td>列出镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#rmi">rmi</a></td>
<td>删除镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#tag">tag</a></td>
<td>修改本地某一镜像的标记，使其镜像属于某一仓库</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#build">build</a></td>
<td>通过指定Dockerfile文件编译镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#history">history</a></td>
<td>查看镜像历史</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#save">save</a></td>
<td>将制定镜像保存成tar文件</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#load">load</a></td>
<td>从tar中恢复镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#import">import</a></td>
<td>从tar中创建一个新镜像</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#checkpoint">checkpoint</a></td>
<td>设置checkpoint，类似于恢复点，可以让镜像撤销到曾经设置的某一个checkpoint上</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#image">image</a></td>
<td>docker镜像管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#manifest">manifest</a></td>
<td>docker镜像清单管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#trust">trust</a></td>
<td>docker可信镜像管理</td>
</tr>
<tr>
<td><code>集群管理</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#swarm">swarm</a></td>
<td>docker集群管理工具</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#node">node</a></td>
<td>docker集群节点控制</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#stack">stack</a></td>
<td>docker集群堆栈管理</td>
</tr>
<tr>
<td><code>其他命令</code></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#info">info</a></td>
<td>查询docker信息</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#version">version</a></td>
<td>查询docker版本</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#system">system</a></td>
<td>docker系统管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#stats">stats</a></td>
<td>docker容器资源使用统计</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#config">config</a></td>
<td>管理docker配置</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#network">network</a></td>
<td>docker网络管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#plugin">plugin</a></td>
<td>docker插件管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#secret">secret</a></td>
<td>docker敏感信息管理</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/talkxin/article/details/83061973#service">service</a></td>
<td>docker服务管理</td>
</tr>
</tbody></table>
<h3 id="run命令"><a href="#run命令" class="headerlink" title="run命令"></a>run命令</h3><blockquote>
<p>docker run命令是创建一个新容器并运行，若本地不存在该容器镜像会直接去镜像仓库中查找并自动下载。</p>
</blockquote>
<p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>命令参数说明：</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>默认</th>
<th>说明</th>
<th>特殊示例</th>
</tr>
</thead>
<tbody><tr>
<td>–add-host</td>
<td></td>
<td>为容器添加一个host to ip的映射关系，可以添加若干个，且容器重启后不会消失。若直接修改容器中的/etc/hosts文件，容器重启后会消失</td>
<td>docker run –add-host localhost:127.0.0.1 ubuntu:latest</td>
</tr>
<tr>
<td>–attach(-a)</td>
<td></td>
<td>将容器的stdin,stdout,stderr【标准输入，标准输出，错误输出】关联到本地shell中，在执行docker run时，将所有输入输出指定到本地shell中，若执行时携带此参数，可以指定将stdin,stdout,stderr的某一个或某几个关联到本地shell</td>
<td></td>
</tr>
<tr>
<td>–blkio-weight</td>
<td>0</td>
<td>限制容器读写权重，当宿主机有1个以上容器时，可以设置容器的读写优先权，权重值在10～1000之间，0为关闭权重（该参数默认为0）</td>
<td></td>
</tr>
<tr>
<td>–blkio-weight-device</td>
<td>0</td>
<td>设置针对指定设备的权重，权重值在10～1000之间，且优先级高于blkio.weight</td>
<td>docker run –blkio-weight-device “/dev/sda:100” ubuntu:latest</td>
</tr>
<tr>
<td>–cap-add</td>
<td></td>
<td>增强linux能力，在docker容器内限制了大部分的linux能力，在之前，需要开启这些功能需要结合<code>--privileged</code>开启特权模式才能使用这些参数，考虑到安全性，可以通过该参数来开启指定的linux功能【默认开启的功能及全部定义详见<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/2c632d1a2de0192c3f18a2542ccb6f30a8719b1f/libcontainer/SPEC.md#security">docker runc</a>】，若参数为all则默认开启所有linux能力</td>
<td></td>
</tr>
<tr>
<td>–cap-drop</td>
<td></td>
<td>移除linux能力</td>
<td></td>
</tr>
<tr>
<td>–cgroup-parent</td>
<td></td>
<td>配置容器的控制组，继承该控制组的资源限制模式。扩展阅读:<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html">linux cgroup</a></td>
<td></td>
</tr>
<tr>
<td>–cidfile</td>
<td></td>
<td>创建一个容器，并将该容器的pid输出到某一文件中，若该文件存在，则会返回一个错误</td>
<td>docker run –cidfile /tmp/docker_test.cid ubuntu echo “test”</td>
</tr>
<tr>
<td>–cpu-count</td>
<td>0</td>
<td>设置容器cpu数量<code>仅限Windows版本</code></td>
<td></td>
</tr>
<tr>
<td>–cpu-percent</td>
<td>0</td>
<td>设置容器CPU使用百分比<code>仅限Windows版本</code></td>
<td></td>
</tr>
<tr>
<td>–cpu-period</td>
<td>0</td>
<td>与参数–cpu-quota配合使用，用于设定cpu从新分配资源的时间周期,时间周期结束后，会对cpu进行重新分配。</td>
<td></td>
</tr>
<tr>
<td>–cpu-quota</td>
<td>0</td>
<td>与参数–cpu-period配合使用，用于设定该容器在资源分配周期内占用cpu的时间，若容器设定–cpu-quota=1000000 –cpu-period=500000，则该容器在这个时间周期内权重为50%，这两个参数主要是提升宿主机内某一容器的权重比，可以用来解决宿主机内若干容器的资源抢占导致重要容器cpu性能不足的场景。该模式应用于Linux 的CFS模式，扩展阅读：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cfs/">完全公平调度程序(CFS)</a></td>
<td></td>
</tr>
<tr>
<td>–cpu-rt-period</td>
<td>0</td>
<td>–cpu-period的微秒版</td>
<td></td>
</tr>
<tr>
<td>–cpu-rt-runtime</td>
<td>0</td>
<td>在一个cpu资源分配周期内，优先保证某容器的cpu使用的最大微秒数。例如，默认周期为 1000000 微秒（1秒），设置 –cpu-rt-runtime=950000 可确保使用实时调度程序的容器每 1000000 微秒可运行 950000 微秒，并保留至少 50000 微秒用于非实时任务。</td>
<td></td>
</tr>
<tr>
<td>–cpu-shares(-c)</td>
<td>0</td>
<td>设置容器CPU权重，可以用于调整容器在单位分配周期内的资源优先使用比</td>
<td></td>
</tr>
<tr>
<td>–cpus</td>
<td></td>
<td>设置容器使用cpu的数量，该参数为1.3新增参数用于快速设置容器对于cpu的占用，例如示例，可以直接设置该容器使用多少cpu</td>
<td>docker run –cpus=”.5” ubuntu:latest</td>
</tr>
<tr>
<td>–cpuset-cpus</td>
<td></td>
<td>设置容器允许在哪个cpu上执行该进程，譬如–cpuset-cpus=”1,3”为指定在cpu 1 和cpu 3上执行，–cpuset-cpus=”0-2”为指定在cpu0,cpu1,cpu2上执行</td>
<td>docker run –cpuset-cpus=”1,3” ubuntu:latest docker run –cpuset-cpus=”0-2” ubuntu:latest</td>
</tr>
<tr>
<td>–cpuset-mems</td>
<td></td>
<td>同参数<code>--cpuset-cpus</code>，但该参数是作用于NUMA 架构的 CPU</td>
<td>docker run –cpuset-mems=”1,3” ubuntu:latest docker run –cpuset-mems=”0-2” ubuntu:latest</td>
</tr>
<tr>
<td>–detach(-d)</td>
<td>false</td>
<td>指定该容器运行于前台还是后台</td>
<td></td>
</tr>
<tr>
<td>–detach-keys</td>
<td></td>
<td>设置容器的键盘映射键位，在容器被链接到前台时，若宿主机的键盘键位与容器键位冲突，可以使用该指令对容器的键位进行重新映射</td>
<td></td>
</tr>
<tr>
<td>–device</td>
<td></td>
<td>将宿主机的设备映射至容器</td>
<td></td>
</tr>
<tr>
<td>–device-cgroup-rule</td>
<td></td>
<td>将宿主机的设备添加到cgroup规则列表中</td>
<td></td>
</tr>
<tr>
<td>–device-read-bps</td>
<td></td>
<td>以字节数/每秒的形式限制设备的读取速率</td>
<td>docker run –device-read-bps /dev/sda:100KB ubuntu:latest</td>
</tr>
<tr>
<td>–device-read-iops</td>
<td></td>
<td>以每秒所执行IO操作的次数的形式限制设备的读取速率</td>
<td>docker run –device-read-iops /dev/sda:10 ubuntu:latest</td>
</tr>
<tr>
<td>–device-write-bps</td>
<td></td>
<td>以字节数/每秒的形式限制设备的写入速率</td>
<td></td>
</tr>
<tr>
<td>–device-write-iops</td>
<td></td>
<td>以每秒所执行IO操作的次数的形式限制设备的写入速率</td>
<td></td>
</tr>
<tr>
<td>–disable-content-trust</td>
<td>true</td>
<td>忽略镜像的校验</td>
<td></td>
</tr>
<tr>
<td>–dns</td>
<td></td>
<td>指定容器使用的DNS服务器，默认和宿主一致</td>
<td></td>
</tr>
<tr>
<td>–dns-opt</td>
<td></td>
<td>设置DNS选项，同修改/etc/resolv.conf文件</td>
<td></td>
</tr>
<tr>
<td>–dns-option</td>
<td></td>
<td>设置DNS选项，同修改/etc/resolv.conf文件</td>
<td></td>
</tr>
<tr>
<td>–dns-search</td>
<td></td>
<td>指定容器DNS搜索域名，默认和宿主一致</td>
<td></td>
</tr>
<tr>
<td>–entrypoint</td>
<td></td>
<td>覆盖Dockerfile中设置的entrypoint命令</td>
<td></td>
</tr>
<tr>
<td>–env(-e)</td>
<td></td>
<td>设置/新增环境变量</td>
<td></td>
</tr>
<tr>
<td>–env-file</td>
<td></td>
<td>读取本地环境变量文件，并加载到容器中</td>
<td></td>
</tr>
<tr>
<td>–expose</td>
<td></td>
<td>开放一个端口或一组端口</td>
<td></td>
</tr>
<tr>
<td>–group-add</td>
<td></td>
<td>为容器添加用户组</td>
<td></td>
</tr>
<tr>
<td>–health-cmd</td>
<td></td>
<td>执行一个健康检查命令</td>
<td></td>
</tr>
<tr>
<td>–health-interval</td>
<td>0</td>
<td>配合<code>--health-cmd</code>参数，设置健康检查的执行的间隔时间（ms | s | m | h）</td>
<td></td>
</tr>
<tr>
<td>–health-retries</td>
<td>0</td>
<td>配合<code>--health-cmd</code>参数，设置健康检查命令失败重试的次数</td>
<td></td>
</tr>
<tr>
<td>–health-start-period</td>
<td>0</td>
<td>配合<code>--health-cmd</code>参数，设置健康检查的启动时间（ms | s | m | h）</td>
<td></td>
</tr>
<tr>
<td>–health-timeout</td>
<td>0</td>
<td>配合<code>--health-cmd</code>参数，设置健康检查命令超时时间（ms | s | m | h）</td>
<td></td>
</tr>
<tr>
<td>–help</td>
<td>false</td>
<td>帮助</td>
<td></td>
</tr>
<tr>
<td>–hostname(-h)</td>
<td></td>
<td>指定容器的hostname</td>
<td></td>
</tr>
<tr>
<td>–init</td>
<td>false</td>
<td>使用tini工具在容器中新增一个守护进程，来预防该容器出现僵尸进程的可能性</td>
<td></td>
</tr>
<tr>
<td>–interactive (-i)</td>
<td>false</td>
<td>以交互模式运行容器，并将容器的STDIN（标准输入）打开，通常与参数<code>--tty (-t)</code>配合使用</td>
<td></td>
</tr>
<tr>
<td>–io-maxbandwidth</td>
<td>0</td>
<td>限制容器IO最大速率<code>仅限Windows版本</code></td>
<td></td>
</tr>
<tr>
<td>–io-maxiops</td>
<td>0</td>
<td>以每秒所执行IO操作的次数的形式限制设备的读取速率<code>仅限Windows版本</code></td>
<td></td>
</tr>
<tr>
<td>–ip</td>
<td></td>
<td>设置容器的IPv4地址</td>
<td></td>
</tr>
<tr>
<td>–ip6</td>
<td></td>
<td>设置容器的IPv6地址</td>
<td></td>
</tr>
<tr>
<td>–ipc</td>
<td></td>
<td>启用ipc命名空间。在docker容器中进程交互采用了Linux常见的进程间交互方法(interprocess communication - IPC), 包括信号量、消息队列和共享内存等。容器的进程间交互实际上还是host上具有相同pid命名空间中的进程间交互，因此需要在IPC资源申请时加入命名空间信息，每个IPC资源有一个唯一的32位id。</td>
<td></td>
</tr>
<tr>
<td>–isolation</td>
<td></td>
<td>使用容器隔离。该参数拥有三个值 (1)default 即与使用dockerd –exec-opt的参数默认效果相同 (2)process 使用linux内核命名空间进行隔离，该参数不支持windows环境。 （3）使用微软的Hyper-V虚拟技术进行隔离，该参数仅限windows环境</td>
<td></td>
</tr>
<tr>
<td>–kernel-memory</td>
<td>0</td>
<td>限制该容器内核的内存使用</td>
<td></td>
</tr>
<tr>
<td>–label (-l)</td>
<td></td>
<td>设置该容器的元数据</td>
<td></td>
</tr>
<tr>
<td>–label-file</td>
<td></td>
<td>通过本地文件导入元数据至该容器</td>
<td></td>
</tr>
<tr>
<td>–link</td>
<td></td>
<td>指定容器间的关联，使用其他容器的IP、env等信息</td>
<td></td>
</tr>
<tr>
<td>–link-local-ip</td>
<td></td>
<td>设置本地链路地址（link-local address）ip</td>
<td></td>
</tr>
<tr>
<td>–log-driver</td>
<td></td>
<td>设置一个指定日志接受工具，用于动态收集日志。扩展阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/ZYQDuron/article/details/54614461?utm_source=blogxgwz0">日志处理与log-driver实现</a></td>
<td></td>
</tr>
<tr>
<td>–log-opt</td>
<td></td>
<td>配合参数<code>--log-driver</code>使用，用于设置日志输出参数</td>
<td></td>
</tr>
<tr>
<td>–mac-address</td>
<td></td>
<td>设置该容器mac地址</td>
<td></td>
</tr>
<tr>
<td>–memory -m</td>
<td>0</td>
<td>限制该容器内存使用</td>
<td></td>
</tr>
<tr>
<td>–memory-reservation</td>
<td>0</td>
<td>软限制该容器的内存使用，当宿主机内存空闲时，该容器的内存使用可以一定比例超出限制，但当宿主机内存紧张时，会强制该容器内存使用限制在该参数之内</td>
<td></td>
</tr>
<tr>
<td>–memory-swap</td>
<td>0</td>
<td>内存交换分区大小限制。配合参数<code>--memory</code>使用，且最小内存交换限制应该大于内存限制。该参数有4种情况： (1)不设置–memory与该参数:则该容器默认可以用完宿舍机的所有内存和 宿主机 swap 分区。 (2)设置–memory 50MB 不设置–memory-swap（默认为0）:则–memory-swap值等于限制内存大小，即该容器能够申请的最大内存为100MB。 (3)设置–memory 50MB –memory-swap为-1:则该容器最大可以申请的内存为50MB+宿主机swap分区大小 (4)设置–memory 50MB –memory-swap 100MB：则该容器可以申请的最大内存为100MB-50MB=50MB</td>
<td></td>
</tr>
<tr>
<td>–memory-swappiness</td>
<td>-1</td>
<td>用于调整虚拟内存的控制行为，为0～100之间的整数。在linux内存管理中，将内存中不活跃的页交换至硬盘中，以缓解内存紧张，该参数设置为0则认定该容器所有内存中的内容均不允许交换至硬盘，用以保障最大性能，若设置为100，则认为该容器所有内存中的数据均可以交换至硬盘。扩展阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/jasonchen_gbd/article/details/79462014">Linux内存管理</a></td>
<td></td>
</tr>
<tr>
<td>–mount</td>
<td></td>
<td>将文件系统挂载附加到容器</td>
<td></td>
</tr>
<tr>
<td>–name</td>
<td></td>
<td>设置该容器的名称</td>
<td></td>
</tr>
<tr>
<td>–net</td>
<td></td>
<td>将容器连接到网络，支持bridge/host/none/container四种类型</td>
<td></td>
</tr>
<tr>
<td>–net-alias</td>
<td></td>
<td>设置该容器在网络上的别名</td>
<td></td>
</tr>
<tr>
<td>–network</td>
<td></td>
<td>将容器连接到网络，支持bridge/host/none/container四种类型</td>
<td></td>
</tr>
<tr>
<td>–network-alias</td>
<td></td>
<td>设置该容器在网络上的别名</td>
<td></td>
</tr>
<tr>
<td>–no-healthcheck</td>
<td>false</td>
<td>禁止一切健康检查行为</td>
<td></td>
</tr>
<tr>
<td>–oom-kill-disable</td>
<td>false</td>
<td>设置是否禁止oom kill行为，若该容器因为需要大量请求内存，导致宿主机内存不足或触发到内存限制，导致杀死该容器进程，若设置该参数为true则会关闭这个检查</td>
<td></td>
</tr>
<tr>
<td>–oom-score-adj</td>
<td>0</td>
<td>调整主机的OOM首选项（从-1000到1000）此处需要注意的是，非专业人士docker官方是不建议用户修改<code>--oom-score-adj``--oom-kill-disable</code>这两个参数的</td>
<td></td>
</tr>
<tr>
<td>–pid</td>
<td></td>
<td>自定义设置该容器的pid</td>
<td></td>
</tr>
<tr>
<td>–pids-limit</td>
<td>0</td>
<td>该参数值为整数，为限制该容器所能创建的最大进程数。</td>
<td></td>
</tr>
<tr>
<td>–privileged</td>
<td>false</td>
<td>在该容器上开启特权模式，让该容器拥有所有的linux能力</td>
<td></td>
</tr>
<tr>
<td>–publish -p</td>
<td></td>
<td>将容器的端口映射到宿主机上</td>
<td>docker run -p 8000:8000 ubuntu</td>
</tr>
<tr>
<td>–publish-all (-P)</td>
<td>false</td>
<td>将该容器的所有端口均随机映射至宿主机</td>
<td></td>
</tr>
<tr>
<td>–read-only</td>
<td>false</td>
<td>设置该容器只读</td>
<td></td>
</tr>
<tr>
<td>–restart</td>
<td>no</td>
<td>在退出该容器时重启该容器</td>
<td></td>
</tr>
<tr>
<td>–rm</td>
<td>false</td>
<td>当退出该容器时自动删除该容器资源</td>
<td></td>
</tr>
<tr>
<td>–runtime</td>
<td></td>
<td>指定该容器关联一个runtime的容器，在使用该参数时注意runtime specified必须在<code>dockerd --add-runtime</code>注册过。扩展阅读<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009583199">什么是容器的runtime</a>与<a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2017/02/Docker-Containerd-RunC">Docker、Containerd、RunC之间的进程关系</a></td>
<td></td>
</tr>
<tr>
<td>–security-opt</td>
<td></td>
<td>设置安全属性，在windows上使用CredentialSpec模块来执行身份识别。</td>
<td></td>
</tr>
<tr>
<td>–shm-size</td>
<td>0</td>
<td>设置/dev/shm/目录的大小</td>
<td></td>
</tr>
<tr>
<td>–sig-proxy</td>
<td>true</td>
<td>代理进程所接收的所有字符,当指定–sig-proxy=false时，ctrl+c和ctrl+d 不会传递信号给docker进程而关闭容器。</td>
<td></td>
</tr>
<tr>
<td>–stop-signal</td>
<td>SIGTERM</td>
<td>停止带有信号的容器，在linux环境下输入<code>kill -l</code>,就可以看到所有信号名称，可以指定容器发出某种信号时停止该容器，譬如<code>SIGKILL</code></td>
<td></td>
</tr>
<tr>
<td>–stop-timeout</td>
<td>0</td>
<td>设置容器调用命令超时后自动退出。该参数可以设置容器在调用命令时导致超时后多少秒退出，0为永远不退出，该参数单位为秒</td>
<td></td>
</tr>
<tr>
<td>–storage-opt</td>
<td></td>
<td>设定该容器的存储空间，可以分别指定dm.basesize、dm.loopdatasize、dm.loopmetadatasize等项,指定单个容器可用数据空间、docker可用数据空间、元数据可用数据空。</td>
<td>docker run –storage-opt dm.basesize=20G ubuntu</td>
</tr>
<tr>
<td>–sysctl</td>
<td>map[]</td>
<td>修改内核参数，对应修改容器中的<code>/etc/sysctl.conf</code>文件</td>
<td></td>
</tr>
<tr>
<td>–tmpfs</td>
<td></td>
<td>指定挂载一个tmpfs目录，tmpfs是一种虚拟内存文件系统。可以不经由镜像直接创建一个容器</td>
<td>docker run -d –tmpfs /run:rw,noexec,nosuid,size=65536k my_image</td>
</tr>
<tr>
<td>–tty (-t)</td>
<td>false</td>
<td>为容器重新分配一个伪输入终端，通常与参数<code>--interactive (-i)</code>同时使用</td>
<td></td>
</tr>
<tr>
<td>–ulimit</td>
<td></td>
<td>设置容器的ulimit选项，扩展阅读<a target="_blank" rel="noopener" href="http://man.linuxde.net/ulimit">ulimit命令</a></td>
<td></td>
</tr>
<tr>
<td>–user (-u)</td>
<td></td>
<td>在该容器下添加新用户</td>
<td></td>
</tr>
<tr>
<td>–userns</td>
<td></td>
<td>指定该容器运行在指定host user namespace中</td>
<td></td>
</tr>
<tr>
<td>–uts</td>
<td></td>
<td>使用uts命名空间。扩展阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/weifenghai/article/details/52836109">Linux命名空间入门</a></td>
<td></td>
</tr>
<tr>
<td>–volume (-v)</td>
<td></td>
<td>在该容器下挂载新卷</td>
<td></td>
</tr>
<tr>
<td>–volume-driver</td>
<td></td>
<td>挂载一个卷容器，该卷可以是一个本地共享卷或者一个远程服务，配合<code>docker volume create</code>命令创建一个卷</td>
<td></td>
</tr>
<tr>
<td>–volumes-from</td>
<td></td>
<td>可以将任意文件夹反挂载到卷中，从而快速实现对该容器的备份与迁移。</td>
<td>docker run –rm –volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</td>
</tr>
<tr>
<td>–workdir (-w)</td>
<td></td>
<td>指定容器的工作目录与Dockerfile中的<code>WORKDIR</code>作用相同</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="start命令"><a href="#start命令" class="headerlink" title="start命令"></a>start命令</h3><blockquote>
<p>docker start是用于启动容器的命令</p>
</blockquote>
<hr>
<p><strong>语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="容器运维操作"><a href="#容器运维操作" class="headerlink" title="容器运维操作"></a>容器运维操作</h3><h4 id="–attach命令"><a href="#–attach命令" class="headerlink" title="–attach命令"></a>–attach命令</h4><p>docker attach命令对应开发者很有用，可以连接到正在运行的容器，观察容器的运行状况，或与容器的主进程进行交互。</p>
<h4 id="–inspect命令"><a href="#–inspect命令" class="headerlink" title="–inspect命令"></a>–inspect命令</h4><p>用于查看镜像和容器的详细信息，默认会列出全部信息，可以通过–format参数来指定输出的模板格式，以便输出特定信息。</p>
<h4 id="查看容器的信息container（ps）"><a href="#查看容器的信息container（ps）" class="headerlink" title="查看容器的信息container（ps）"></a>查看容器的信息container（ps）</h4><p><code>docker ps</code>命令可以查看容器的<code>CONTAINER ID</code>、<code>NAME</code>、<code>IMAGE NAME</code>、端口开启及绑定、容器启动后执行的<code>COMMNAD</code>。最常用的功能是通过<code>ps</code>来找到<code>CONTAINER_ID，以便对特定容器进行操作。</code><br><code>docker ps</code> 默认显示当前正在运行中的container<br><code>docker ps -a</code> 查看包括已经停止的所有容器<br><code>docker ps -l</code> 显示最新启动的一个容器（包括已停止的）</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[devadmin@swarm1 ~]$ docker ps -l</span><br><span class="line">CONTAINER ID        IMAGE                                            COMMAND              CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">1cfb8ad8642e        regloc.com&#x2F;test&#x2F;settlequery:201711271708   &quot;sh entrypoint.sh&quot;   22 hours ago        Up 22 hours         0.0.0.0:18182-&gt;18182&#x2F;tcp   settlequery.z4taavbos34np74za1bu674az.ncj2uocqbh15ljxhui0yccd9t</span><br><span class="line">[devadmin@swarm1 ~]$ </span><br></pre></td></tr></table></figure>



<h3 id="–-列出机器上的镜像（images）"><a href="#–-列出机器上的镜像（images）" class="headerlink" title="– 列出机器上的镜像（images）"></a>– 列出机器上的镜像（images）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker images </span><br><span class="line">REPOSITORY               TAG             IMAGE ID        CREATED         VIRTUAL SIZE</span><br><span class="line">ubuntu                   14.10           2185fd50e2ca    13 days ago     236.9 MB</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>其中我们可以根据REPOSITORY来判断这个镜像是来自哪个服务器，如果没有 / 则表示官方镜像，类似于<code>username/repos_name</code>表示Github的个人公共库，类似于<code>regsistory.example.com:5000/repos_name</code>则表示的是私服。<br>IMAGE ID列其实是缩写，要显示完整则带上<code>--no-trunc</code>选项</p>
<h3 id="2-在docker-index中搜索image（search）"><a href="#2-在docker-index中搜索image（search）" class="headerlink" title="2. 在docker index中搜索image（search）"></a>2. 在docker index中搜索image（search）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker search TERM</span><br><span class="line"># docker search seanlo</span><br><span class="line">NAME                DESCRIPTION           STARS     OFFICIAL   AUTOMATED</span><br><span class="line">seanloook&#x2F;centos6   sean&#39;s docker repos         0</span><br></pre></td></tr></table></figure>

<p>搜索的范围是官方镜像和所有个人公共镜像。NAME列的 / 后面是仓库的名字。</p>
<h3 id="3-从docker-registry-server-中下拉image或repository（pull）"><a href="#3-从docker-registry-server-中下拉image或repository（pull）" class="headerlink" title="3. 从docker registry server 中下拉image或repository（pull）"></a>3. 从docker registry server 中下拉image或repository（pull）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line"># docker pull centos</span><br></pre></td></tr></table></figure>

<p>上面的命令需要注意，在docker v1.2版本以前，会下载官方镜像的centos仓库里的所有镜像，而从v.13开始官方文档里的说明变了：will pull the centos:latest image, its intermediate layers and any aliases of the same id，也就是只会下载tag为latest的镜像（以及同一images id的其他tag）。<br>也可以明确指定具体的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull centos:centos6</span><br></pre></td></tr></table></figure>

<p>当然也可以从某个人的公共仓库（包括自己是私人仓库）拉取，形如<code>docker pull username/repository&lt;:tag_name&gt;</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull seanlook&#x2F;centos:centos6</span><br></pre></td></tr></table></figure>

<p>如果你没有网络，或者从其他私服获取镜像，形如<code>docker pull registry.domain.com:5000/repos:&lt;tag_name&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull dl.dockerpool.com:5000&#x2F;mongo:latest</span><br></pre></td></tr></table></figure>

<h3 id="4-推送一个image或repository到registry（push）"><a href="#4-推送一个image或repository到registry（push）" class="headerlink" title="4. 推送一个image或repository到registry（push）"></a>4. 推送一个image或repository到registry（push）</h3><p>与上面的pull对应，可以推送到Docker Hub的Public、Private以及私服，但不能推送到Top Level Repository。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker push seanlook&#x2F;mongo</span><br><span class="line"># docker push registry.tp-link.net:5000&#x2F;mongo:2014-10-27</span><br></pre></td></tr></table></figure>

<p>registry.tp-link.net也可以写成IP，172.29.88.222。<br>在repository不存在的情况下，命令行下push上去的会为我们创建为私有库，然而通过浏览器创建的默认为公共库。</p>
<h3 id="5-从image启动一个container（run）"><a href="#5-从image启动一个container（run）" class="headerlink" title="5. 从image启动一个container（run）"></a>5. 从image启动一个container（run）</h3><p><code>docker run</code>命令首先会从特定的image创之上create一层可写的container，然后通过start命令来启动它。停止的container可以重新启动并保留原来的修改。run命令启动参数有很多，以下是一些常规使用说明<br>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<h4 id="5-1-使用image创建container并执行相应命令，然后停止"><a href="#5-1-使用image创建container并执行相应命令，然后停止" class="headerlink" title="5.1 使用image创建container并执行相应命令，然后停止"></a>5.1 使用image创建container并执行相应命令，然后停止</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run ubuntu echo &quot;hello world&quot;</span><br><span class="line">hello word</span><br></pre></td></tr></table></figure>

<p>这是最简单的方式，跟在本地直接执行<code>echo &#39;hello world&#39;</code> 几乎感觉不出任何区别，而实际上它会从本地ubuntu:latest镜像启动到一个容器，并执行打印命令后退出（<code>docker ps -l</code>可查看）。需要注意的是，默认有一个<code>--rm=true</code>参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。<br>容器启动后会自动随机生成一个<code>CONTAINER ID</code>，这个ID在后面commit命令后可以变为<code>IMAGE ID</code></p>
<h4 id="使用image创建container并进入交互模式-login-shell是-bin-bash"><a href="#使用image创建container并进入交互模式-login-shell是-bin-bash" class="headerlink" title="使用image创建container并进入交互模式, login shell是/bin/bash"></a>使用image创建container并进入交互模式, login shell是/bin/bash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run -i -t --name mytest centos:centos6 &#x2F;bin&#x2F;bash</span><br><span class="line">bash-4.1#</span><br></pre></td></tr></table></figure>

<p>上面的<code>--name</code>参数可以指定启动后的容器名字，如果不指定则docker会帮我们取一个名字。镜像<code>centos:centos6</code>也可以用<code>IMAGE ID</code> (68edf809afe7) 代替），并且会启动一个伪终端，但通过ps或top命令我们却只能看到一两个进程，因为容器的核心是所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外，并没有其它的资源，可见Docker对资源的利用率极高。此时使用exit或Ctrl+D退出后，这个容器也就消失了（消失后的容器并没有完全删除？）<br>（那么多个TAG不同而IMAGE ID相同的的镜像究竟会运行以哪一个TAG启动呢</p>
<h4 id="5-2-运行出一个container放到后台运行"><a href="#5-2-运行出一个container放到后台运行" class="headerlink" title="5.2 运行出一个container放到后台运行"></a>5.2 运行出一个container放到后台运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d ubuntu &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 2; done&quot;</span><br><span class="line">ae60c4b642058fefcc61ada85a610914bed9f5df0e2aa147100eab85cea785dc</span><br></pre></td></tr></table></figure>

<p>它将直接把启动的container挂起放在后台运行（这才叫saas），并且会输出一个<code>CONTAINER ID</code>，通过<code>docker ps</code>可以看到这个容器的信息，可在container外面查看它的输出<code>docker logs ae60c4b64205</code>，也可以通过<code>docker attach ae60c4b64205</code>连接到这个正在运行的终端，此时在<code>Ctrl+C</code>退出container就消失了，按ctrl-p ctrl-q可以退出到宿主机，而保持container仍然在运行<br>另外，如果-d启动但后面的命令执行完就结束了，如<code>/bin/bash</code>、<code>echo test</code>，则container做完该做的时候依然会终止。而且-d不能与–rm同时使用<br>可以通过这种方式来运行memcached、apache等。</p>
<h4 id="5-3-映射host到container的端口和目录"><a href="#5-3-映射host到container的端口和目录" class="headerlink" title="5.3 映射host到container的端口和目录"></a>5.3 映射host到container的端口和目录</h4><p>映射主机到容器的端口是很有用的，比如在container中运行memcached，端口为11211，运行容器的host可以连接container的 internel_ip:11211 访问，如果有从其他主机访问memcached需求那就可以通过-p选项，形如<code>-p &lt;host_port:contain_port&gt;</code>，存在以下几种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p 11211:11211 这个即是默认情况下，绑定主机所有网卡（0.0.0.0）的11211端口到容器的11211端口上</span><br><span class="line">-p 127.0.0.1:11211:11211 只绑定localhost这个接口的11211端口</span><br><span class="line">-p 127.0.0.1::5000</span><br><span class="line">-p 127.0.0.1:80:8080</span><br></pre></td></tr></table></figure>

<p>目录映射其实是“绑定挂载”host的路径到container的目录，这对于内外传送文件比较方便，在搭建私服那一节，为了避免私服container停止以后保存的images不被删除，就要把提交的images保存到挂载的主机目录下。使用比较简单，<code>-v &lt;host_path:container_path&gt;</code>，绑定多个目录时再加<code>-v</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v &#x2F;tmp&#x2F;docker:&#x2F;tmp&#x2F;docker</span><br></pre></td></tr></table></figure>

<p>另外在两个container之间建立联系可用<code>--link</code>，<br>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker run --name nginx_test \</span><br><span class="line">&gt; -v &#x2F;tmp&#x2F;docker:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:ro \</span><br><span class="line">&gt; -p 80:80 -d \</span><br><span class="line">&gt; nginx:1.7.6</span><br></pre></td></tr></table></figure>

<p>在主机的/tmp/docker下建立index.html，就可以通过<code>http://localhost:80/</code>或<code>http://host-ip:80</code>访问了。</p>
<h3 id="6-将一个container固化为一个新的image（commit）"><a href="#6-将一个container固化为一个新的image（commit）" class="headerlink" title="6. 将一个container固化为一个新的image（commit）"></a>6. 将一个container固化为一个新的image（commit）</h3><p>当我们在制作自己的镜像的时候，会在container中安装一些工具、修改配置，如果不做commit保存起来，那么container停止以后再启动，这些更改就消失了。<br><code>docker commit &lt;container&gt; [repo:tag]</code><br>后面的repo:tag可选<br>只能提交正在运行的container，即通过<code>docker ps</code>可以看见的容器，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">查看刚运行过的容器</span><br><span class="line"># docker ps -l</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND      CREATED       STATUS        PORTS   NAMES</span><br><span class="line">c9fdf26326c9   nginx:1   nginx -g..   3 hours ago   Exited (0)..     nginx_test</span><br><span class="line"></span><br><span class="line">启动一个已存在的容器（run是从image新建容器后再启动），以下也可以使用docker start nginx_test代替  </span><br><span class="line">[root@hostname docker]# docker start c9fdf26326c9</span><br><span class="line">c9fdf26326c9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -i -t --sig-proxy&#x3D;false 21ffe545748baf &#x2F;bin&#x2F;bash</span><br><span class="line">nginx服务没有启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># docker commit -m &quot;some tools installed&quot; fcbd0a5348ca seanlook&#x2F;ubuntu:14.10_tutorial</span><br><span class="line">fe022762070b09866eaab47bc943ccb796e53f3f416abf3f2327481b446a9503</span><br><span class="line">请注意，当你反复去commit一个容器的时候，每次都会得到一个新的&#96;IMAGE ID&#96;，假如后面的&#96;repository:tag&#96;没有变，通过&#96;docker images&#96;可以看到，之前提交的那份镜像的&#96;repository:tag&#96;就会变成&#96;&lt;none&gt;:&lt;none&gt;&#96;，所以尽量避免反复提交。</span><br><span class="line">另外，观察以下几点:</span><br></pre></td></tr></table></figure>

<ul>
<li>commit container只会pause住容器，这是为了保证容器文件系统的一致性，但不会stop。如果你要对这个容器继续做其他修改：<ul>
<li>你可以重新提交得到新image2，删除次新的image1</li>
<li>也可以关闭容器用新image1启动，继续修改，提交image2后删除image1</li>
<li>当然这样会很痛苦，所以一般是采用<code>Dockerfile</code>来<code>build</code>得到最终image，参考[]</li>
</ul>
</li>
<li>虽然产生了一个新的image，并且你可以看到大小有100MB，但从commit过程很快就可以知道实际上它并没有独立占用100MB的硬盘空间，而只是在旧镜像的基础上修改，它们共享大部分公共的“片”。</li>
</ul>
<p>下</p>
<h3 id="1-开启-停止-重启container（start-stop-restart）"><a href="#1-开启-停止-重启container（start-stop-restart）" class="headerlink" title="1. 开启/停止/重启container（start/stop/restart）"></a>1. 开启/停止/重启container（start/stop/restart）</h3><p>容器可以通过<code>run</code>新建一个来运行，也可以重新<code>start</code>已经停止的container，但<code>start</code>不能够再指定容器启动时运行的指令，因为docker只能有一个前台进程。<br>容器stop（或<code>Ctrl+D</code>）时，会在保存当前容器的状态之后退出，下次start时保有上次关闭时更改。而且每次进入<code>attach</code>进去的界面是一样的，与第一次run启动或commit提交的时刻相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER_ID&#x3D;$(docker start &lt;containner_id&gt;)</span><br><span class="line">docker stop $CONTAINER_ID</span><br><span class="line">docker restart $CONTAINER_ID</span><br></pre></td></tr></table></figure>

<h3 id="2-连接到正在运行中的container（attach）"><a href="#2-连接到正在运行中的container（attach）" class="headerlink" title="2. 连接到正在运行中的container（attach）"></a>2. 连接到正在运行中的container（attach）</h3><p>要<code>attach</code>上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与<code>screen</code>命令的attach类似）。<br>官方文档中说<code>attach</code>后可以通过<code>CTRL-C</code>来detach，但实际上经过我的测试，如果container当前在运行bash，<code>CTRL-C</code>自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，<code>CTRL-C</code>不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在<code>attach</code>是可以带上<code>--sig-proxy=false</code>来确保<code>CTRL-D</code>或<code>CTRL-C</code>不会关闭容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker attach --sig-proxy&#x3D;false $CONTAINER_ID</span><br></pre></td></tr></table></figure>

<h3 id="3-查看image或container的底层信息（inspect）"><a href="#3-查看image或container的底层信息（inspect）" class="headerlink" title="3. 查看image或container的底层信息（inspect）"></a>3. 查看image或container的底层信息（inspect）</h3><p><code>inspect</code>的对象可以是image、运行中的container和停止的container。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看容器的内部IP</span><br><span class="line"># docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; $CONTAINER_ID</span><br><span class="line">172.17.42.35</span><br></pre></td></tr></table></figure>

<h3 id="4-删除一个或多个container、image（rm、rmi）"><a href="#4-删除一个或多个container、image（rm、rmi）" class="headerlink" title="4. 删除一个或多个container、image（rm、rmi）"></a>4. 删除一个或多个container、image（rm、rmi）</h3><p>你可能在使用过程中会<code>build</code>或<code>commit</code>许多镜像，无用的镜像需要删除。但删除这些镜像是有一些条件的：</p>
<ul>
<li>同一个<code>IMAGE ID</code>可能会有多个<code>TAG</code>（可能还在不同的仓库），首先你要根据这些 image names 来删除标签，当删除最后一个tag的时候就会自动删除镜像；</li>
<li>承上，如果要删除的多个<code>IMAGE NAME</code>在同一个<code>REPOSITORY</code>，可以通过<code>docker rmi &lt;image_id&gt;</code>来同时删除剩下的<code>TAG</code>；若在不同Repo则还是需要手动逐个删除<code>TAG</code>；</li>
<li>还存在由这个镜像启动的container时（即便已经停止），也无法删除镜像；</li>
</ul>
<p>TO-DO<br>如何查看镜像与容器的依存关系</p>
<p>删除容器<br><code>docker rm &lt;container_id/contaner_name&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除所有停止的容器</span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>

<p>删除镜像<br>docker rmi &lt;image_id/image_name …&gt;`</p>
<h3 id="5-docker-build-使用此配置生成新的image"><a href="#5-docker-build-使用此配置生成新的image" class="headerlink" title="5. docker build 使用此配置生成新的image"></a>5. docker build 使用此配置生成新的image</h3><p><code>build</code>命令可以从<code>Dockerfile</code>和上下文来创建镜像：<br><code>docker build [OPTIONS] PATH | URL | -</code><br>上面的<code>PATH</code>或<code>URL</code>中的文件被称作上下文，build image的过程会先把这些文件传送到docker的服务端来进行的。<br>如果<code>PATH</code>直接就是一个单独的<code>Dockerfile</code>文件则可以不需要上下文；如果<code>URL</code>是一个Git仓库地址，那么创建image的过程中会自动<code>git clone</code>一份到本机的临时目录，它就成为了本次build的上下文。无论指定的<code>PATH</code>是什么，<code>Dockerfile</code>是至关重要的，请参考<a target="_blank" rel="noopener" href="http://docs.docker.com/reference/builder/">Dockerfile Reference</a>。<br>请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># cat Dockerfile </span><br><span class="line">FROM seanlook&#x2F;nginx:bash_vim</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTRYPOINT &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &amp;&amp; &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># docker build -t seanlook&#x2F;nginx:bash_vim_Df .</span><br><span class="line">Sending build context to Docker daemon 73.45 MB</span><br><span class="line">Sending build context to Docker daemon </span><br><span class="line">Step 0 : FROM seanlook&#x2F;nginx:bash_vim</span><br><span class="line"> ---&gt; aa8516fa0bb7</span><br><span class="line">Step 1 : EXPOSE 80</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; fece07e2b515</span><br><span class="line">Step 2 : ENTRYPOINT &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf &amp;&amp; &#x2F;bin&#x2F;bash</span><br><span class="line"> ---&gt; Running in e08963fd5afb</span><br><span class="line"> ---&gt; d9bbd13f5066</span><br><span class="line">Removing intermediate container e08963fd5afb</span><br><span class="line">Successfully built d9bbd13f5066</span><br></pre></td></tr></table></figure>

<p>上面的<code>PATH</code>为<code>.</code>，所以在当前目录下的所有文件（不包括<code>.dockerignore</code>中的）将会被<code>tar</code>打包并传送到<code>docker daemon</code>（一般在本机），从输出我们可以到<code>Sending build context...</code>，最后有个<code>Removing intermediate container</code>的过程，可以通过<code>--rm=false</code>来保留容器。<br>TO-DO<br><code>docker build github.com/creack/docker-firefox</code>失败。</p>
<h3 id="6-给镜像打上标签（tag）"><a href="#6-给镜像打上标签（tag）" class="headerlink" title="6. 给镜像打上标签（tag）"></a>6. 给镜像打上标签（tag）</h3><p>tag的作用主要有两点：一是为镜像起一个容易理解的名字，二是可以通过<code>docker tag</code>来重新指定镜像的仓库，这样在<code>push</code>时自动提交到仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将同一IMAGE_ID的所有tag，合并为一个新的</span><br><span class="line"># docker tag 195eb90b5349 seanlook&#x2F;ubuntu:rm_test</span><br><span class="line"></span><br><span class="line">新建一个tag，保留旧的那条记录</span><br><span class="line"># docker tag Registry&#x2F;Repos:Tag New_Registry&#x2F;New_Repos:New_Tag</span><br></pre></td></tr></table></figure>

<h3 id="7-查看容器的信息container（ps）"><a href="#7-查看容器的信息container（ps）" class="headerlink" title="7. 查看容器的信息container（ps）"></a>7. 查看容器的信息container（ps）</h3><p><code>docker ps</code>命令可以查看容器的<code>CONTAINER ID</code>、<code>NAME</code>、<code>IMAGE NAME</code>、端口开启及绑定、容器启动后执行的<code>COMMNAD</code>。经常通过<code>ps</code>来找到<code>CONTAINER_ID</code>。<br><code>docker ps</code> 默认显示当前正在运行中的container<br><code>docker ps -a</code> 查看包括已经停止的所有容器<br><code>docker ps -l</code> 显示最新启动的一个容器（包括已停止的）</p>
<h3 id="8-查看容器中正在运行的进程（top）"><a href="#8-查看容器中正在运行的进程（top）" class="headerlink" title="8. 查看容器中正在运行的进程（top）"></a>8. 查看容器中正在运行的进程（top）</h3><p>容器运行时不一定有<code>/bin/bash</code>终端来交互执行top命令，查看container中正在运行的进程，况且还不一定有<code>top</code>命令，这是<code>docker top &lt;container_id/container_name&gt;</code>就很有用了。实际上在host上使用<code>ps -ef|grep docker</code>也可以看到一组类似的进程信息，把container里的进程看成是host上启动docker的子进程就对了。</p>
<h3 id="9-其他命令"><a href="#9-其他命令" class="headerlink" title="9. 其他命令"></a>9. 其他命令</h3><p>docker还有一些如<code>login</code>、<code>cp</code>、<code>logs</code>、<code>export</code>、<code>import</code>、<code>load</code>、<code>kill</code>等不是很常用的命令，比较简单，请参考官网。</p>
<h3 id="events、history和logs命令"><a href="#events、history和logs命令" class="headerlink" title="events、history和logs命令"></a>events、history和logs命令</h3><p>这3个命令用于查看Docker的系统日志信息。events命令会打印出实时的系统事件；history命令会打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的命令记录；logs命令会打印出容器中进程的运行日志。</p>
<p>docker events [options] ：从服务器获取实时事件。</p>
<p>OPTIONS说明：</p>
<ul>
<li><strong>-f ：</strong>根据条件过滤事件；</li>
<li><strong>–since ：</strong>从指定的时间戳后显示所有事件;</li>
<li><strong>–until ：</strong>流水时间显示到指定的时间为止；</li>
</ul>
<p>docker history [options] image：查看指定镜像的创建历史。</p>
<p>OPTIONS说明：</p>
<ul>
<li>**-H :**以可读的格式打印镜像大小和日期，默认为true；</li>
<li>**–no-trunc :**显示完整的提交记录；</li>
<li>**-q :**仅列出提交记录ID。</li>
</ul>
<p>docker logs [options] container</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">        --details        显示更多的信息</span><br><span class="line">    -f, --follow         跟踪日志输出，最后一行为当前时间戳的日志</span><br><span class="line">        --since string   显示自具体某个时间或时间段的日志</span><br><span class="line">        --tail string    从日志末尾显示多少行日志， 默认是all</span><br><span class="line">    -t, --timestamps     显示时间戳</span><br></pre></td></tr></table></figure>

<p>FROM registry.ihdou.com/node:10.15.3-alpine<br>MAINTAINER Charlie<br>ENV NODE_ENV=production<br>ENV HOST 0.0.0.0<br>RUN mkdir -p /social-statics-app<br>COPY . /social-statics-app<br>WORKDIR /social-statics-app<br>EXPOSE 3000<br>RUN apk add –no-cache make gcc g++ python<br>RUN npm install<br>RUN npm rebuild node-sass<br>RUN npm run build<br>RUN npm cache clean –force<br>RUN apk del make gcc g++ python<br>CMD [“npm”, “start”]</p>
<p>镜像构建：</p>
<p>docker build -t social-statics-app .</p>
<p>docker build -t registry.ihdou.com/search .</p>
<p>项目启动命令：</p>
<p>docker run -dt –rm  -p 3000:3000 social-statics-app</p>
<p>docker run -it –rm  -v /usr/local/jars:/logs –name zuul zuul</p>
<p>docker run -it –rm -p 10014:10014  -v /usr/local/jars:/logs –name search search:v1</p>
<p>docker run -it –rm -p 38012:38012  -v /usr/local/jars:/logs registry.ihdou.com/4.0/wallet</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
    <time datetime="2020-10-03T05:59:50.000Z" class="entry-date">
        2020-10-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-Dockerfile构建镜像" class="post-Dockerfile构建镜像 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">Docker Dockerfile</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/" data-id="ckv99zk5r00037ohx98fb55e2" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h4 id="一-Dockerfile基本结构"><a href="#一-Dockerfile基本结构" class="headerlink" title="一.Dockerfile基本结构"></a>一.Dockerfile基本结构</h4><p>一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This Nuxt.js Dockerfile</span></span><br><span class="line"><span class="comment"># FROM </span></span><br><span class="line">MAINTAINER Xuest</span><br><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM registry.ihdou.com/node:10.15.3-alpine</span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER Xuest </span><br><span class="line"><span class="comment">#ENV 设置环境变量</span></span><br><span class="line">ENV NODE_ENV=production</span><br><span class="line">ENV HOST 0.0.0.0</span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN mkdir -p /social-statics-app</span><br><span class="line"><span class="comment">#COPY </span></span><br><span class="line">COPY . /social-statics-app</span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /social-statics-app</span><br><span class="line"><span class="comment">#EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line">RUN npm install</span><br><span class="line">RUN npm rebuild node-sass</span><br><span class="line">RUN npm run build</span><br><span class="line">RUN npm cache clean --force</span><br><span class="line"><span class="comment">#CMD 运行以下命令</span></span><br><span class="line">CMD [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>1、FROM : 指定基础镜像，要在哪个镜像建立</p>
<p>格式为 <code>FROM &lt;image&gt; 或FROM &lt;image&gt;:&lt;tag&gt; 。</code></p>
<p>第一条指令必须为 FROM 指令。**定制的镜像都是基于 FROM 的镜像，这里的 image就是定制需要的基础镜像。后续的操作都是基于 image。</p>
<p>2、MAINTAINER：指定维护者信息</p>
<p>格式为 <code>MAINTAINER &lt;name&gt;</code></p>
<p>3、RUN：在镜像中要执行的命令</p>
<p>格式为 <code>RUN &lt;command&gt; 或 RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>，前者将在 shell 终端中运行命令，即 /bin/bash -c ；后者则使用 exec 执行。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [“/bin/bash”, “-c”,”echo hello”]</code> 。</p>
<p>4、WORKDIR：指定当前工作目录，相当于 cd</p>
<p>格式为 <code>WORKDIR /path/to/workdir</code></p>
<p>5、EXPOSE：指定容器要打开的端口</p>
<p>格式为 <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>，告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。</p>
<p>6、ENV：定义环境变量</p>
<p>格式为 <code>ENV &lt;key&gt; &lt;value&gt;</code> 。 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。</p>
<p>ENV PATH /usr/local/nginx/sbin:$PATH</p>
<p>7、COPY </p>
<p>复制本地主机的 （为 Dockerfile 所在目录的相对路径）到容器中的</p>
<p>8、ADD</p>
<p>相当于 COPY，但是比 COPY 功能更强大</p>
<p>格式为 <code>ADD &lt;src&gt; &lt;dest&gt;</code>，该命令将复制指定的 到容器中的 。 其中 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件，复制进容器会自动解压。</p>
<p>9、VOLUME</p>
<p>挂载目录 格式为<code>VOLUME [&quot;/data&quot;]</code>，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>
<p>10、USER</p>
<p>格式为 <code>USER daemon</code>，指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： RUN useradd -s /sbin/nologin -M www。</p>
<p>11、ENTRYPOINT</p>
<p>ENTRYPOINT [“executable”, “param1”, “param2”] ENTRYPOINT command param1 param2 （shell中执行）</p>
<p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效。</p>
<p>12、CMD</p>
<p>CMD [“executable”,”param1”,”param2”] 使用 exec 执行，推荐方式；CMD command param1 param2 在 /bin/bash 中执行，提供给需要交互的应用；CMD [“param1”,”param2”] 提供给 ENTRYPOINT 的默认参数；指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令</p>
<p>13、ONBUILD</p>
<p>格式为 <code>ONBUILD [INSTRUCTION]</code>，在构建本镜像时不生效，在基于此镜像构建镜像时生效。配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
<p>注意：</p>
<p>ENTRYPOINT 和 CMD 的区别：ENTRYPOINT 指定了该镜像启动时的入口，CMD 则指定了容器启动时的命令，当两者共用时，完整的启动命令像是 ENTRYPOINT + CMD 这样。使用 ENTRYPOINT 的好处是在我们启动镜像就像是启动了一个可执行程序，在 CMD 上仅需要指定参数；另外在我们需要自定义 CMD 时不容易出错。</p>
<p>使用 CMD 的 Dockerfile：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@sta2 test]<span class="meta"># cat Dockerfile FROM mysql CMD [<span class="meta-string">&quot;echo&quot;</span>,<span class="meta-string">&quot;test&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>使用 ENTRYPOINT 的 Dockerfile</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@sta2 entrypoint]<span class="meta">#  cat  Dockerfile FROM mysql ENTRYPOINT [<span class="meta-string">&quot;echo&quot;</span>,<span class="meta-string">&quot;test&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>结论：ENTRYPOINT 不能覆盖掉执行时的参数，CMD 可以掉覆盖默认的参数。</p>
<p>demo</p>
<p>Jar例子：</p>
<p>FROM registry.ihdou.com/java8<br>LABEL maintainer Xuest<br>ADD social-search-server-1.0.0-SNAPSHOT.jar search.jar<br>EXPOSE 10014 19997<br>ENTRYPOINT [“java”,”-jar”,”search.jar”]</p>
<p>VUE Nuxt例子：</p>
<p>FROM registry.ihdou.com/node:10.15.3-alpine<br>MAINTAINER Xuest<br>ENV NODE_ENV=production<br>ENV HOST 0.0.0.0<br>RUN mkdir -p /social-statics-app<br>COPY . /social-statics-app<br>WORKDIR /social-statics-app<br>EXPOSE 3000<br>RUN npm install<br>RUN npm rebuild node-sass<br>RUN npm run build<br>RUN npm cache clean –force<br>CMD [“npm”, “start”]</p>
<p>VUE静态：</p>
<p>FROM registry.ihdou.com/tool/nginx<br>RUN mkdir /usr/share/nginx/html/v4manage<br>COPY nginx.conf /etc/nginx/nginx.conf<br>COPY ./v4manage /usr/share/nginx/html/v4manage<br>EXPOSE 80</p>
<p>&lt;覆盖容器nginx配置&gt;</p>
<p>nginx根目录：/usr/share/nginx/html/</p>
<p>nginx配置地址：/etc/nginx/nginx.conf</p>
<pre><code>        server &#123;
                listen       80;
                server_name  localhost;
                root    /usr/share/nginx/html/v4manage/;
                location / &#123;
                        try_files $uri $uri/ @router;
                        index  index.html index.htm;
                &#125;
                location @router &#123;
                        rewrite ^.*$ /index.html last;
                &#125;
        &#125;</code></pre>
<h4 id="二-创建镜像"><a href="#二-创建镜像" class="headerlink" title="二.创建镜像"></a>二.创建镜像</h4><p>1、使用Dockerfile构建镜像</p>
<p>docker build -t v4manage .  </p>
<p>2.给镜像打标签</p>
<p>docker tag v4manage  192.168.102.78/4.0/ v4manage </p>
<p>3.Push仓库</p>
<p>docker push 192.168.102.78/4.0/ v4manage</p>
<p>[root@k8s-master harbor]# docker tag 192.168.102.78/v4manage 192.168.102.78/4.0/v4manage<br>[root@k8s-master harbor]# docker push 192.168.102.78/4.0/v4manage<br>The push refers to repository [192.168.102.78/4.0/v4manage]<br>518ec4362654: Pushed<br>ba2c6d9de847: Pushed<br>6f40d5797506: Pushed<br>7e914612e366: Pushed<br>f790aed835ee: Pushed<br>850c2400ea4d: Pushed<br>7ccabd267c9f: Pushed<br>f5600c6330da: Pushed<br>latest: digest: sha256:9f920ab7c9e5f5b5f9673b013b2b68193ca80c0a5236d7c72484e473abe3f659 size: 1987</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">
    <time datetime="2020-09-03T05:59:50.000Z" class="entry-date">
        2020-09-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-K8s搭建部署" class="post-K8s搭建部署 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/09/03/K8s%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/">kubeadm部署k8s集群</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/09/03/K8s%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/" data-id="ckv99zk5y00097ohx6arwed6m" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p>
<p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p>
<p>创建一个 Master 节点 kubeadm init</p>
<p>将一个 Node 节点加入到当前集群中 kubeadm join &lt;Master节点的IP和端口 &gt;</p>
<h4 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</span><br><span class="line">-   一台或多台机器，操作系统 CentOS7.x-86_x64</span><br><span class="line">-   硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多</span><br><span class="line">-   集群中所有机器之间网络互通</span><br><span class="line">-   可以访问外网，需要拉取镜像</span><br><span class="line">-   禁止swap分区</span><br></pre></td></tr></table></figure>

<h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-   在所有节点上安装Docker和kubeadm</span><br><span class="line">-   部署Kubernetes Master</span><br><span class="line">-   部署容器网络插件</span><br><span class="line">-   部署 Kubernetes Node，将节点加入Kubernetes集群中</span><br><span class="line">-   部署Dashboard Web页面，可视化查看Kubernetes资源</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="基础环境-所有节点执行"><a href="#基础环境-所有节点执行" class="headerlink" title="基础环境(所有节点执行)"></a>基础环境(所有节点执行)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.78 k8s-master</span><br><span class="line">192.168.102.79 node1 </span><br><span class="line">#1.关闭防火墙：</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">#2.关闭selinux</span><br><span class="line">sed -i &#39;s&#x2F;enforcing&#x2F;disabled&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config#永久</span><br><span class="line">setenforce 0  #临时</span><br><span class="line">#3.关闭swap</span><br><span class="line">swapoff -a #临时  </span><br><span class="line">vim &#x2F;etc&#x2F;fstab   注释或删掉swap行 #永久</span><br><span class="line">#4.设置主机名</span><br><span class="line">hostnamectl set-hostname &lt;hostname&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#在master添加hosts：</span><br><span class="line">cat &gt;&gt; &#x2F;etc&#x2F;hosts &lt;&lt;EOF</span><br><span class="line">192.168.31.78 k8s-master </span><br><span class="line">192.168.31.79 node1 </span><br><span class="line">EOF</span><br><span class="line">#将桥接的IPv4流量传递到iptables的链</span><br><span class="line">cat &gt; &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf &lt;&lt;EOF </span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D;1</span><br><span class="line">EOF</span><br><span class="line">$ sysctl --system #生效</span><br></pre></td></tr></table></figure>

<h4 id="安装docker-kubeadm-kubelet和kubectl-所有节点执行-所有节点都执行："><a href="#安装docker-kubeadm-kubelet和kubectl-所有节点执行-所有节点都执行：" class="headerlink" title="安装docker,kubeadm,kubelet和kubectl(所有节点执行)所有节点都执行："></a>安装docker,kubeadm,kubelet和kubectl(所有节点执行)所有节点都执行：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">安装Docker</span><br><span class="line">Docker version 19.03.13, build 4484c46d9d</span><br><span class="line">查看本机是否已安装：</span><br><span class="line">yum list installed | grep docker</span><br><span class="line">如有卸载：</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">使用官方源地址（比较慢）</span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line">阿里云</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line">查看所有仓库中所有docker版本,并选择特定的版本安装</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">docker-ce.x86_64            3:20.10.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.9-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.8-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.7-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.6-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.5-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.4-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.3-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.2-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.14-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.1-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.13-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.13-3.el7                   @docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.12-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.11-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.10-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:19.03.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.9-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.8-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.7-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.6-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.5-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.4-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.3-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.2-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.1-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:18.09.0-3.el7                    docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.3.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.2.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.06.0.ce-3.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.03.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.12.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.12.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.2.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.06.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.3.ce-1.el7                   docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.2.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable </span><br><span class="line">docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable </span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> </span><br><span class="line">安装指定版本</span><br><span class="line">sudo yum install docker-ce-19.03.13 docker-ce-cli-19.03.13 containerd.io</span><br><span class="line">systemctl enable docker </span><br><span class="line">systemctl start docker</span><br><span class="line">docker version</span><br><span class="line">[root@k8s-node-1 ~]# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           19.03.13</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.13.15</span><br><span class="line"> Git commit:        4484c46d9d</span><br><span class="line"> Built:             Wed Sep 16 17:03:45 2020</span><br><span class="line"> OS&#x2F;Arch:           linux&#x2F;amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"> </span><br><span class="line">修改docker下载镜像的默认源</span><br><span class="line">cat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt; EOF</span><br><span class="line">&#123; &quot;registry-mirrors&quot;:</span><br><span class="line">[&quot;https:&#x2F;&#x2F;b9pmyelo.mirror.aliyuncs.com&quot;] &#125;</span><br><span class="line">EOF</span><br><span class="line">添加阿里云k8s镜像源</span><br><span class="line">[root@master ~]#cat &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo &lt;&lt; EOF </span><br><span class="line">[kubernetes] </span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">repo_gpgcheck&#x3D;0</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg</span><br><span class="line">https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg </span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#安装kubeadm，kubelet和kubectl</span><br><span class="line">[root@master ~]#yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line">[root@master ~]#systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<h4 id="部署Kubernetes-Master"><a href="#部署Kubernetes-Master" class="headerlink" title="部署Kubernetes Master"></a>部署Kubernetes Master</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">在master执行，由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。</span><br><span class="line"></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address&#x3D;192.168.102.78  \</span><br><span class="line">--image-repository registry.aliyuncs.com&#x2F;google_containers  \</span><br><span class="line">--kubernetes-version v1.18.0 \</span><br><span class="line">--service-cidr&#x3D;10.96.0.0&#x2F;12 \</span><br><span class="line">--pod-network-cidr&#x3D;10.244.0.0&#x2F;16</span><br><span class="line"></span><br><span class="line">使用kubectl工具（为了能使用kubectl连接集群，执行下面提示的命令）</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">kubectl get nodes</span><br><span class="line">[root@k8s-master dockeryaml]# kubectl get nodes（此时发现master 状态为 noready）</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    master   27h   v1.18.0</span><br><span class="line">node1        Ready    &lt;none&gt;   27h   v1.18.0</span><br><span class="line">此时master为准备就绪，需要完成下面步骤 (安装Pod网络插件（CNI）)</span><br><span class="line">vi &#x2F;etc&#x2F;hosts #添加</span><br><span class="line">199.232.28.133 gist.githubusecontent.com</span><br><span class="line">199.232.28.133 user-images.githubusercontent.com</span><br><span class="line">199.232.28.133 raw.githubusercontent.com</span><br><span class="line">199.232.28.133 camo.githubusercontent.com</span><br><span class="line">199.232.28.133 cloud.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars0.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars1.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars3.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars4.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars5.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars6.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars7.githubusercontent.com</span><br><span class="line">199.232.28.133 avatars8.githubusercontent.com</span><br><span class="line">[root@master ~]#wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml</span><br><span class="line">[root@master ~]#kubectl apply -f kube-flannel.yml</span><br><span class="line">[root@master ~]#kubectl get pods -n kube-system</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Node节点执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">加入Kubernetes Node</span><br><span class="line">在node节点上执行，向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：</span><br><span class="line">kubeadm join 192.168.102.78:6443 --token 217ucp.zh413g0ix9jljl23     --discovery-token-ca-cert-hash sha256:0f0245b5f1a5517a1962634f55791bb7bd84c6369847637ba4a9185f9d297af1</span><br><span class="line">token如果失效：</span><br><span class="line">kubeadm token create --print-join-command</span><br><span class="line">测试kubernetes集群，在Kubernetes集群中创建一个pod，验证是否正常运行：</span><br><span class="line">$ kubectl create deployment nginx --image&#x3D;nginx </span><br><span class="line">$ kubectl expose deployment nginx --port&#x3D;80 --type&#x3D;NodePort </span><br><span class="line">$ kubectl get pod,svc</span><br><span class="line">访问地址：http:&#x2F;&#x2F;NodeIP:Port</span><br></pre></td></tr></table></figure>


      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/09/03/K8s%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/">
    <time datetime="2020-09-03T05:59:50.000Z" class="entry-date">
        2020-09-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-Elasticsearch集群" class="post-Elasticsearch集群 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/08/03/Elasticsearch%E9%9B%86%E7%BE%A4/">Elasticsearch集群搭建</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/08/03/Elasticsearch%E9%9B%86%E7%BE%A4/" data-id="ckv99zk5v00067ohxhr12508i" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><strong>1.1</strong> <strong>安装准备</strong></p>
<p><strong>1.1.1**</strong>下载安装包**</p>
<p><a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.2.tar.gz">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.2.tar.gz</a></p>
<p><strong>1.1.2</strong> <strong>服务器准备</strong></p>
<p>为搭建ElasticSearch集群，准备了二台服务器，主机IP分别为：</p>
<table>
<thead>
<tr>
<th><strong>服务器IP</strong></th>
<th><strong>系统版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>192.168.102.151</td>
<td>Centos7.5</td>
</tr>
<tr>
<td>192.168.102.11</td>
<td>Centos7.5</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>1.1.3</strong> <strong>新建用户</strong></p>
<p>ES不支持root用户启动，分别使用root用户登录服务器新建es用户,并设置密码，然后给用户文件夹所有权</p>
<p># 新增用户</p>
<p>useradd es</p>
<p># 设置密码</p>
<p>passwd es</p>
<p># 授权</p>
<p>chown es /home/es</p>
<p># 新建es数据文件夹和日志文件夹</p>
<p>mkdir -p /opt/es/logs</p>
<p>mkdir -p /opt/es/data</p>
<p>chown es /opt/es/</p>
<p>chown es /opt/es/logs/</p>
<p>chown es /opt/es/data/</p>
<p># 准备安装包</p>
<p>1、jdk-8u144-linux-x64.tar.gz<br> 2、elasticsearch-6.2.2.tar.gz</p>
<p><strong>1.1.4</strong> <strong>调整系统参数</strong></p>
<p><strong>1.1.3.1</strong> <strong>内核参数调整</strong></p>
<p>vim /etc/sysctl.conf</p>
<p># 增加下面的内容</p>
<p>fs.file-max = 65536</p>
<p>vm.max_map_count = 262144</p>
<p># 执行命令</p>
<p>sysctl -p</p>
<p><strong>1.1.3.2</strong> <strong>资源参数调整</strong></p>
<p>vim /etc/security/limits.conf</p>
<p># 修改</p>
<p>* soft nofile 65536</p>
<p>* hard nofile 65536</p>
<p>* soft nproc 2048</p>
<p>* hard nproc 4096</p>
<p>es soft memlock unlimited</p>
<p>es hard memlock unlimited</p>
<p><strong>1.1.3.3</strong> <strong>调整线程数</strong></p>
<p>vim /etc/security/limits.d/90-nproc.conf</p>
<p>找到如下内容：</p>
<p>* soft nproc 1024</p>
<p>#修改为</p>
<p>* soft nproc 2048</p>
<p><strong>1.2 JDK**</strong>安装**</p>
<p>登录es用户，进入/opt文件夹，解压JDK安装包<br> ES5.0以上必须1.8JDK支持</p>
<p>cd /opt</p>
<p>tar -zxvf /home/es/jdk-8u144-linux-x64.tar.gz</p>
<p># 设置环境变量</p>
<p>vim /etc/profile</p>
<p>#在文件最下方添加</p>
<p>export JAVA_HOME=/opt/jdk1.8.0_144</p>
<p>export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/*.jar</p>
<p>export PATH=.:$JAVA_HOME/bin:$PATH</p>
<p><strong>1.3 ES**</strong>安装及配置**</p>
<p><strong>1.3.1</strong> <strong>解压缩</strong></p>
<p># 切换到es用户</p>
<p>cd /home/es</p>
<p>tar -zxvf elasticsearch-6.2.2.tar.gz</p>
<p><strong>1.3.2</strong> <strong>配置</strong></p>
<p><strong>1.3.2.1 elasticsearch.yml</strong></p>
<p>cluster.name: my-social</p>
<p>node.name: social-151</p>
<p>network.host: 192.168.102.151</p>
<p>node.master: true</p>
<p>node.data: true</p>
<p>path.data: /opt/es/data</p>
<p>path.logs: /opt/es/logs</p>
<p>http.cors.enabled: true</p>
<p>http.ors.allow-origin: “*”</p>
<p>discovery.zen.ping.unicast.hosts: [“192.168.102.11”,”192.168.102.151”]                                  </p>
<p># 集群名称，各个节点的值必须一致</p>
<p>cluster.name: elasticsearch_production</p>
<p># 节点名称，区分节点，各个节点的值不能一致</p>
<p>node.name: node-1</p>
<p># 数据文件路径</p>
<p>path.data: /opt/es/data</p>
<p># 日志文件路径</p>
<p>path.logs: /opt/es/logs</p>
<p># 设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，Linux下可以通过ulimit -l unlimited命令</p>
<p>bootstrap.memory_lock: true</p>
<p># 因为Centos6不支持SecComp，而ES5.6.4默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动</p>
<p>bootstrap.system_call_filter: false</p>
<p># 本机IP</p>
<p>network.host: 192.168.6.104</p>
<p># 单播列表</p>
<p>discovery.zen.ping.unicast.hosts: [“192.168.102.151”, “192.168.102.11”, “192.168.102.40”]</p>
<p># 防止脑裂，官方推荐设置成 N/2 + 1，N是集群中master节点的数量</p>
<p>discovery.zen.minimum_master_nodes: 2</p>
<p># 存在至少2个节点（数据节点或者 master 节点）才进行数据恢复</p>
<p>gateway.recover_after_nodes: 2</p>
<p># 等待10分钟，或者3个节点上线后，才进行数据恢复，这取决于哪个条件先达到</p>
<p>gateway.expected_nodes: 3</p>
<p>gateway.recover_after_time: 10m</p>
<p># 禁用xpack安全认证</p>
<p>xpack.security.enabled: false</p>
<p><strong>1.3.2.2 jvm.options</strong></p>
<p># 调整内存大小根据系统资源而定，最好不要超过总资源一半</p>
<p>-Xms8g</p>
<p>-Xmx8g</p>
<p><strong>1.3.2.3 elasticsearch**</strong>和elasticsearch-plugin**</p>
<p>可选步骤，如果环境变量配置JDK为1.8不需要配置，若需要多JDK共同使用则需要配置</p>
<p>export JAVA_HOME=/opt/jdk1.8.0_144</p>
<p>export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/*.jar</p>
<p>export PATH=.:$JAVA_HOME/bin:$PATH</p>
<p><strong>1.3.4</strong> <strong>启动</strong></p>
<p>cd /home/es/elasticsearch-6.2.2/bin</p>
<p># 控制台启动，加 -d 参数可以后台启动</p>
<p>./elasticsearch    </p>
<p># 查看节点状态</p>
<p>curl -XGET ‘192.168.102.151:9200/_cat/nodes?v’</p>
<p># 查看集群状态</p>
<p>curl -XGET ‘192.168.102.11:9200/_cat/health?v’</p>
<p><strong>1.4 head**</strong>的安装**</p>
<p>//下载源码</p>
<p>（1）git clone git://github.com/mobz/elasticsearch-head.git</p>
<p>//进入根目录</p>
<p>（2）cd elasticsearch-head</p>
<p>//安装</p>
<p>（3）npm install</p>
<p>//启动</p>
<p>（4）nohup grunt server &amp;</p>
<p>这里需要注意es5的head不再是es的插件而是需要单独作为一个服务提供，上面我们安装es时，最后两行配置属性是开启了es的跨域访问，所以head作为一个单独的服务，是可以访问es集群的。</p>
<p>此外es5的head安装依赖nodejs环境，所以我们要安装node 步骤如下：</p>
<p>这里采用的是下载官网编译好的二进制包直接安装</p>
<p>（1）wget <a target="_blank" rel="noopener" href="https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.xz">https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.xz</a></p>
<p>（2）xz -d node-v8.9.4-linux-x64.tar.xz </p>
<p>（3）设置全局环境变量</p>
<p>export NODE_HOME=/usr/local/node/8.9.4</p>
<p>export PATH=$NODE_HOME/bin:$PATH</p>
<p>（4）验证</p>
<p>head只需要在一台es节点上安装即可</p>
<p><strong>1.5 IK**</strong>分词器的安装**</p>
<p>（1）下载源码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip//%E8%BF%9B%E5%85%A5%E6%A0%B9%E7%9B%AE%E5%BD%95">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip//进入根目录</a></p>
<p>（2）cd elasticsearch-6.2.2 </p>
<p>（3）./bin/elasticsearch-plugin install <a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip</a></p>
<p>重启elasticsearch、</p>
<p><a target="_blank" rel="noopener" href="http://192.168.102.151:9200/_analyze?analyzer=ik_max_word&amp;text=iphonex">http://192.168.102.151:9200/_analyze?analyzer=ik_max_word&amp;text=iphonex</a> &amp;pretty=true</p>
<p>常见问题：</p>
<p>通过手动重新分配分片（curl -XPOST esip:9200/_cluster/reroute?retry_failed=true ）解决unassigned</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/08/03/Elasticsearch%E9%9B%86%E7%BE%A4/">
    <time datetime="2020-08-03T05:59:50.000Z" class="entry-date">
        2020-08-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-Java多线程" class="post-Java多线程 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程讲解</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="ckv99zk5z000a7ohxbr077j2q" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h4 id="1-查看线程信息："><a href="#1-查看线程信息：" class="headerlink" title="1.查看线程信息："></a>1.查看线程信息：</h4><ul>
<li><p>方法1：</p>
<p>   jps</p>
<p>   <u><del>top -H -p 进程id</del></u></p>
</li>
<li><p>方法2：</p>
<p> jstack 进程id</p>
</li>
<li><p>方法3  </p>
<p>jconsonle  ， jvisualvm</p>
</li>
</ul>
<p>  cd /usr/local/</p>
<p>  java -Djava.rmi.server.hostname=192.168.102.19 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false  Thread01</p>
<h4 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2.线程状态"></a>2.线程状态</h4><ul>
<li>操作系统层面：5种<img src="./images/1604372609431.png" alt="1604372609431"></li>
</ul>
<p>【初始状态】：创建了线程对象</p>
<p>【可运行状态】：（就绪状态）线程对象创建后，该状态的线程位于可运行线程池中，等待调度，获取cpu 的使用权 。</p>
<p>【运行状态】：可运行状态的线程获得了cpu 时间片 ，执行程序代码。</p>
<p>​    ·当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换。</p>
<p>【阻塞状态】：阻塞状态是指线程因为某种原因放弃了cpu 使用权，让出了cpu时间片，暂时停止运行。直到线程进入可运行)状态，才有机会再次获得cpu时间片转到运行状态。</p>
<ul>
<li><p>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p>
</li>
<li><p>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p>
</li>
<li><p>(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
<p> ·对阻塞状态的线程来说只要他们一直不被唤醒，调度器就一直不回考虑调度他们。</p>
</li>
</ul>
<p>【中止状态】：线程执行完毕，生命周期结束，不会再转换为其他状态。</p>
<ul>
<li>根据Thread.State枚举，分为6种状态。</li>
</ul>
<p><img src="./images/1604375157493.png" alt="1604375157493"></p>
<p>1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</p>
<p>2.运行(RUNNABLE)：调用了start方法后，Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。</p>
<p>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态涵盖了操作系统层面的【可运行状态】，【运行状态】和【阻塞状态】(由于BIO导致的线程阻塞，在java中无法区分，仍然认为是可运行。)</p>
<p>3.阻塞(BLOCKED)：表示线程阻塞于锁。</p>
<p>4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
<p>5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p>
<p>6.终止(TERMINATED)：表示该线程已经执行完毕。</p>
<p>————-StateTest—————</p>
<h4 id="3-守护线程"><a href="#3-守护线程" class="headerlink" title="3.守护线程"></a>3.守护线程</h4><p>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<p>也就是说，如果没有普通线程，那么守护线程也没有存活下去的意义了。</p>
<p>垃圾回收器线程就是 一种守护线程。</p>
<p>————-DaemonTest—————</p>
<h4 id="4-线程上下文切换（Thread-Context-Switch）"><a href="#4-线程上下文切换（Thread-Context-Switch）" class="headerlink" title="4.线程上下文切换（Thread Context Switch）"></a>4.线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因，导致cpu不再执行当前线程，转而执行另一个线程的代码：</p>
<ul>
<li>线程cpu时间片用完（被动）</li>
<li>垃圾回收（被动）</li>
<li>有更高优先级线程执行（被动）</li>
<li>线程自己调用了sleep，wait，yield，join，park，synchronized，lock等方法（主动）</li>
</ul>
<p>当context switch发生时，需要操作系统保存当前线程的状态，并恢复另一个线程的状态。</p>
<p>context switch频繁发生会影响性能。</p>
<h4 id="5-常见方法"><a href="#5-常见方法" class="headerlink" title="5.常见方法"></a>5.常见方法</h4><p><img src="./images/1604393649085.png" alt="1604393649085"></p>
<p><img src="./images/1604393753556.png" alt="1604393753556"></p>
<ul>
<li><h5 id="sleep-amp-yield"><a href="#sleep-amp-yield" class="headerlink" title="sleep&amp;yield"></a>sleep&amp;yield</h5></li>
</ul>
<p><img src="./images/1604395158808.png" alt="1604395158808"></p>
<p>​    3.yield()方法的作用是放弃当前的CPU资源，让其 他任务去占用CPU执行时间，放弃的时间不确定， 有可能刚刚放弃，马上又获得CPU时间片。</p>
<ul>
<li><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5></li>
</ul>
<p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才 从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p>
<p>体现了多线程中同步的应用，即调用方需要等待线程的结果。</p>
<ul>
<li><h5 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h5></li>
</ul>
<ol>
<li><p>打断sleep，wait，join的线程</p>
</li>
<li><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。（打断标记:false）</p>
<p>———-InterruptTest01——————–</p>
</li>
<li><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。（打断标记:true）</p>
<p>————InterruptTest02———————–</p>
</li>
</ol>
<h4 id="6-两阶段终止模式—interrupt实现"><a href="#6-两阶段终止模式—interrupt实现" class="headerlink" title="6.两阶段终止模式—interrupt实现"></a>6.两阶段终止模式—interrupt实现</h4><ul>
<li>当我们想要结束一个线程时候，通过此模式可以优雅安全的关闭线程，让线程可以完成它本应完成的当前任务并可以附加一些收尾工作后再进行关闭</li>
<li>是一种线程设计模式，并不在传统23中设计模式中</li>
<li>此模式下关闭线程会有一定延迟，主要在于被关闭线程需要执行完后，再进行关闭</li>
</ul>
<ul>
<li>​     错误方式</li>
</ul>
<p><img src="./images/1604404899459.png" alt="1604404899459"></p>
<ul>
<li>模拟场景—监控处理</li>
</ul>
<p><img src="./images/1604458290894.png"></p>
<p>———————–TwoPhaseTerminationTest————————</p>
<h4 id="7-锁"><a href="#7-锁" class="headerlink" title="7.锁"></a>7.锁</h4><h5 id="7-1-临界区："><a href="#7-1-临界区：" class="headerlink" title="7.1 临界区："></a>7.1 临界区：</h5><p>一段代码内如果存在对共享资源的的多线程读写操作，称这段代码为临界区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increament</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 临界区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decreament</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">      <span class="comment">// 临界区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-2竞态条件"><a href="#7-2竞态条件" class="headerlink" title="7.2竞态条件"></a>7.2竞态条件</h5><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>
<p>例：</p>
<p>——————SynTest01——-查看字节码————</p>
<ul>
<li>当前线程获得锁后，执行临界区代码；执行中其他线程进入临界区时则进入阻塞；指到当前线程释放锁</li>
</ul>
<h5 id="7-3方法上synchronized"><a href="#7-3方法上synchronized" class="headerlink" title="7.3方法上synchronized"></a>7.3方法上synchronized</h5><p>synchronized是指在对象上加锁。</p>
<p>synchronized(lock): 是指对lock对象加锁</p>
<p>synchronized(this): 是指对当前对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-4-Java对象头"><a href="#7-4-Java对象头" class="headerlink" title="7.4 Java对象头"></a>7.4 Java对象头</h5><ul>
<li>Java对象由 Java对象头和成员变量组成</li>
</ul>
<p>对象头以32位虚拟机为例：</p>
<p>普通对象</p>
<p>​      <img src="./images/1604481085895.png" alt="1604481085895"></p>
<p>数组对象    <img src="./images/1604481118286.png" alt="1604481118286"></p>
<p>其中Mark Word结构为</p>
<p><img src="./images/1604481424575.png" alt="1604481424575"></p>
<h5 id="7-5-Monitor"><a href="#7-5-Monitor" class="headerlink" title="7.5 Monitor"></a>7.5 Monitor</h5><p>Monitor被翻译为<strong>监视器</strong>或<strong>管程</strong>，是java synchronized锁的底层原理</p>
<p>每个Java对象都可以关联一个Monitor对象，当使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word就被设置指向Monitor的指针。</p>
<p>Monitor结构如下</p>
<p><img src="./images/1604483026018.png" alt="1604483026018"></p>
<p><img src="./images/1604488793391.png" alt="1604488793391"></p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/5fa279bc0791291e95ccb764">https://www.processon.com/diagraming/5fa279bc0791291e95ccb764</a></p>
<h5 id="7-6-synchronized字节码"><a href="#7-6-synchronized字节码" class="headerlink" title="7.6 synchronized字节码"></a>7.6 synchronized字节码</h5><p>———————————-SynTest01————————————–</p>
<h5 id="7-7-轻量级锁"><a href="#7-7-轻量级锁" class="headerlink" title="7.7 轻量级锁"></a>7.7 轻量级锁</h5><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
<p>轻量级锁对使用者是透明的，预发仍然是synchronized。</p>
<p>假设有两个方法同步块，利用同一个对象加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 同步代码块1</span></span><br><span class="line">    method2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 同步代码块2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./images/1604557850274.png" alt="1604557850274"></p>
<p><img src="./images/1604558071476.png" alt="1604558071476"></p>
<p><img src="./images/1604558466280.png" alt="1604558466280"></p>
<p><img src="./images/1604558746983.png" alt="1604558746983"></p>
<p><img src="./images/1604558916004.png" alt="1604558916004"></p>
<p><img src="./images/1604559023468.png" alt="1604559023468"></p>
<h5 id="7-8-锁膨胀"><a href="#7-8-锁膨胀" class="headerlink" title="7.8 锁膨胀"></a>7.8 锁膨胀</h5><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这是需要进行锁膨胀，将轻量级锁升级成重量级锁。</p>
<p><img src="./images/1604560081669.png" alt="1604560081669"></p>
<p><img src="./images/1604560207271.png" alt="1604560207271"></p>
<p><img src="./images/1604560393452.png" alt="1604560393452"></p>
<h5 id="7-9-自旋优化"><a href="#7-9-自旋优化" class="headerlink" title="7.9 自旋优化"></a>7.9 自旋优化</h5><p><img src="./images/1604560802387.png" alt="1604560802387"></p>
<p><img src="./images/1604560904235.png" alt="1604560904235"></p>
<p><img src="./images/1604560935146.png" alt="1604560935146"></p>
<h5 id="7-10-偏向锁"><a href="#7-10-偏向锁" class="headerlink" title="7.10 偏向锁"></a>7.10 偏向锁</h5><p>轻量级锁在没有竞争时(就自己这个线程)，每次锁冲入仍然要执行CAS操作。</p>
<p>JAVA6中引入偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID时自己的就表示没有竞争，不用重新CAS，以后只要不发生竞争，这个对象锁就归该线程所有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 同步代码块1</span></span><br><span class="line">    method2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;<span class="comment">//------------锁重入</span></span><br><span class="line">    <span class="comment">// 同步代码块2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="7-10-1-偏向状态"><a href="#7-10-1-偏向状态" class="headerlink" title="7.10.1 偏向状态"></a>7.10.1 偏向状态</h6><p><img src="./images/1604565305465.png" alt="1604565305465"></p>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁(默认开启)，那么对象创建后，markword值为0x05，即最后3位为<strong>101</strong>，这时它的thread，epoch，age都为0</li>
<li>偏向锁默认是有延迟的，不会再程序启动时立即生效，如果想避免延迟，可以加VM参数：-XX:BiasedLockingStartupDelay=0来禁用延迟。</li>
<li>如果没有开启偏向锁，那么对象创建后，markword的值为0x01，即最后3位为<strong>001</strong>，这时它的hashcode，age都为0，第一次用到hashcode时才会赋值</li>
</ul>
<p>——————–BiasedTest01——-验证对象创建mark头数据，vm参数等———–</p>
<p>——————–BiasedTest02——–验证加锁前后mark头数据———-</p>
<h6 id="7-10-2-撤销-调用hashcode"><a href="#7-10-2-撤销-调用hashcode" class="headerlink" title="7.10.2 撤销-调用hashcode"></a>7.10.2 撤销-调用hashcode</h6><p>测试hashcode ：thread+hashcode&gt;64位</p>
<p>——————–BiasedTest02——–验证hashcode加锁前后mark头数据———-</p>
<h6 id="7-10-3-撤销-其他线程使用对象"><a href="#7-10-3-撤销-其他线程使用对象" class="headerlink" title="7.10.3 撤销-其他线程使用对象"></a>7.10.3 撤销-其他线程使用对象</h6><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
<p>——————–BiasedTest03——–</p>
<h6 id="7-10-4-撤销-调用wait-notify"><a href="#7-10-4-撤销-调用wait-notify" class="headerlink" title="7.10.4 撤销-调用wait/notify"></a>7.10.4 撤销-调用wait/notify</h6><h6 id="7-10-5-批量重偏向"><a href="#7-10-5-批量重偏向" class="headerlink" title="7.10.5 批量重偏向"></a>7.10.5 批量重偏向</h6><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了T1的线程仍有机会重新偏向T2，重偏向会重置对象的Thread ID</p>
<p>当撤销偏向锁阈值达到20次后，jvm会觉得，自己是不是偏向错了，于是会再给这些对象加锁时，重新偏向至加锁线程。</p>
<p>——————–BiasedTest04——–</p>
<h6 id="7-10-6-批量撤销"><a href="#7-10-6-批量撤销" class="headerlink" title="7.10.6 批量撤销"></a>7.10.6 批量撤销</h6><p>当撤销偏向锁阈值达到40次后，jvm会觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的。新建的对象也是不可偏向的。</p>
<p>——————–BiasedTest05——–</p>
<h5 id="7-11-锁消除"><a href="#7-11-锁消除" class="headerlink" title="7.11 锁消除"></a>7.11 锁消除</h5><p>锁消除是发生在编译器级别的一种锁优化方式。<br>有时候我们写的代码完全不需要加锁，却执行了加锁操作。</p>
<p>JIT即时编译器，会对热点代码进行优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123;<span class="comment">// 对方法内对象变量加锁，不会发生任何竞争，JIT即时编译器去将锁去掉</span></span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁消除默认时打开的，可以通过 -XX:-EliminateLocks 去掉</p>
<h5 id="7-11-死锁"><a href="#7-11-死锁" class="headerlink" title="7.11 死锁"></a>7.11 死锁</h5><h6 id="7-11-1-定义"><a href="#7-11-1-定义" class="headerlink" title="7.11.1 定义"></a>7.11.1 定义</h6><p>存在这样的情况，一个线程同时获取多把锁，这时就容易产生死锁。</p>
<p>   线程1获得A对象锁，接下来想获取B对象锁</p>
<p>   线程2获得B对象锁，接下来想获取A对象锁</p>
<p>———————–DeadLockTest———————————-</p>
<h6 id="7-11-2-死锁定位"><a href="#7-11-2-死锁定位" class="headerlink" title="7.11.2 死锁定位"></a>7.11.2 死锁定位</h6><ul>
<li><p>命令行工具</p>
<p>   jps</p>
<p>  jstack 进程id</p>
</li>
<li><p>jconsonle  ， jvisualvm</p>
</li>
</ul>
<h6 id="7-11-3-死锁现象-哲学家就餐"><a href="#7-11-3-死锁现象-哲学家就餐" class="headerlink" title="7.11.3 死锁现象-哲学家就餐"></a>7.11.3 死锁现象-哲学家就餐</h6><p><img src="./images/1604891663452.png" alt="1604891663452"></p>
<p>——————-DeadLockEatTest———————–</p>
<h4 id="8-ReentrantLock"><a href="#8-ReentrantLock" class="headerlink" title="8.ReentrantLock"></a>8.ReentrantLock</h4><p>java.util.concurrent下的一个类，</p>
<p>ReentrantLock类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁中断、超时，和多个条件变量等一些特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-1-可重入"><a href="#8-1-可重入" class="headerlink" title="8.1 可重入"></a>8.1 可重入</h5><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获得这把锁</p>
<p>如果是不可重入锁，那么第二次获得锁时，自己也会被挡住</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">      method1();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">      method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-2-可打断"><a href="#8-2-可打断" class="headerlink" title="8.2 可打断"></a>8.2 可打断</h5><p>调用线程的interrupt方法将正在等待锁的线程终止等待</p>
<p>————-Test03—————–</p>
<h5 id="8-3-锁超时"><a href="#8-3-锁超时" class="headerlink" title="8.3 锁超时"></a>8.3 锁超时</h5><p>可打断是一种<strong>被动</strong>避免死等的方式，需要别的线程来执行interrupt方法。</p>
<p>锁超时是一种<strong>主动</strong>避免死等的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;   <span class="comment">//尝试获取锁。true:获取到，可以进入临界区；false:未获取到。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException <span class="comment">//尝试一定时间获取锁</span></span></span><br></pre></td></tr></table></figure>

<p>————-Test04—————–</p>
<h5 id="8-4-哲学家就餐问题的解决"><a href="#8-4-哲学家就餐问题的解决" class="headerlink" title="8.4 哲学家就餐问题的解决"></a>8.4 哲学家就餐问题的解决</h5><p>——————-DeadLockEatTest———————–</p>
<h4 id="9-wait-amp-notify"><a href="#9-wait-amp-notify" class="headerlink" title="9.wait&amp;notify"></a>9.wait&amp;notify</h4><p><img src="./images/1604911151353.png" alt="1604911151353"></p>
<ul>
<li>线程获得到锁后，Owner线程发现自己往下执行的条件不满足，调用锁对象的wait方法，即可进入waitset变为waiting状态。</li>
<li>BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片，BLOCKED是未获得锁，WAITING是获得了锁，但自己又放弃了锁。</li>
<li>BLOCKED线程会在Owner线程释放锁时唤醒</li>
<li>WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进图EntryList重新竞争</li>
</ul>
<h5 id="9-1-API介绍"><a href="#9-1-API介绍" class="headerlink" title="9.1 API介绍"></a>9.1 API介绍</h5><ul>
<li>obj.wait()让进入object锁的线程到waitSet等待。</li>
<li>obj.notify()让object上正在waitSet上等待的线程挑一个来唤醒</li>
<li>obj.notifyAll()让object上正在waitSet上等待的线程全部唤醒</li>
</ul>
<p>他们都是线程之间进行协作的手段，都属于Object对象的方法，由锁对象来调用。</p>
<p><strong>必须获得此对象锁，成为owner后，才能调用这几个方法</strong></p>
<p>——————-WaitTest01———————–</p>
<p>——————-WaitTest02———————–</p>
<h5 id="9-2-wait-sleep区别"><a href="#9-2-wait-sleep区别" class="headerlink" title="9.2 wait sleep区别"></a>9.2 wait sleep区别</h5><p><img src="./images/1604921222531.png" alt="1604921222531"></p>
<h4 id="10-线程状态转换"><a href="#10-线程状态转换" class="headerlink" title="10.线程状态转换"></a>10.线程状态转换</h4><p><img src="./images/1604978135209.png" alt="1604978135209"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/07/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
    <time datetime="2020-07-03T05:59:50.000Z" class="entry-date">
        2020-07-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-A商城系统" class="post-A商城系统 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/06/03/A%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F/">商城管理系统</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/06/03/A%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F/" data-id="ckv99zk5m00017ohxbh62dak4" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="一个基于-SpringCloud-redis-uniapp的商城管理系统，拼团、限购、秒杀都有，可二次开发接私活"><a href="#一个基于-SpringCloud-redis-uniapp的商城管理系统，拼团、限购、秒杀都有，可二次开发接私活" class="headerlink" title="一个基于 SpringCloud+redis+uniapp的商城管理系统，拼团、限购、秒杀都有，可二次开发接私活"></a>一个基于 SpringCloud+redis+uniapp的商城管理系统，拼团、限购、秒杀都有，可二次开发接私活</h1><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>项目采用SpringCloud+Mybatis+mysql+es+redis+mq++vue+uniapp等技术实现，前后端分离。 整个商城有，商城装修，会员、商品、 营销（秒杀、优惠券，限购、拼团、限购、二维码等）、订单、支付、报表统计、钱包等功能，适合企业或个人二次开发。</p>
<h1 id="商城功能"><a href="#商城功能" class="headerlink" title="商城功能"></a>商城功能</h1><p>商城系统由前后端组成，商城管理后台+小程序（H5、小程序通用），业务模块如下：</p>
<ol>
<li><strong>会员模块</strong>：会员列表、会员等级，会员升级等</li>
<li><strong>商品模块</strong>：类目、品牌、型号、规格设置，商品上下架、供应链商品管理等</li>
<li><strong>订单模块</strong>：下单、购物车、支付，发货、收货、评价、退款等</li>
<li><strong>营销模块</strong>：优惠券、限购、拼团、秒杀，二维码等</li>
<li><strong>商城模块</strong>：基础配置、装修模板、帮助中心，分类导航、海报管理等</li>
<li><strong>订单模块</strong>：各种配置</li>
<li><strong>系统设置模块</strong>：菜单等</li>
<li><strong>财务模块</strong>：报表、支付对账流水等</li>
</ol>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>项目采用微信服务架构分模块开发方式</p>
<ol>
<li><strong>hdyg-admin</strong> CMS系统管理</li>
<li><strong>hdyg-member</strong> 会员、营销模块</li>
<li><strong>hdyg-admin</strong> 后台、CMS等模块</li>
<li><strong>hdyg-product</strong> 商品、搜索模块</li>
<li><strong>hdyg-common</strong> 工具模块图片、短信等</li>
<li><strong>hdyg-order</strong> 订单支付售后等模块<h1 id="系统预览"><a href="#系统预览" class="headerlink" title="系统预览"></a>系统预览</h1>前后端预览<br><img src="https://img-blog.csdnimg.cn/b69dd5410bcf460a8813626ef9379066.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JabLS3mnb4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7928e9a799ed475cacaf9094211c99ba.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JabLS3mnb4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ec39f58404944f32a74bc0a8b19d1f4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JabLS3mnb4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c445c3d374cc466aa9e5251d893f7ab0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JabLS3mnb4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/801ced317ab445dcac2157f0f5aee11c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JabLS3mnb4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6690638d75394861b1eb4a8c5dfb486f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JabLS3mnb4=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4cb260ca3c574376b1a462a6ca797a10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JabLS3mnb4=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1></li>
</ol>
<p>后端使用技术</p>
<ol>
<li>springCloud</li>
<li>mybatis</li>
<li>mysql</li>
<li>slf4j</li>
<li>fastjson</li>
<li>redis</li>
<li>xxjob</li>
<li>elasticsearch</li>
<li>swagger</li>
<li>lombok</li>
<li>mapstruct</li>
<li>rocketmq</li>
<li>nacos<h1 id="前端使用技术"><a href="#前端使用技术" class="headerlink" title="前端使用技术"></a>前端使用技术</h1></li>
<li>Vue全家桶</li>
<li>ElementUI</li>
<li>uniapp<h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1>请+Q聊<ol>
<li>QQ:124691234</li>
<li>QQ:297130457</li>
</ol>
</li>
</ol>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/06/03/A%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F/">
    <time datetime="2020-06-03T05:59:50.000Z" class="entry-date">
        2020-06-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-Maven知识库" class="post-Maven知识库 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/06/03/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/">Maven知识库</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/06/03/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/" data-id="ckv99zk5v00077ohx4c2cdzfh" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="Maven的作用？"><a href="#Maven的作用？" class="headerlink" title="Maven的作用？"></a>Maven的作用？</h3><p>1.添加第三方jar包</p>
<p>2.解决jar包之间的依赖关系</p>
<p>3.获取第三方jar包</p>
<p>4.将项目拆成多个工程模块</p>
<h3 id="Maven-是什么？"><a href="#Maven-是什么？" class="headerlink" title="Maven 是什么？"></a><strong>Maven</strong> <strong>是什么？</strong></h3><p>是Apache软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。</p>
<h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><p>1.清理：删除以前的编译结果，为重新编译做好准备。</p>
<p>2.编译：将 Java 源程序为字编译为节码文件。</p>
<p>3.测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。</p>
<p>4.报告：在每一次测试后以标准的格式记录和展示测试结果</p>
<p>5.打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。</p>
<p>6.安装：在 Maven 环境下特指将打包的结果—— jar 包或 war 包安装到本地仓库。</p>
<p>7.部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。</p>
<h3 id="Maven-核心概念"><a href="#Maven-核心概念" class="headerlink" title="Maven 核心概念"></a>Maven 核心概念</h3><p>1.POM</p>
<p>2.约定的目录结构</p>
<p>3.坐标</p>
<p>4.依赖管理</p>
<p>5.仓库管理</p>
<p>6.生命周期</p>
<p>7.插件和目标</p>
<p>8.继承</p>
<p>9.聚合</p>
<h3 id="原理与约定"><a href="#原理与约定" class="headerlink" title="原理与约定"></a>原理与约定</h3><p>Maven 的核心程序中仅仅定义了抽象的声明周期，具体的操作是由 Maven 的插件完成的。Maven 的插件不包含在 Maven 的核心程序中，在首次使用时需要联网下载。</p>
<p>下载的插件被保存在本地仓库，本地仓库的默认位置是：~.m2\repository</p>
<p>约定的目录结构对于 Maven 实现自动化构建是必不可缺的一环，Maven 必须能找到 Java 源文件，编译后的字节码也有一个存储的位置，所以约定至关重要。</p>
<p>项目</p>
<p>  src</p>
<p>​    main</p>
<p>​      java</p>
<p>​      resources</p>
<p>​    test</p>
<p>​      java</p>
<p>​      resources</p>
<p>target</p>
<p>src：源码目录<br> main：主程序目录<br> main-&gt;java：主程序的Java源文件目录<br> main-&gt;resources：主程序的资源文件目录<br> test：测试程序目录<br> test-&gt;java：测试程序的Java源文件目录<br> test-&gt;resources：测试程序的资源文件目录</p>
<h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p>Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。</p>
<p><strong>Maven</strong> <strong>坐标</strong></p>
<p>在空间中需要 x、y、z三个向量确定一个点</p>
<p>使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程(gav)。</p>
<p>1.groupid：公司或组织的域名倒叙+当前项目名称</p>
<p>2.artifactid：当前项目的模块名称</p>
<p>3.version：当前模块的版本</p>
<p><groupId>com.ihdou.maven</groupId></p>
<p><artifactId>Hello</artifactId></p>
<p><version>0.0.1-SNAPSHOT</version></p>
<p>使用命令 <code>mvn install</code> 执行安装后 Maven 工程进入仓库，通过两个步骤查找 jar 包。</p>
<p>1.将 gav 三个向量连起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com. ihdou.maven+Hello+0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>

<p>2.以连起来的的字符串作为目录结构到仓库中查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com&#x2F; ihdou &#x2F;maven&#x2F;Hello&#x2F;0.0.1-SNAPSHOT&#x2F;Hello-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>使用 Maven 就是为了使用它的依赖功能，当 A jar 包用到了 B jar 包的某些类时，A 对 B 产生了依赖。</p>
<p>实现依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.ihdou.maven&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Hello&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>依赖的范围有：compile(编译)、test(测试)、provided(部署)</p>
<p>依赖的传递：A 依赖 B，B 依赖 C ，A 是否能使用 C？要看 B 依赖 C 的范围是不是 compile</p>
<p>依赖的排除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.ihdou&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;TestDB&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;exclusion&gt;</span><br><span class="line">        &lt;&#x2F;exclusions&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>对版本号进行统一：<br> 1.统一声明版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;mysql-connector.version&gt;5.1.47&lt;&#x2F;mysql-connector.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<p>2.引用前面声明的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;mysql-connector.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库有本地仓库和远程仓库，远程仓库包含私服、中央仓库、中央仓库的镜像。</p>
<p>仓库中存储的文件有 Maven 的插件、我们自己开发的项目的模块、第三方框架或工具的 jar 包</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Maven 生命周期定义了各个构建缓解的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。</p>
<p>有3套相互独立的生命周期，分别是：</p>
<p>\1. Clean Lifecycle 在进行真正的构建之前进行的一些清理工具。</p>
<p>\2. Default Lifecycle 构建的核心部分，编译，测试，打包，安装部署等等。</p>
<p>\3. Site Lifecycle 生成项目报告，站点，发布站点</p>
<p>它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。也可以直接运行 mvn clean install site 运行所有这三套声明周期</p>
<p>Clean 生命周期的阶段：</p>
<p>\1. pre-clean 执行一些需要在 clean 之前完成的工作</p>
<p>\2. clean 移除所有上一次构建生成的文件</p>
<p>\3. post-clean 执行一些需要在 clean 之后立刻完成的工作</p>
<p>Site 生命周期的阶段：</p>
<p>\1.   pre-site 执行一些需要在生成站点文档之前完成的工作</p>
<p>\2.   site 生成项目的站点文档</p>
<p>\3.   post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</p>
<p>\4.   site-deploy 将生成的站点文档部署到特定的服务器上</p>
<p>Default 生命周期的阶段</p>
<p>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：</p>
<p>validate</p>
<p>generate-sources</p>
<p>process-sources</p>
<p>generate-resources</p>
<p>process-resources 复制并处理资源文件，至目标目录，准备打包</p>
<p>compile 编译项目的源代码</p>
<p>process-classes</p>
<p>generate-test-sources</p>
<p>process-test-sources</p>
<p>generate-test-resources</p>
<p>process-test-resources 复制并处理资源文件，至目标测试目录</p>
<p>test-compile 编译测试源代码</p>
<p>process-test-classes</p>
<p>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署</p>
<p>prepare-package</p>
<p>package 接受编译好的代码，打包成可发布的格式，如 JAR</p>
<p>pre-integration-test</p>
<p>integration-test</p>
<p>verify</p>
<p>install 将包安装至本地仓库，以让其他项目依赖</p>
<p>deploy 将最终的包复制到远程的仓库，以让其他开发人员与项目共享或部署到服务器上运行</p>
<p>运行任何一个阶段的时候，它前面的所有阶段都会被运行</p>
<h3 id="插件和目标"><a href="#插件和目标" class="headerlink" title="插件和目标"></a>插件和目标</h3><p>Maven 的核心仅仅定义了抽象的声明周期，具体的任务都是交给插件完成的。</p>
<p>每个插件都能实现多个功能，每个功能就是一个插件目标</p>
<p>Maven 的声明周期与插件目标相互绑定，以完成某个具体的构建任务</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>非 compile 范文的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。</p>
<table>
<thead>
<tr>
<th><strong>工程</strong></th>
<th><strong>依赖</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Hello</td>
<td><code>&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></td>
</tr>
<tr>
<td>HelloFriend</td>
<td><code>&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></td>
</tr>
<tr>
<td>MakeFriend</td>
<td><code>&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></td>
</tr>
</tbody></table>
<p>如果将各模块的版本统一为 4.9，各个模块单独修改是不可取的，可以使用继承机制将依赖信息统一提取到父工程模块中进行统一管理。</p>
<h3 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h3><p>1.创建父工程：打包方式设置为 pom</p>
<p>2.在子工程中引用父工程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;!-- 父工程坐标 --&gt;</span><br><span class="line">    &lt;groupId&gt;...&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;...&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;...&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;relativePath&gt;从当前目录到父项目的 pom.xml文件的相对路径&lt;&#x2F;relativePath&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>

<p>如果此时子工程的 groupId 和 version 和父工程重复则可以删除</p>
<p>3.在父工程中管理依赖<br> 将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>在子项目中重新制定需要的依赖，删除范围和版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="聚合-多模块"><a href="#聚合-多模块" class="headerlink" title="聚合(多模块)"></a>聚合(多模块)</h3><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需药逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。</p>
<p>配置聚合：</p>
<p>在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;test&lt;&#x2F;module&gt;</span><br><span class="line">    &lt;module&gt;b&lt;&#x2F;module&gt;</span><br><span class="line">&lt;&#x2F;modules&gt;</span><br></pre></td></tr></table></figure>


      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/06/03/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/">
    <time datetime="2020-06-03T05:59:50.000Z" class="entry-date">
        2020-06-03
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-Redis集群安装部署" class="post-Redis集群安装部署 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/06/03/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/">Redis集群安装部署</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2020/06/03/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" data-id="ckv99zk5x00087ohxaz4a0ldd" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-Redis下载"><a href="#1-Redis下载" class="headerlink" title="1  Redis下载"></a>1  Redis下载</h3><p>从该网站<a target="_blank" rel="noopener" href="http://www.redis.net.cn/%E4%B8%8B%E8%BD%BDredis%E7%A8%B3%E5%AE%9A%E7%89%88%E6%9C%AC[Redis">http://www.redis.net.cn/下载redis稳定版本[Redis</a> 5.0.4](<a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-3.0.6.tar.gz)(redis-5.0.4.tar.gz)%E3%80%82">http://download.redis.io/releases/redis-3.0.6.tar.gz)(redis-5.0.4.tar.gz)。</a></p>
<p>模式: 三主三从</p>
<p>5.0版本后不需要ruby支持，其底层改由C实现</p>
<p>主从配置、leader选举由redis自己实现</p>
<h4 id="1-1-测试服务器"><a href="#1-1-测试服务器" class="headerlink" title="1.1 测试服务器"></a>1.1 测试服务器</h4><p>操作系统: centos</p>
<p>192.168.102.33:6379 192.168.102.33:6380</p>
<p>192.168.102.34:6379 192.168.102.34:6380</p>
<p>192.168.102.35:6379 192.168.102.35:6380</p>
<h4 id="1-2-安装redis"><a href="#1-2-安装redis" class="headerlink" title="1.2 安装redis"></a>1.2 安装redis</h4><p>yum install gcc</p>
<p>yum install tcl</p>
<p>make 安装需要gcc和tcl</p>
<p>#在集群服务器做出以下操作：</p>
<p>cd /usr/local/</p>
<p>tar xzf redis-5.0.4.tar.gz</p>
<p>cd redis-5.0.4</p>
<p>执行make install</p>
<p>至此redis安装完成</p>
<p>运行#make test 测试</p>
<h3 id="2-redis配置文件"><a href="#2-redis配置文件" class="headerlink" title="2  redis配置文件"></a>2  redis配置文件</h3><p>cp redis.conf nodes-6379.conf </p>
<p>cp redis.conf nodes-6380.conf</p>
<p>分别编辑nodes-6379.conf 、nodes-6380.conf</p>
<p>#bind 127.0.0.1（注释掉）</p>
<p>daemonize yes  //后台启动</p>
<p>port 6379（分别对每个机器的端口号进行设置）</p>
<p>dir /usr/local/redis-data/6379/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）</p>
<p>cluster-enabled yes（启动集群模式）</p>
<p>cluster-config-file nodes-6379.conf（集群节点信息文件，这里63xx最好和port对应上）</p>
<p>cluster-node-timeout 5000</p>
<p>protected-mode no  （关闭保护模式）</p>
<p>appendonly yes （启动：设置yes,修改默认的appendonly no,改为yes</p>
<p>将有数据的aof文件复制一份保存到对应目录(config get dir)</p>
<p>恢复：重启redis然后重新加载） </p>
<p>requirepass admin （配置redis服务器密码，不配的话jedis连接会报如下错误）</p>
<p>以上配置每台都需要调整，nodes-6379.conf，nodes-6380.conf</p>
<h3 id="3-启动redis实例"><a href="#3-启动redis实例" class="headerlink" title="3  启动redis实例"></a>3  启动redis实例</h3><p>cd /usr/local/</p>
<p>mkdir redis-data/6379</p>
<p>mkdir redis-data/6380</p>
<p>Redis启动时不会自动创建数据文件存放目录，启动前手动创建</p>
<p>cd /usr/local/ redis-5.0.4/scr</p>
<p>启动</p>
<p>./redis-server ../nodes-6379.conf</p>
<p>./redis-server ../nodes-6380.conf</p>
<p>以此步骤启动每个机器上的redis实例</p>
<h3 id="4-redis配置集群"><a href="#4-redis配置集群" class="headerlink" title="4  redis配置集群"></a>4  redis配置集群</h3><p>任选一台 我这使用192.168.102.33</p>
<p>cd /usr/local/redis-5.0.4/src/</p>
<p>./redis-cli –cluster create –cluster-replicas 1 192.168.102.33:6379 192.168.102.33:6380 192.168.102.34:6379 192.168.102.34:6380 192.168.102.35:6379 192.168.102.35:6380 –cluster-replicas 1 -a admin</p>
<p>注意–cluster-replicas 1 -a admin 带上密码 否则集群创建不成功</p>
<p>以上redis5.0.4集群搭建完毕</p>
<h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5  测试"></a>5  测试</h3>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/06/03/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/">
    <time datetime="2020-06-03T05:59:50.000Z" class="entry-date">
        2020-06-03
    </time>
</a>
    
    
    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2020/12/01/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">Docker 教程讲解</a>
          </li>
        
          <li>
            <a href="/2020/11/03/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">Docker 搭建私有仓库</a>
          </li>
        
          <li>
            <a href="/2020/10/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Docker 命令大全</a>
          </li>
        
          <li>
            <a href="/2020/09/03/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">Docker Dockerfile</a>
          </li>
        
          <li>
            <a href="/2020/09/03/K8s%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/">kubeadm部署k8s集群</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2021 xuesongtan
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>