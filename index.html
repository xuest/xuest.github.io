<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Docker教程讲解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/01/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/" class="article-date">
  <time datetime="2020-12-01T06:13:43.992Z" itemprop="datePublished">2020-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 是一个开源的应用容器引擎，基于 [Go 语言] 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低</p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p>
<h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环</li>
</ul>
<h2 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h2><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
<h3 id="1、快速，一致地交付您的应用程序"><a href="#1、快速，一致地交付您的应用程序" class="headerlink" title="1、快速，一致地交付您的应用程序"></a>1、快速，一致地交付您的应用程序</h3><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p>
<p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p>
<ul>
<li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li>
<li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li>
<li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li>
<li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li>
</ul>
<h3 id="2、响应式部署和扩展"><a href="#2、响应式部署和扩展" class="headerlink" title="2、响应式部署和扩展"></a>2、响应式部署和扩展</h3><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p>
<p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p>
<h3 id="3、在同一硬件上运行更多工作负载"><a href="#3、在同一硬件上运行更多工作负载" class="headerlink" title="3、在同一硬件上运行更多工作负载"></a>3、在同一硬件上运行更多工作负载</h3><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p>
<h1 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h1><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<p>Docker 包括三个基本概念:</p>
<ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<h1 id="Docker-镜像构建"><a href="#Docker-镜像构建" class="headerlink" title="Docker 镜像构建"></a>Docker 镜像构建</h1><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<h2 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h2><p>我们可以使用 <strong>docker images</strong> 来列出本地主机上的镜像。</p>
<p>REPOSITORY                                  TAG                 IMAGE ID            CREATED             SIZE<br>registry.ihdou.com/4.0/v4manage             latest              6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/4.0/v4manage                 latest              6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/4.0/v4manage                 v1                  6f4c3cf49540        30 hours ago        156MB<br>192.168.102.78/v4manage                     latest              6f4c3cf49540        30 hours ago        156MB</p>
<p>各个选项说明:</p>
<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 v4manage             仓库源里，有 v1、latest               等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p>使用镜像来运行容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i 192.168.102.78&#x2F;4.0&#x2F;v4manage:v1 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>-i</strong>: 交互式操作。</li>
<li><strong>-t</strong>: 终端。</li>
<li><strong>ubuntu:15.10</strong>: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</li>
<li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>
</ul>
<h2 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h2><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>
<p>docker pull 192.168.102.78/4.0/v4manage</p>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search v4</span><br></pre></td></tr></table></figure>

<p><strong>NAME:</strong> 镜像仓库源的名称</p>
<p><strong>DESCRIPTION:</strong> 镜像的描述</p>
<p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p>
<p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
<p><strong>AUTOMATED:</strong> 自动构建</p>
<p>我们决定使用上图中的 httpd 官方版本的镜像，使用命令 docker pull 来下载镜像。</p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>镜像删除使用 <strong>docker rmi</strong> 命令，存在基于当前镜像正在运行的或者stop的容器时，需先停用删除容器，再删除镜像</p>
<p>[root@k8s-master harbor]# docker rmi 6dd206182a84<br>Deleted: sha256:6dd206182a849cad478ba4c1de76bfe3e32625e3e49a56a2585c7000efeaf33f<br>Deleted: sha256:b4d4ea2b50ffda7360439fefde67d6bcc61f9fa1f8ce627261bc44ba5b1c3ab8<br>Deleted: sha256:f12cb102ecabd70a1381e2c5e3b5306d3b30e328d52f5c53c39540cc78e4626f<br>Deleted: sha256:64d6980d5059ddbd51a9dea09062d213dfedf89b25822a629f45d3f4aab4159b<br>Deleted: sha256:38f5bf067c29598625aee277b503b95af493e2d61866012cc90a221b9db2fe67<br>Deleted: sha256:5fc71dd3e480565be4631ad5ca7da3e86ec35becafa8333837e630268971d236<br>Deleted: sha256:f552c10bfa44c286856f36a7d00723448f4e8fd392fab6ac3969840daaabd03e<br>[root@k8s-master harbor]# </p>
<h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><p>更新镜像之前，我们需要使用镜像来创建一个容器。在运行的容器内部使用 <strong>apt-get update</strong> 命令进行更新</p>
<p>[root@k8s-master harbor]# docker run -t -i 192.168.102.78/4.0/v4manage:v1 /bin/bash<br>root@d36a4bcbe790:/# apt-get update<br>Get:1 <a target="_blank" rel="noopener" href="http://security.debian.org/debian-security">http://security.debian.org/debian-security</a> buster/updates InRelease [65.4 kB]<br>Get:2 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster InRelease [121 kB]<br>Get:3 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster-updates InRelease [51.9 kB]<br>Get:4 <a target="_blank" rel="noopener" href="http://security.debian.org/debian-security">http://security.debian.org/debian-security</a> buster/updates/main amd64 Packages [253 kB]<br>Get:5 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster/main amd64 Packages [7906 kB]<br>Get:6 <a target="_blank" rel="noopener" href="http://deb.debian.org/debian">http://deb.debian.org/debian</a> buster-updates/main amd64 Packages [7856 B]<br>Fetched 8406 kB in 8s (1052 kB/s)<br>Reading package lists… Done<br>root@d36a4bcbe790:/# </p>
<p>在完成操作之后，输入 exit 命令来退出这个容器。</p>
<p>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p>
<p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li><strong>e218edb10161：</strong>容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li>
</ul>
<h3 id="新增镜像"><a href="#新增镜像" class="headerlink" title="新增镜像"></a>新增镜像</h3><p>我们使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This Nuxt.js Dockerfile</span></span><br><span class="line"><span class="comment"># FROM </span></span><br><span class="line">MAINTAINER Xuest</span><br><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM registry.ihdou.com/node:10.15.3-alpine</span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER Xuest </span><br><span class="line"><span class="comment">#ENV 设置环境变量</span></span><br><span class="line">ENV NODE_ENV=production</span><br><span class="line">ENV HOST 0.0.0.0</span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN mkdir -p /social-statics-app</span><br><span class="line"><span class="comment">#COPY </span></span><br><span class="line">COPY . /social-statics-app</span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /social-statics-app</span><br><span class="line"><span class="comment">#EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line">RUN npm install</span><br><span class="line">RUN npm rebuild node-sass</span><br><span class="line">RUN npm run build</span><br><span class="line">RUN npm cache clean --force</span><br><span class="line"><span class="comment">#CMD 运行以下命令</span></span><br><span class="line">CMD [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Docker-仓库管理"><a href="#Docker-仓库管理" class="headerlink" title="Docker 仓库管理"></a>Docker 仓库管理</h1><p>仓库（Repository）是集中存放镜像的地方。以下介绍一下 [Docker Hub]。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的</p>
<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。</p>
<p>大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h3 id="登录和退出"><a href="#登录和退出" class="headerlink" title="登录和退出"></a>登录和退出</h3><p>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>

<p><strong>退出</strong></p>
<p>退出 docker hub 可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logout</span><br></pre></td></tr></table></figure>

<p>拉取镜像</p>
<p>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</p>
<p>以 ubuntu 为关键词进行搜索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search ubuntu</span><br></pre></td></tr></table></figure>

<p>使用 docker pull 将官方 ubuntu 镜像下载到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu </span><br></pre></td></tr></table></figure>

<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 username 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username&#x2F;ubuntu:18.04</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG        IMAGE ID            CREATED           ...  </span><br><span class="line">ubuntu          18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">username&#x2F;ubuntu 18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">$ docker push username&#x2F;ubuntu:18.04</span><br><span class="line">$ docker search username&#x2F;ubuntu</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED</span><br><span class="line">username&#x2F;ubuntu</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/01/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/" data-id="cki8eocx70005nohxdz990b9y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Docker私有仓库搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/30/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/" class="article-date">
  <time datetime="2020-11-30T03:03:17.669Z" itemprop="datePublished">2020-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker-搭建私有仓库"><a href="#Docker-搭建私有仓库" class="headerlink" title="Docker 搭建私有仓库"></a>Docker 搭建私有仓库</h1><p>以Harbor为列搭建私有仓库</p>
<h2 id="一、Harbor概述"><a href="#一、Harbor概述" class="headerlink" title="一、Harbor概述"></a>一、Harbor概述</h2><p>Habor是由VMWare公司开源的容器镜像仓库。事实上，Habor是在Docker Registry上进行了相应的</p>
<p>企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访</p>
<p>问控制 ，AD/LDAP集成以及审计日志等，足以满足基本企业需求。</p>
<p>官方地址：<a target="_blank" rel="noopener" href="https://vmware.github.io/harbor/cn/">https://vmware.github.io/harbor/cn/</a></p>
<p>Github项目地址：<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p>
<p>安装包下载地址：<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a></p>
<ul>
<li><strong>Harbor相关组件</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>harbor-adminserver</td>
<td>配置管理中心</td>
</tr>
<tr>
<td>harbor-db</td>
<td>Mysql数据库</td>
</tr>
<tr>
<td>harbor-jobservice</td>
<td>负责镜像复制</td>
</tr>
<tr>
<td>harbor-log</td>
<td>记录操作日志</td>
</tr>
<tr>
<td>harbor-ui</td>
<td>Web管理页面和API</td>
</tr>
<tr>
<td>nginx</td>
<td>前端代理，负责前端页面和镜像上传/下载转发</td>
</tr>
<tr>
<td>redis</td>
<td>会话</td>
</tr>
<tr>
<td>registry</td>
<td>镜像存储</td>
</tr>
</tbody></table>
<h2 id="二、Harbor安装"><a href="#二、Harbor安装" class="headerlink" title="二、Harbor安装"></a>二、Harbor安装</h2><p>1、先安装docker-compose</p>
<p>curl -L <a target="_blank" rel="noopener" href="https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-%60uname">https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname</a> -s<code>-</code>uname -m` &gt; /usr/local/bin/docker-compose </p>
<p>给docker-compose添加执行权限</p>
<p>chmod +x /usr/local/bin/docker-compose</p>
<p>查看docker-compose是否安装成功</p>
<p>docker-compose -version</p>
<p>docker-compose version 1.27.3, build 4092ae5d</p>
<p>2、下载Harbor的压缩包v2.1.1</p>
<p>wget <a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases/download/v2.1.1/harbor-offline-installer-v2.1.1.tgz">https://github.com/goharbor/harbor/releases/download/v2.1.1/harbor-offline-installer-v2.1.1.tgz</a></p>
<p>上传压缩包到linux，并解压</p>
<p>tar zxvf harbor-offline-installer-v2.1.1.tgz</p>
<p>修改配置:</p>
<p>cp harbor.yml.tmpl  harbor.yml</p>
<p>vim harbor.yml</p>
<p>修改hostname: 192.168.102.78   密码hd123456</p>
<p>注释掉https默认（如有https另说）</p>
<p>3、安装Harbor</p>
<p>./prepare </p>
<p>./install.sh</p>
<p>4、启动、停止Harbor</p>
<p>docker-compose up -d 启动 </p>
<p>docker-compose stop 停止 </p>
<p>docker-compose restart 重新启动</p>
<p>5、访问Harbor</p>
<p><a target="_blank" rel="noopener" href="http://192.168.102.78/">http://192.168.102.78</a></p>
<p>默认账户密码：admin/hd12345</p>
<p>6、配置http镜像仓库可信任</p>
<p>vim /etc/docker/daemon.json    </p>
<h2 id="编辑配置文件-添加一行信任授权内容："><a href="#编辑配置文件-添加一行信任授权内容：" class="headerlink" title="编辑配置文件 添加一行信任授权内容："></a>编辑配置文件 添加一行信任授权内容：</h2><p> {  </p>
<p>​       “insecure-registries”: [“192.168.102.78”]   </p>
<p> } </p>
<p>添加完成后重启docker服务： systemctl restart docker</p>
<p><img src="C:\Users\XUEST\AppData\Roaming\Typora\typora-user-images\image-20201201105746658.png" alt="image-20201201105746658"></p>
<p>测试实例</p>
<p>docker login 192.168.102.78</p>
<p>admin</p>
<p>hd123456</p>
<p>docker push 192.168.102.78/4.0/v4manage</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/30/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/" data-id="cki8eocx30002nohxa2yy6y20" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Dockerfile构建镜像" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/27/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/" class="article-date">
  <time datetime="2020-11-27T06:02:29.142Z" itemprop="datePublished">2020-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Docker-Dockerfile"><a href="#Docker-Dockerfile" class="headerlink" title="Docker Dockerfile"></a>Docker Dockerfile</h1><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h2 id="一-Dockerfile基本结构"><a href="#一-Dockerfile基本结构" class="headerlink" title="一.Dockerfile基本结构"></a>一.Dockerfile基本结构</h2><p>一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This Nuxt.js Dockerfile</span></span><br><span class="line"><span class="comment"># FROM </span></span><br><span class="line">MAINTAINER Xuest</span><br><span class="line"><span class="comment"># Base images 基础镜像</span></span><br><span class="line">FROM registry.ihdou.com/node:10.15.3-alpine</span><br><span class="line"><span class="comment">#MAINTAINER 维护者信息</span></span><br><span class="line">MAINTAINER Xuest </span><br><span class="line"><span class="comment">#ENV 设置环境变量</span></span><br><span class="line">ENV NODE_ENV=production</span><br><span class="line">ENV HOST 0.0.0.0</span><br><span class="line"><span class="comment">#RUN 执行以下命令 </span></span><br><span class="line">RUN mkdir -p /social-statics-app</span><br><span class="line"><span class="comment">#COPY </span></span><br><span class="line">COPY . /social-statics-app</span><br><span class="line"><span class="comment">#WORKDIR 相当于cd</span></span><br><span class="line">WORKDIR /social-statics-app</span><br><span class="line"><span class="comment">#EXPOSE 映射端口</span></span><br><span class="line">EXPOSE 3000</span><br><span class="line">RUN npm install</span><br><span class="line">RUN npm rebuild node-sass</span><br><span class="line">RUN npm run build</span><br><span class="line">RUN npm cache clean --force</span><br><span class="line"><span class="comment">#CMD 运行以下命令</span></span><br><span class="line">CMD [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>1、FROM : 指定基础镜像，要在哪个镜像建立</p>
<p>格式为 <code>FROM &lt;image&gt; 或FROM &lt;image&gt;:&lt;tag&gt; 。</code></p>
<p>第一条指令必须为 FROM 指令。**定制的镜像都是基于 FROM 的镜像，这里的 image就是定制需要的基础镜像。后续的操作都是基于 image。</p>
<p>2、MAINTAINER：指定维护者信息</p>
<p>格式为 <code>MAINTAINER &lt;name&gt;</code></p>
<p>3、RUN：在镜像中要执行的命令</p>
<p>格式为 <code>RUN &lt;command&gt; 或 RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>，前者将在 shell 终端中运行命令，即 /bin/bash -c ；后者则使用 exec 执行。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [“/bin/bash”, “-c”,”echo hello”]</code> 。</p>
<p>4、WORKDIR：指定当前工作目录，相当于 cd</p>
<p>格式为 <code>WORKDIR /path/to/workdir</code></p>
<p>5、EXPOSE：指定容器要打开的端口</p>
<p>格式为 <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>，告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。</p>
<p>6、ENV：定义环境变量</p>
<p>格式为 <code>ENV &lt;key&gt; &lt;value&gt;</code> 。 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。</p>
<p>ENV PATH /usr/local/nginx/sbin:$PATH</p>
<p>7、COPY </p>
<p>复制本地主机的 （为 Dockerfile 所在目录的相对路径）到容器中的</p>
<p>8、ADD</p>
<p>相当于 COPY，但是比 COPY 功能更强大</p>
<p>格式为 <code>ADD &lt;src&gt; &lt;dest&gt;</code>，该命令将复制指定的 到容器中的 。 其中 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件，复制进容器会自动解压。</p>
<p>9、VOLUME</p>
<p>挂载目录 格式为<code>VOLUME [&quot;/data&quot;]</code>，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>
<p>10、USER</p>
<p>格式为 <code>USER daemon</code>，指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： RUN useradd -s /sbin/nologin -M www。</p>
<p>11、ENTRYPOINT</p>
<p>ENTRYPOINT [“executable”, “param1”, “param2”] ENTRYPOINT command param1 param2 （shell中执行）</p>
<p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效。</p>
<p>12、CMD</p>
<p>CMD [“executable”,”param1”,”param2”] 使用 exec 执行，推荐方式；CMD command param1 param2 在 /bin/bash 中执行，提供给需要交互的应用；CMD [“param1”,”param2”] 提供给 ENTRYPOINT 的默认参数；指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令</p>
<p>13、ONBUILD</p>
<p>格式为 <code>ONBUILD [INSTRUCTION]</code>，在构建本镜像时不生效，在基于此镜像构建镜像时生效。配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
<p>注意：</p>
<p>ENTRYPOINT 和 CMD 的区别：ENTRYPOINT 指定了该镜像启动时的入口，CMD 则指定了容器启动时的命令，当两者共用时，完整的启动命令像是 ENTRYPOINT + CMD 这样。使用 ENTRYPOINT 的好处是在我们启动镜像就像是启动了一个可执行程序，在 CMD 上仅需要指定参数；另外在我们需要自定义 CMD 时不容易出错。</p>
<p>使用 CMD 的 Dockerfile：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@sta2 test]<span class="meta"># cat Dockerfile FROM mysql CMD [<span class="meta-string">&quot;echo&quot;</span>,<span class="meta-string">&quot;test&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>使用 ENTRYPOINT 的 Dockerfile</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@sta2 entrypoint]<span class="meta">#  cat  Dockerfile FROM mysql ENTRYPOINT [<span class="meta-string">&quot;echo&quot;</span>,<span class="meta-string">&quot;test&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>结论：ENTRYPOINT 不能覆盖掉执行时的参数，CMD 可以掉覆盖默认的参数。</p>
<p>demo</p>
<p>Jar例子：</p>
<p>FROM registry.ihdou.com/java8<br>LABEL maintainer Xuest<br>ADD social-search-server-1.0.0-SNAPSHOT.jar search.jar<br>EXPOSE 10014 19997<br>ENTRYPOINT [“java”,”-jar”,”search.jar”]</p>
<p>VUE Nuxt例子：</p>
<p>FROM registry.ihdou.com/node:10.15.3-alpine<br>MAINTAINER Xuest<br>ENV NODE_ENV=production<br>ENV HOST 0.0.0.0<br>RUN mkdir -p /social-statics-app<br>COPY . /social-statics-app<br>WORKDIR /social-statics-app<br>EXPOSE 3000<br>RUN npm install<br>RUN npm rebuild node-sass<br>RUN npm run build<br>RUN npm cache clean –force<br>CMD [“npm”, “start”]</p>
<p>VUE静态：</p>
<p>FROM registry.ihdou.com/tool/nginx<br>RUN mkdir /usr/share/nginx/html/v4manage<br>COPY nginx.conf /etc/nginx/nginx.conf<br>COPY ./v4manage /usr/share/nginx/html/v4manage<br>EXPOSE 80</p>
<p>&lt;覆盖容器nginx配置&gt;</p>
<p>nginx根目录：/usr/share/nginx/html/</p>
<p>nginx配置地址：/etc/nginx/nginx.conf</p>
<pre><code>        server &#123;
                listen       80;
                server_name  localhost;
                root    /usr/share/nginx/html/v4manage/;
                location / &#123;
                        try_files $uri $uri/ @router;
                        index  index.html index.htm;
                &#125;
                location @router &#123;
                        rewrite ^.*$ /index.html last;
                &#125;
        &#125;</code></pre>
<h2 id="二-创建镜像"><a href="#二-创建镜像" class="headerlink" title="二.创建镜像"></a>二.创建镜像</h2><p>1、使用Dockerfile构建镜像</p>
<p>docker build -t v4manage .  </p>
<p>2.给镜像打标签</p>
<p>docker tag v4manage  192.168.102.78/4.0/ v4manage </p>
<p>3.Push仓库</p>
<p>docker push 192.168.102.78/4.0/ v4manage</p>
<p>[root@k8s-master harbor]# docker tag 192.168.102.78/v4manage 192.168.102.78/4.0/v4manage<br>[root@k8s-master harbor]# docker push 192.168.102.78/4.0/v4manage<br>The push refers to repository [192.168.102.78/4.0/v4manage]<br>518ec4362654: Pushed<br>ba2c6d9de847: Pushed<br>6f40d5797506: Pushed<br>7e914612e366: Pushed<br>f790aed835ee: Pushed<br>850c2400ea4d: Pushed<br>7ccabd267c9f: Pushed<br>f5600c6330da: Pushed<br>latest: digest: sha256:9f920ab7c9e5f5b5f9673b013b2b68193ca80c0a5236d7c72484e473abe3f659 size: 1987</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/27/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/" data-id="cki8eocws0000nohxgf439vks" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2020-11-13T08:57:42.205Z" itemprop="datePublished">2020-11-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-查看线程信息："><a href="#1-查看线程信息：" class="headerlink" title="1.查看线程信息："></a>1.查看线程信息：</h4><ul>
<li><p>方法1：</p>
<p>   jps</p>
<p>   <u><del>top -H -p 进程id</del></u></p>
</li>
<li><p>方法2：</p>
<p> jstack 进程id</p>
</li>
<li><p>方法3  </p>
<p>jconsonle  ， jvisualvm</p>
</li>
</ul>
<p>  cd /usr/local/</p>
<p>  java -Djava.rmi.server.hostname=192.168.102.19 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false  Thread01</p>
<h4 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2.线程状态"></a>2.线程状态</h4><ul>
<li>操作系统层面：5种<img src="./images/1604372609431.png" alt="1604372609431"></li>
</ul>
<p>【初始状态】：创建了线程对象</p>
<p>【可运行状态】：（就绪状态）线程对象创建后，该状态的线程位于可运行线程池中，等待调度，获取cpu 的使用权 。</p>
<p>【运行状态】：可运行状态的线程获得了cpu 时间片 ，执行程序代码。</p>
<p>​    ·当CPU时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换。</p>
<p>【阻塞状态】：阻塞状态是指线程因为某种原因放弃了cpu 使用权，让出了cpu时间片，暂时停止运行。直到线程进入可运行)状态，才有机会再次获得cpu时间片转到运行状态。</p>
<ul>
<li><p>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p>
</li>
<li><p>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p>
</li>
<li><p>(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
<p> ·对阻塞状态的线程来说只要他们一直不被唤醒，调度器就一直不回考虑调度他们。</p>
</li>
</ul>
<p>【中止状态】：线程执行完毕，生命周期结束，不会再转换为其他状态。</p>
<ul>
<li>根据Thread.State枚举，分为6种状态。</li>
</ul>
<p><img src="./images/1604375157493.png" alt="1604375157493"></p>
<p>1.初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</p>
<p>2.运行(RUNNABLE)：调用了start方法后，Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。</p>
<p>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态涵盖了操作系统层面的【可运行状态】，【运行状态】和【阻塞状态】(由于BIO导致的线程阻塞，在java中无法区分，仍然认为是可运行。)</p>
<p>3.阻塞(BLOCKED)：表示线程阻塞于锁。</p>
<p>4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
<p>5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p>
<p>6.终止(TERMINATED)：表示该线程已经执行完毕。</p>
<p>————-StateTest—————</p>
<h4 id="3-守护线程"><a href="#3-守护线程" class="headerlink" title="3.守护线程"></a>3.守护线程</h4><p>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<p>也就是说，如果没有普通线程，那么守护线程也没有存活下去的意义了。</p>
<p>垃圾回收器线程就是 一种守护线程。</p>
<p>————-DaemonTest—————</p>
<h4 id="4-线程上下文切换（Thread-Context-Switch）"><a href="#4-线程上下文切换（Thread-Context-Switch）" class="headerlink" title="4.线程上下文切换（Thread Context Switch）"></a>4.线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因，导致cpu不再执行当前线程，转而执行另一个线程的代码：</p>
<ul>
<li>线程cpu时间片用完（被动）</li>
<li>垃圾回收（被动）</li>
<li>有更高优先级线程执行（被动）</li>
<li>线程自己调用了sleep，wait，yield，join，park，synchronized，lock等方法（主动）</li>
</ul>
<p>当context switch发生时，需要操作系统保存当前线程的状态，并恢复另一个线程的状态。</p>
<p>context switch频繁发生会影响性能。</p>
<h4 id="5-常见方法"><a href="#5-常见方法" class="headerlink" title="5.常见方法"></a>5.常见方法</h4><p><img src="./images/1604393649085.png" alt="1604393649085"></p>
<p><img src="./images/1604393753556.png" alt="1604393753556"></p>
<ul>
<li><h5 id="sleep-amp-yield"><a href="#sleep-amp-yield" class="headerlink" title="sleep&amp;yield"></a>sleep&amp;yield</h5></li>
</ul>
<p><img src="./images/1604395158808.png" alt="1604395158808"></p>
<p>​    3.yield()方法的作用是放弃当前的CPU资源，让其 他任务去占用CPU执行时间，放弃的时间不确定， 有可能刚刚放弃，马上又获得CPU时间片。</p>
<ul>
<li><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5></li>
</ul>
<p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才 从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p>
<p>体现了多线程中同步的应用，即调用方需要等待线程的结果。</p>
<ul>
<li><h5 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h5></li>
</ul>
<ol>
<li><p>打断sleep，wait，join的线程</p>
</li>
<li><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。（打断标记:false）</p>
<p>———-InterruptTest01——————–</p>
</li>
<li><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。（打断标记:true）</p>
<p>————InterruptTest02———————–</p>
</li>
</ol>
<h4 id="6-两阶段终止模式—interrupt实现"><a href="#6-两阶段终止模式—interrupt实现" class="headerlink" title="6.两阶段终止模式—interrupt实现"></a>6.两阶段终止模式—interrupt实现</h4><ul>
<li>当我们想要结束一个线程时候，通过此模式可以优雅安全的关闭线程，让线程可以完成它本应完成的当前任务并可以附加一些收尾工作后再进行关闭</li>
<li>是一种线程设计模式，并不在传统23中设计模式中</li>
<li>此模式下关闭线程会有一定延迟，主要在于被关闭线程需要执行完后，再进行关闭</li>
</ul>
<ul>
<li>​     错误方式</li>
</ul>
<p><img src="./images/1604404899459.png" alt="1604404899459"></p>
<ul>
<li>模拟场景—监控处理</li>
</ul>
<p><img src="./images/1604458290894.png"></p>
<p>———————–TwoPhaseTerminationTest————————</p>
<h4 id="7-锁"><a href="#7-锁" class="headerlink" title="7.锁"></a>7.锁</h4><h5 id="7-1-临界区："><a href="#7-1-临界区：" class="headerlink" title="7.1 临界区："></a>7.1 临界区：</h5><p>一段代码内如果存在对共享资源的的多线程读写操作，称这段代码为临界区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increament</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 临界区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decreament</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">      <span class="comment">// 临界区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-2竞态条件"><a href="#7-2竞态条件" class="headerlink" title="7.2竞态条件"></a>7.2竞态条件</h5><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>
<p>例：</p>
<p>——————SynTest01——-查看字节码————</p>
<ul>
<li>当前线程获得锁后，执行临界区代码；执行中其他线程进入临界区时则进入阻塞；指到当前线程释放锁</li>
</ul>
<h5 id="7-3方法上synchronized"><a href="#7-3方法上synchronized" class="headerlink" title="7.3方法上synchronized"></a>7.3方法上synchronized</h5><p>synchronized是指在对象上加锁。</p>
<p>synchronized(lock): 是指对lock对象加锁</p>
<p>synchronized(this): 是指对当前对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-4-Java对象头"><a href="#7-4-Java对象头" class="headerlink" title="7.4 Java对象头"></a>7.4 Java对象头</h5><ul>
<li>Java对象由 Java对象头和成员变量组成</li>
</ul>
<p>对象头以32位虚拟机为例：</p>
<p>普通对象</p>
<p>​      <img src="./images/1604481085895.png" alt="1604481085895"></p>
<p>数组对象    <img src="./images/1604481118286.png" alt="1604481118286"></p>
<p>其中Mark Word结构为</p>
<p><img src="./images/1604481424575.png" alt="1604481424575"></p>
<h5 id="7-5-Monitor"><a href="#7-5-Monitor" class="headerlink" title="7.5 Monitor"></a>7.5 Monitor</h5><p>Monitor被翻译为<strong>监视器</strong>或<strong>管程</strong>，是java synchronized锁的底层原理</p>
<p>每个Java对象都可以关联一个Monitor对象，当使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word就被设置指向Monitor的指针。</p>
<p>Monitor结构如下</p>
<p><img src="./images/1604483026018.png" alt="1604483026018"></p>
<p><img src="./images/1604488793391.png" alt="1604488793391"></p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/5fa279bc0791291e95ccb764">https://www.processon.com/diagraming/5fa279bc0791291e95ccb764</a></p>
<h5 id="7-6-synchronized字节码"><a href="#7-6-synchronized字节码" class="headerlink" title="7.6 synchronized字节码"></a>7.6 synchronized字节码</h5><p>———————————-SynTest01————————————–</p>
<h5 id="7-7-轻量级锁"><a href="#7-7-轻量级锁" class="headerlink" title="7.7 轻量级锁"></a>7.7 轻量级锁</h5><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
<p>轻量级锁对使用者是透明的，预发仍然是synchronized。</p>
<p>假设有两个方法同步块，利用同一个对象加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 同步代码块1</span></span><br><span class="line">    method2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 同步代码块2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./images/1604557850274.png" alt="1604557850274"></p>
<p><img src="./images/1604558071476.png" alt="1604558071476"></p>
<p><img src="./images/1604558466280.png" alt="1604558466280"></p>
<p><img src="./images/1604558746983.png" alt="1604558746983"></p>
<p><img src="./images/1604558916004.png" alt="1604558916004"></p>
<p><img src="./images/1604559023468.png" alt="1604559023468"></p>
<h5 id="7-8-锁膨胀"><a href="#7-8-锁膨胀" class="headerlink" title="7.8 锁膨胀"></a>7.8 锁膨胀</h5><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这是需要进行锁膨胀，将轻量级锁升级成重量级锁。</p>
<p><img src="./images/1604560081669.png" alt="1604560081669"></p>
<p><img src="./images/1604560207271.png" alt="1604560207271"></p>
<p><img src="./images/1604560393452.png" alt="1604560393452"></p>
<h5 id="7-9-自旋优化"><a href="#7-9-自旋优化" class="headerlink" title="7.9 自旋优化"></a>7.9 自旋优化</h5><p><img src="./images/1604560802387.png" alt="1604560802387"></p>
<p><img src="./images/1604560904235.png" alt="1604560904235"></p>
<p><img src="./images/1604560935146.png" alt="1604560935146"></p>
<h5 id="7-10-偏向锁"><a href="#7-10-偏向锁" class="headerlink" title="7.10 偏向锁"></a>7.10 偏向锁</h5><p>轻量级锁在没有竞争时(就自己这个线程)，每次锁冲入仍然要执行CAS操作。</p>
<p>JAVA6中引入偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID时自己的就表示没有竞争，不用重新CAS，以后只要不发生竞争，这个对象锁就归该线程所有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 同步代码块1</span></span><br><span class="line">    method2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;<span class="comment">//------------锁重入</span></span><br><span class="line">    <span class="comment">// 同步代码块2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="7-10-1-偏向状态"><a href="#7-10-1-偏向状态" class="headerlink" title="7.10.1 偏向状态"></a>7.10.1 偏向状态</h6><p><img src="./images/1604565305465.png" alt="1604565305465"></p>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁(默认开启)，那么对象创建后，markword值为0x05，即最后3位为<strong>101</strong>，这时它的thread，epoch，age都为0</li>
<li>偏向锁默认是有延迟的，不会再程序启动时立即生效，如果想避免延迟，可以加VM参数：-XX:BiasedLockingStartupDelay=0来禁用延迟。</li>
<li>如果没有开启偏向锁，那么对象创建后，markword的值为0x01，即最后3位为<strong>001</strong>，这时它的hashcode，age都为0，第一次用到hashcode时才会赋值</li>
</ul>
<p>——————–BiasedTest01——-验证对象创建mark头数据，vm参数等———–</p>
<p>——————–BiasedTest02——–验证加锁前后mark头数据———-</p>
<h6 id="7-10-2-撤销-调用hashcode"><a href="#7-10-2-撤销-调用hashcode" class="headerlink" title="7.10.2 撤销-调用hashcode"></a>7.10.2 撤销-调用hashcode</h6><p>测试hashcode ：thread+hashcode&gt;64位</p>
<p>——————–BiasedTest02——–验证hashcode加锁前后mark头数据———-</p>
<h6 id="7-10-3-撤销-其他线程使用对象"><a href="#7-10-3-撤销-其他线程使用对象" class="headerlink" title="7.10.3 撤销-其他线程使用对象"></a>7.10.3 撤销-其他线程使用对象</h6><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
<p>——————–BiasedTest03——–</p>
<h6 id="7-10-4-撤销-调用wait-notify"><a href="#7-10-4-撤销-调用wait-notify" class="headerlink" title="7.10.4 撤销-调用wait/notify"></a>7.10.4 撤销-调用wait/notify</h6><h6 id="7-10-5-批量重偏向"><a href="#7-10-5-批量重偏向" class="headerlink" title="7.10.5 批量重偏向"></a>7.10.5 批量重偏向</h6><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了T1的线程仍有机会重新偏向T2，重偏向会重置对象的Thread ID</p>
<p>当撤销偏向锁阈值达到20次后，jvm会觉得，自己是不是偏向错了，于是会再给这些对象加锁时，重新偏向至加锁线程。</p>
<p>——————–BiasedTest04——–</p>
<h6 id="7-10-6-批量撤销"><a href="#7-10-6-批量撤销" class="headerlink" title="7.10.6 批量撤销"></a>7.10.6 批量撤销</h6><p>当撤销偏向锁阈值达到40次后，jvm会觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的。新建的对象也是不可偏向的。</p>
<p>——————–BiasedTest05——–</p>
<h5 id="7-11-锁消除"><a href="#7-11-锁消除" class="headerlink" title="7.11 锁消除"></a>7.11 锁消除</h5><p>锁消除是发生在编译器级别的一种锁优化方式。<br>有时候我们写的代码完全不需要加锁，却执行了加锁操作。</p>
<p>JIT即时编译器，会对热点代码进行优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(o) &#123;<span class="comment">// 对方法内对象变量加锁，不会发生任何竞争，JIT即时编译器去将锁去掉</span></span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁消除默认时打开的，可以通过 -XX:-EliminateLocks 去掉</p>
<h5 id="7-11-死锁"><a href="#7-11-死锁" class="headerlink" title="7.11 死锁"></a>7.11 死锁</h5><h6 id="7-11-1-定义"><a href="#7-11-1-定义" class="headerlink" title="7.11.1 定义"></a>7.11.1 定义</h6><p>存在这样的情况，一个线程同时获取多把锁，这时就容易产生死锁。</p>
<p>   线程1获得A对象锁，接下来想获取B对象锁</p>
<p>   线程2获得B对象锁，接下来想获取A对象锁</p>
<p>———————–DeadLockTest———————————-</p>
<h6 id="7-11-2-死锁定位"><a href="#7-11-2-死锁定位" class="headerlink" title="7.11.2 死锁定位"></a>7.11.2 死锁定位</h6><ul>
<li><p>命令行工具</p>
<p>   jps</p>
<p>  jstack 进程id</p>
</li>
<li><p>jconsonle  ， jvisualvm</p>
</li>
</ul>
<h6 id="7-11-3-死锁现象-哲学家就餐"><a href="#7-11-3-死锁现象-哲学家就餐" class="headerlink" title="7.11.3 死锁现象-哲学家就餐"></a>7.11.3 死锁现象-哲学家就餐</h6><p><img src="./images/1604891663452.png" alt="1604891663452"></p>
<p>——————-DeadLockEatTest———————–</p>
<h4 id="8-ReentrantLock"><a href="#8-ReentrantLock" class="headerlink" title="8.ReentrantLock"></a>8.ReentrantLock</h4><p>java.util.concurrent下的一个类，</p>
<p>ReentrantLock类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁中断、超时，和多个条件变量等一些特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-1-可重入"><a href="#8-1-可重入" class="headerlink" title="8.1 可重入"></a>8.1 可重入</h5><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获得这把锁</p>
<p>如果是不可重入锁，那么第二次获得锁时，自己也会被挡住</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">      method1();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">      method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-2-可打断"><a href="#8-2-可打断" class="headerlink" title="8.2 可打断"></a>8.2 可打断</h5><p>调用线程的interrupt方法将正在等待锁的线程终止等待</p>
<p>————-Test03—————–</p>
<h5 id="8-3-锁超时"><a href="#8-3-锁超时" class="headerlink" title="8.3 锁超时"></a>8.3 锁超时</h5><p>可打断是一种<strong>被动</strong>避免死等的方式，需要别的线程来执行interrupt方法。</p>
<p>锁超时是一种<strong>主动</strong>避免死等的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;   <span class="comment">//尝试获取锁。true:获取到，可以进入临界区；false:未获取到。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException <span class="comment">//尝试一定时间获取锁</span></span></span><br></pre></td></tr></table></figure>

<p>————-Test04—————–</p>
<h5 id="8-4-哲学家就餐问题的解决"><a href="#8-4-哲学家就餐问题的解决" class="headerlink" title="8.4 哲学家就餐问题的解决"></a>8.4 哲学家就餐问题的解决</h5><p>——————-DeadLockEatTest———————–</p>
<h4 id="9-wait-amp-notify"><a href="#9-wait-amp-notify" class="headerlink" title="9.wait&amp;notify"></a>9.wait&amp;notify</h4><p><img src="./images/1604911151353.png" alt="1604911151353"></p>
<ul>
<li>线程获得到锁后，Owner线程发现自己往下执行的条件不满足，调用锁对象的wait方法，即可进入waitset变为waiting状态。</li>
<li>BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片，BLOCKED是未获得锁，WAITING是获得了锁，但自己又放弃了锁。</li>
<li>BLOCKED线程会在Owner线程释放锁时唤醒</li>
<li>WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进图EntryList重新竞争</li>
</ul>
<h5 id="9-1-API介绍"><a href="#9-1-API介绍" class="headerlink" title="9.1 API介绍"></a>9.1 API介绍</h5><ul>
<li>obj.wait()让进入object锁的线程到waitSet等待。</li>
<li>obj.notify()让object上正在waitSet上等待的线程挑一个来唤醒</li>
<li>obj.notifyAll()让object上正在waitSet上等待的线程全部唤醒</li>
</ul>
<p>他们都是线程之间进行协作的手段，都属于Object对象的方法，由锁对象来调用。</p>
<p><strong>必须获得此对象锁，成为owner后，才能调用这几个方法</strong></p>
<p>——————-WaitTest01———————–</p>
<p>——————-WaitTest02———————–</p>
<h5 id="9-2-wait-sleep区别"><a href="#9-2-wait-sleep区别" class="headerlink" title="9.2 wait sleep区别"></a>9.2 wait sleep区别</h5><p><img src="./images/1604921222531.png" alt="1604921222531"></p>
<h4 id="10-线程状态转换"><a href="#10-线程状态转换" class="headerlink" title="10.线程状态转换"></a>10.线程状态转换</h4><p><img src="./images/1604978135209.png" alt="1604978135209"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="cki8eocx80006nohxevqcflgq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis集群安装部署" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/30/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" class="article-date">
  <time datetime="2020-10-30T07:43:36.238Z" itemprop="datePublished">2020-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redis集群安装部署"><a href="#Redis集群安装部署" class="headerlink" title="Redis集群安装部署"></a>Redis集群安装部署</h1><h2 id="1-Redis下载"><a href="#1-Redis下载" class="headerlink" title="1  Redis下载"></a>1  Redis下载</h2><p>从该网站<a target="_blank" rel="noopener" href="http://www.redis.net.cn/%E4%B8%8B%E8%BD%BDredis%E7%A8%B3%E5%AE%9A%E7%89%88%E6%9C%AC[Redis">http://www.redis.net.cn/下载redis稳定版本[Redis</a> 5.0.4](<a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-3.0.6.tar.gz)(redis-5.0.4.tar.gz)%E3%80%82">http://download.redis.io/releases/redis-3.0.6.tar.gz)(redis-5.0.4.tar.gz)。</a></p>
<p>模式: 三主三从</p>
<p>5.0版本后不需要ruby支持，其底层改由C实现</p>
<p>主从配置、leader选举由redis自己实现</p>
<h2 id="1-1-测试服务器"><a href="#1-1-测试服务器" class="headerlink" title="1.1 测试服务器"></a>1.1 测试服务器</h2><p>操作系统: centos</p>
<p>192.168.102.33:6379 192.168.102.33:6380</p>
<p>192.168.102.34:6379 192.168.102.34:6380</p>
<p>192.168.102.35:6379 192.168.102.35:6380</p>
<h2 id="1-2-安装redis"><a href="#1-2-安装redis" class="headerlink" title="1.2 安装redis"></a>1.2 安装redis</h2><p>yum install gcc</p>
<p>yum install tcl</p>
<p>make 安装需要gcc和tcl</p>
<p>#在集群服务器做出以下操作：</p>
<p>cd /usr/local/</p>
<p>tar xzf redis-5.0.4.tar.gz</p>
<p>cd redis-5.0.4</p>
<p>执行make install</p>
<p>至此redis安装完成</p>
<p>运行#make test 测试</p>
<h1 id="2-redis配置文件"><a href="#2-redis配置文件" class="headerlink" title="2  redis配置文件"></a>2  redis配置文件</h1><p>cp redis.conf nodes-6379.conf </p>
<p>cp redis.conf nodes-6380.conf</p>
<p>分别编辑nodes-6379.conf 、nodes-6380.conf</p>
<p>#bind 127.0.0.1（注释掉）</p>
<p>daemonize yes  //后台启动</p>
<p>port 6379（分别对每个机器的端口号进行设置）</p>
<p>dir /usr/local/redis-data/6379/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）</p>
<p>cluster-enabled yes（启动集群模式）</p>
<p>cluster-config-file nodes-6379.conf（集群节点信息文件，这里63xx最好和port对应上）</p>
<p>cluster-node-timeout 5000</p>
<p>protected-mode no  （关闭保护模式）</p>
<p>appendonly yes （启动：设置yes,修改默认的appendonly no,改为yes</p>
<p>将有数据的aof文件复制一份保存到对应目录(config get dir)</p>
<p>恢复：重启redis然后重新加载） </p>
<p>requirepass admin （配置redis服务器密码，不配的话jedis连接会报如下错误）</p>
<p>以上配置每台都需要调整，nodes-6379.conf，nodes-6380.conf</p>
<h1 id="3-启动redis实例"><a href="#3-启动redis实例" class="headerlink" title="3  启动redis实例"></a>3  启动redis实例</h1><p>cd /usr/local/</p>
<p>mkdir redis-data/6379</p>
<p>mkdir redis-data/6380</p>
<p>Redis启动时不会自动创建数据文件存放目录，启动前手动创建</p>
<p>cd /usr/local/ redis-5.0.4/scr</p>
<p>启动</p>
<p>./redis-server ../nodes-6379.conf</p>
<p>./redis-server ../nodes-6380.conf</p>
<p>以此步骤启动每个机器上的redis实例</p>
<h1 id="4-redis配置集群"><a href="#4-redis配置集群" class="headerlink" title="4  redis配置集群"></a>4  redis配置集群</h1><p>任选一台 我这使用192.168.102.33</p>
<p>cd /usr/local/redis-5.0.4/src/</p>
<p>./redis-cli –cluster create –cluster-replicas 1 192.168.102.33:6379 192.168.102.33:6380 192.168.102.34:6379 192.168.102.34:6380 192.168.102.35:6379 192.168.102.35:6380 –cluster-replicas 1 -a admin</p>
<p>注意–cluster-replicas 1 -a admin 带上密码 否则集群创建不成功</p>
<p>以上redis5.0.4集群搭建完毕</p>
<h1 id="5-测试"><a href="#5-测试" class="headerlink" title="5  测试"></a>5  测试</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/30/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" data-id="cki8eocx50004nohx1y5ja1q4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Elasticsearch集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/28/Elasticsearch%E9%9B%86%E7%BE%A4/" class="article-date">
  <time datetime="2020-10-28T06:40:24.574Z" itemprop="datePublished">2020-10-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Elasticsearch集群搭建"><a href="#Elasticsearch集群搭建" class="headerlink" title="Elasticsearch集群搭建"></a>Elasticsearch集群搭建</h1><p><strong>1.1</strong> <strong>安装准备</strong></p>
<p><strong>1.1.1**</strong>下载安装包**</p>
<p><a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.2.tar.gz">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.2.tar.gz</a></p>
<p><strong>1.1.2</strong> <strong>服务器准备</strong></p>
<p>为搭建ElasticSearch集群，准备了二台服务器，主机IP分别为：</p>
<table>
<thead>
<tr>
<th><strong>服务器IP</strong></th>
<th><strong>系统版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>192.168.102.151</td>
<td>Centos7.5</td>
</tr>
<tr>
<td>192.168.102.11</td>
<td>Centos7.5</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>1.1.3</strong> <strong>新建用户</strong></p>
<p>ES不支持root用户启动，分别使用root用户登录服务器新建es用户,并设置密码，然后给用户文件夹所有权</p>
<p># 新增用户</p>
<p>useradd es</p>
<p># 设置密码</p>
<p>passwd es</p>
<p># 授权</p>
<p>chown es /home/es</p>
<p># 新建es数据文件夹和日志文件夹</p>
<p>mkdir -p /opt/es/logs</p>
<p>mkdir -p /opt/es/data</p>
<p>chown es /opt/es/</p>
<p>chown es /opt/es/logs/</p>
<p>chown es /opt/es/data/</p>
<p># 准备安装包</p>
<p>1、jdk-8u144-linux-x64.tar.gz<br> 2、elasticsearch-6.2.2.tar.gz</p>
<p><strong>1.1.4</strong> <strong>调整系统参数</strong></p>
<p><strong>1.1.3.1</strong> <strong>内核参数调整</strong></p>
<p>vim /etc/sysctl.conf</p>
<p># 增加下面的内容</p>
<p>fs.file-max = 65536</p>
<p>vm.max_map_count = 262144</p>
<p># 执行命令</p>
<p>sysctl -p</p>
<p><strong>1.1.3.2</strong> <strong>资源参数调整</strong></p>
<p>vim /etc/security/limits.conf</p>
<p># 修改</p>
<p>* soft nofile 65536</p>
<p>* hard nofile 65536</p>
<p>* soft nproc 2048</p>
<p>* hard nproc 4096</p>
<p>es soft memlock unlimited</p>
<p>es hard memlock unlimited</p>
<p><strong>1.1.3.3</strong> <strong>调整线程数</strong></p>
<p>vim /etc/security/limits.d/90-nproc.conf</p>
<p>找到如下内容：</p>
<p>* soft nproc 1024</p>
<p>#修改为</p>
<p>* soft nproc 2048</p>
<p><strong>1.2 JDK**</strong>安装**</p>
<p>登录es用户，进入/opt文件夹，解压JDK安装包<br> ES5.0以上必须1.8JDK支持</p>
<p>cd /opt</p>
<p>tar -zxvf /home/es/jdk-8u144-linux-x64.tar.gz</p>
<p># 设置环境变量</p>
<p>vim /etc/profile</p>
<p>#在文件最下方添加</p>
<p>export JAVA_HOME=/opt/jdk1.8.0_144</p>
<p>export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/*.jar</p>
<p>export PATH=.:$JAVA_HOME/bin:$PATH</p>
<p><strong>1.3 ES**</strong>安装及配置**</p>
<p><strong>1.3.1</strong> <strong>解压缩</strong></p>
<p># 切换到es用户</p>
<p>cd /home/es</p>
<p>tar -zxvf elasticsearch-6.2.2.tar.gz</p>
<p><strong>1.3.2</strong> <strong>配置</strong></p>
<p><strong>1.3.2.1 elasticsearch.yml</strong></p>
<p>cluster.name: my-social</p>
<p>node.name: social-151</p>
<p>network.host: 192.168.102.151</p>
<p>node.master: true</p>
<p>node.data: true</p>
<p>path.data: /opt/es/data</p>
<p>path.logs: /opt/es/logs</p>
<p>http.cors.enabled: true</p>
<p>http.ors.allow-origin: “*”</p>
<p>discovery.zen.ping.unicast.hosts: [“192.168.102.11”,”192.168.102.151”]                                  </p>
<p># 集群名称，各个节点的值必须一致</p>
<p>cluster.name: elasticsearch_production</p>
<p># 节点名称，区分节点，各个节点的值不能一致</p>
<p>node.name: node-1</p>
<p># 数据文件路径</p>
<p>path.data: /opt/es/data</p>
<p># 日志文件路径</p>
<p>path.logs: /opt/es/logs</p>
<p># 设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，Linux下可以通过ulimit -l unlimited命令</p>
<p>bootstrap.memory_lock: true</p>
<p># 因为Centos6不支持SecComp，而ES5.6.4默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动</p>
<p>bootstrap.system_call_filter: false</p>
<p># 本机IP</p>
<p>network.host: 192.168.6.104</p>
<p># 单播列表</p>
<p>discovery.zen.ping.unicast.hosts: [“192.168.102.151”, “192.168.102.11”, “192.168.102.40”]</p>
<p># 防止脑裂，官方推荐设置成 N/2 + 1，N是集群中master节点的数量</p>
<p>discovery.zen.minimum_master_nodes: 2</p>
<p># 存在至少2个节点（数据节点或者 master 节点）才进行数据恢复</p>
<p>gateway.recover_after_nodes: 2</p>
<p># 等待10分钟，或者3个节点上线后，才进行数据恢复，这取决于哪个条件先达到</p>
<p>gateway.expected_nodes: 3</p>
<p>gateway.recover_after_time: 10m</p>
<p># 禁用xpack安全认证</p>
<p>xpack.security.enabled: false</p>
<p><strong>1.3.2.2 jvm.options</strong></p>
<p># 调整内存大小根据系统资源而定，最好不要超过总资源一半</p>
<p>-Xms8g</p>
<p>-Xmx8g</p>
<p><strong>1.3.2.3 elasticsearch**</strong>和elasticsearch-plugin**</p>
<p>可选步骤，如果环境变量配置JDK为1.8不需要配置，若需要多JDK共同使用则需要配置</p>
<p>export JAVA_HOME=/opt/jdk1.8.0_144</p>
<p>export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/*.jar</p>
<p>export PATH=.:$JAVA_HOME/bin:$PATH</p>
<p><strong>1.3.4</strong> <strong>启动</strong></p>
<p>cd /home/es/elasticsearch-6.2.2/bin</p>
<p># 控制台启动，加 -d 参数可以后台启动</p>
<p>./elasticsearch    </p>
<p># 查看节点状态</p>
<p>curl -XGET ‘192.168.102.151:9200/_cat/nodes?v’</p>
<p># 查看集群状态</p>
<p>curl -XGET ‘192.168.102.11:9200/_cat/health?v’</p>
<p><strong>1.4 head**</strong>的安装**</p>
<p>//下载源码</p>
<p>（1）git clone git://github.com/mobz/elasticsearch-head.git</p>
<p>//进入根目录</p>
<p>（2）cd elasticsearch-head</p>
<p>//安装</p>
<p>（3）npm install</p>
<p>//启动</p>
<p>（4）nohup grunt server &amp;</p>
<p>这里需要注意es5的head不再是es的插件而是需要单独作为一个服务提供，上面我们安装es时，最后两行配置属性是开启了es的跨域访问，所以head作为一个单独的服务，是可以访问es集群的。</p>
<p>此外es5的head安装依赖nodejs环境，所以我们要安装node 步骤如下：</p>
<p>这里采用的是下载官网编译好的二进制包直接安装</p>
<p>（1）wget <a target="_blank" rel="noopener" href="https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.xz">https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.xz</a></p>
<p>（2）xz -d node-v8.9.4-linux-x64.tar.xz </p>
<p>（3）设置全局环境变量</p>
<p>export NODE_HOME=/usr/local/node/8.9.4</p>
<p>export PATH=$NODE_HOME/bin:$PATH</p>
<p>（4）验证</p>
<p>head只需要在一台es节点上安装即可</p>
<p><strong>1.5 IK**</strong>分词器的安装**</p>
<p>（1）下载源码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip//%E8%BF%9B%E5%85%A5%E6%A0%B9%E7%9B%AE%E5%BD%95">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip//进入根目录</a></p>
<p>（2）cd elasticsearch-6.2.2 </p>
<p>（3）./bin/elasticsearch-plugin install <a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip</a></p>
<p>重启elasticsearch、</p>
<p><a target="_blank" rel="noopener" href="http://192.168.102.151:9200/_analyze?analyzer=ik_max_word&amp;text=iphonex">http://192.168.102.151:9200/_analyze?analyzer=ik_max_word&amp;text=iphonex</a> &amp;pretty=true</p>
<p>常见问题：</p>
<p>通过手动重新分配分片（curl -XPOST esip:9200/_cluster/reroute?retry_failed=true ）解决unassigned</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/28/Elasticsearch%E9%9B%86%E7%BE%A4/" data-id="cki8eocx10001nohx06pj7giz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Maven知识库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/27/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/" class="article-date">
  <time datetime="2020-10-27T08:59:43.875Z" itemprop="datePublished">2020-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Maven知识库"><a href="#Maven知识库" class="headerlink" title="Maven知识库"></a>Maven知识库</h1><h3 id="Maven的作用？"><a href="#Maven的作用？" class="headerlink" title="Maven的作用？"></a>Maven的作用？</h3><p>1.添加第三方jar包</p>
<p>2.解决jar包之间的依赖关系</p>
<p>3.获取第三方jar包</p>
<p>4.将项目拆成多个工程模块</p>
<p><strong>Maven</strong> <strong>是什么？</strong></p>
<p>是Apache软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。</p>
<h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><p>1.清理：删除以前的编译结果，为重新编译做好准备。</p>
<p>2.编译：将 Java 源程序为字编译为节码文件。</p>
<p>3.测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。</p>
<p>4.报告：在每一次测试后以标准的格式记录和展示测试结果</p>
<p>5.打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。</p>
<p>6.安装：在 Maven 环境下特指将打包的结果—— jar 包或 war 包安装到本地仓库。</p>
<p>7.部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。</p>
<h3 id="Maven-是什么？"><a href="#Maven-是什么？" class="headerlink" title="Maven 是什么？"></a>Maven 是什么？</h3><p>是Apache软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理</p>
<h3 id="Maven-核心概念"><a href="#Maven-核心概念" class="headerlink" title="Maven 核心概念"></a>Maven 核心概念</h3><p>1.POM</p>
<p>2.约定的目录结构</p>
<p>3.坐标</p>
<p>4.依赖管理</p>
<p>5.仓库管理</p>
<p>6.生命周期</p>
<p>7.插件和目标</p>
<p>8.继承</p>
<p>9.聚合</p>
<h3 id="原理与约定"><a href="#原理与约定" class="headerlink" title="原理与约定"></a>原理与约定</h3><p>Maven 的核心程序中仅仅定义了抽象的声明周期，具体的操作是由 Maven 的插件完成的。Maven 的插件不包含在 Maven 的核心程序中，在首次使用时需要联网下载。</p>
<p>下载的插件被保存在本地仓库，本地仓库的默认位置是：~.m2\repository</p>
<p>约定的目录结构对于 Maven 实现自动化构建是必不可缺的一环，Maven 必须能找到 Java 源文件，编译后的字节码也有一个存储的位置，所以约定至关重要。</p>
<p>项目</p>
<p>  src</p>
<p>​    main</p>
<p>​      java</p>
<p>​      resources</p>
<p>​    test</p>
<p>​      java</p>
<p>​      resources</p>
<p>target</p>
<p>src：源码目录<br> main：主程序目录<br> main-&gt;java：主程序的Java源文件目录<br> main-&gt;resources：主程序的资源文件目录<br> test：测试程序目录<br> test-&gt;java：测试程序的Java源文件目录<br> test-&gt;resources：测试程序的资源文件目录</p>
<h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p>Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。</p>
<p><strong>Maven</strong> <strong>坐标</strong></p>
<p>在空间中需要 x、y、z三个向量确定一个点</p>
<p>使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程(gav)。</p>
<p>1.groupid：公司或组织的域名倒叙+当前项目名称</p>
<p>2.artifactid：当前项目的模块名称</p>
<p>3.version：当前模块的版本</p>
<p><groupId>com.ihdou.maven</groupId></p>
<p><artifactId>Hello</artifactId></p>
<p><version>0.0.1-SNAPSHOT</version></p>
<p>使用命令 <code>mvn install</code> 执行安装后 Maven 工程进入仓库，通过两个步骤查找 jar 包。</p>
<p>1.将 gav 三个向量连起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com. ihdou.maven+Hello+0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>

<p>2.以连起来的的字符串作为目录结构到仓库中查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com&#x2F; ihdou &#x2F;maven&#x2F;Hello&#x2F;0.0.1-SNAPSHOT&#x2F;Hello-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>使用 Maven 就是为了使用它的依赖功能，当 A jar 包用到了 B jar 包的某些类时，A 对 B 产生了依赖。</p>
<p>实现依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.ihdou.maven&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Hello&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>依赖的范围有：compile(编译)、test(测试)、provided(部署)</p>
<p>依赖的传递：A 依赖 B，B 依赖 C ，A 是否能使用 C？要看 B 依赖 C 的范围是不是 compile</p>
<p>依赖的排除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.ihdou&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;TestDB&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;exclusion&gt;</span><br><span class="line">        &lt;&#x2F;exclusions&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>对版本号进行统一：<br> 1.统一声明版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;mysql-connector.version&gt;5.1.47&lt;&#x2F;mysql-connector.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<p>2.引用前面声明的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;mysql-connector.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库有本地仓库和远程仓库，远程仓库包含私服、中央仓库、中央仓库的镜像。</p>
<p>仓库中存储的文件有 Maven 的插件、我们自己开发的项目的模块、第三方框架或工具的 jar 包</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Maven 生命周期定义了各个构建缓解的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。</p>
<p>有3套相互独立的生命周期，分别是：</p>
<p>\1. Clean Lifecycle 在进行真正的构建之前进行的一些清理工具。</p>
<p>\2. Default Lifecycle 构建的核心部分，编译，测试，打包，安装部署等等。</p>
<p>\3. Site Lifecycle 生成项目报告，站点，发布站点</p>
<p>它们是相互独立的，你可以仅仅调用 clean 来清理工作目录，仅仅调用 site 来生成站点。也可以直接运行 mvn clean install site 运行所有这三套声明周期</p>
<p>Clean 生命周期的阶段：</p>
<p>\1. pre-clean 执行一些需要在 clean 之前完成的工作</p>
<p>\2. clean 移除所有上一次构建生成的文件</p>
<p>\3. post-clean 执行一些需要在 clean 之后立刻完成的工作</p>
<p>Site 生命周期的阶段：</p>
<p>\1.   pre-site 执行一些需要在生成站点文档之前完成的工作</p>
<p>\2.   site 生成项目的站点文档</p>
<p>\3.   post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</p>
<p>\4.   site-deploy 将生成的站点文档部署到特定的服务器上</p>
<p>Default 生命周期的阶段</p>
<p>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：</p>
<p>validate</p>
<p>generate-sources</p>
<p>process-sources</p>
<p>generate-resources</p>
<p>process-resources 复制并处理资源文件，至目标目录，准备打包</p>
<p>compile 编译项目的源代码</p>
<p>process-classes</p>
<p>generate-test-sources</p>
<p>process-test-sources</p>
<p>generate-test-resources</p>
<p>process-test-resources 复制并处理资源文件，至目标测试目录</p>
<p>test-compile 编译测试源代码</p>
<p>process-test-classes</p>
<p>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署</p>
<p>prepare-package</p>
<p>package 接受编译好的代码，打包成可发布的格式，如 JAR</p>
<p>pre-integration-test</p>
<p>integration-test</p>
<p>verify</p>
<p>install 将包安装至本地仓库，以让其他项目依赖</p>
<p>deploy 将最终的包复制到远程的仓库，以让其他开发人员与项目共享或部署到服务器上运行</p>
<p>运行任何一个阶段的时候，它前面的所有阶段都会被运行</p>
<h3 id="插件和目标"><a href="#插件和目标" class="headerlink" title="插件和目标"></a>插件和目标</h3><p>Maven 的核心仅仅定义了抽象的声明周期，具体的任务都是交给插件完成的。</p>
<p>每个插件都能实现多个功能，每个功能就是一个插件目标</p>
<p>Maven 的声明周期与插件目标相互绑定，以完成某个具体的构建任务</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>非 compile 范文的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。</p>
<table>
<thead>
<tr>
<th><strong>工程</strong></th>
<th><strong>依赖</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Hello</td>
<td><code>&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></td>
</tr>
<tr>
<td>HelloFriend</td>
<td><code>&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></td>
</tr>
<tr>
<td>MakeFriend</td>
<td><code>&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.0&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></td>
</tr>
</tbody></table>
<p>如果将各模块的版本统一为 4.9，各个模块单独修改是不可取的，可以使用继承机制将依赖信息统一提取到父工程模块中进行统一管理。</p>
<h4 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h4><p>1.创建父工程：打包方式设置为 pom</p>
<p>2.在子工程中引用父工程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;!-- 父工程坐标 --&gt;</span><br><span class="line">    &lt;groupId&gt;...&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;...&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;...&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;relativePath&gt;从当前目录到父项目的 pom.xml文件的相对路径&lt;&#x2F;relativePath&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>

<p>如果此时子工程的 groupId 和 version 和父工程重复则可以删除</p>
<p>3.在父工程中管理依赖<br> 将 Parent 项目中的 dependencies 标签，用 dependencyManagement 标签括起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>在子项目中重新制定需要的依赖，删除范围和版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="聚合-多模块"><a href="#聚合-多模块" class="headerlink" title="聚合(多模块)"></a>聚合(多模块)</h3><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需药逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。</p>
<p>配置聚合：</p>
<p>在总的聚合工程中使用 modules/module 标签组合，指定模块工程的相对路径集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;test&lt;&#x2F;module&gt;</span><br><span class="line">    &lt;module&gt;b&lt;&#x2F;module&gt;</span><br><span class="line">&lt;&#x2F;modules&gt;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/27/Maven%E7%9F%A5%E8%AF%86%E5%BA%93/" data-id="cki8eocx40003nohxfe5qb4ch" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/01/Docker%E6%95%99%E7%A8%8B%E8%AE%B2%E8%A7%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/30/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/27/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/13/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/30/Redis%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>